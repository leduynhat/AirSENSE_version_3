

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->

<!-- Mirrored from docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/nvs_flash.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 29 Feb 2020 06:26:21 GMT -->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Non-volatile storage library &mdash; ESP-IDF Programming Guide v4.1-dev-2071-gf91080637 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../../../../../media.readthedocs.com/javascript/readthedocs-doc-embed.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="NVS Partition Generator Utility" href="nvs_partition_gen.html" />
    <link rel="prev" title="Manufacturing Utility" href="mass_mfg.html" /> 

<!-- RTD Extra Head -->

<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link rel="canonical" href="nvs_flash.html" />

<link rel="stylesheet" href="../../../../../../../media.readthedocs.com/css/readthedocs-doc-embed.css" type="text/css" />

<script type="text/javascript" src="../../_static/readthedocs-data.js"></script>

<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = "api-reference/storage/nvs_flash"
READTHEDOCS_DATA['source_suffix'] = ".rst"
</script>

<script type="text/javascript" src="../../../../../../../media.readthedocs.com/javascript/readthedocs-analytics.js"></script>

<!-- end RTD <extrahead> -->
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index-2.html" class="icon icon-home"> ESP-IDF Programming Guide
          

          
            
            <img src="../../_static/espressif-logo.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="https://docs.espressif.com/projects/esp-idf/en/latest/search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">Get Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../peripherals/index.html">Peripherals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">Provisioning</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Storage</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="fatfs.html">FAT Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="mass_mfg.html">Mass Manufacturing Utility</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Non-Volatile Storage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#internals">Internals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nvs-encryption">NVS Encryption</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nvs-partition-generator-utility">NVS Partition Generator Utility</a></li>
<li class="toctree-l4"><a class="reference internal" href="#application-example">Application Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference">API Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="nvs_partition_gen.html">NVS Partition Generation Utility</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdmmc.html">SD/SDIO/MMC Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi_flash.html">SPI Flash and Partition APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="spiffs.html">SPIFFS Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="vfs.html">Virtual Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="wear-levelling.html">Wear Levelling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../system/index.html">System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">Configuration Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">Error Codes Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">H/W Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../esp32s2.html">ESP32-S2 Preview Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">Libraries and Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">Copyrights</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">语言/Languages</a></li>
<li class="toctree-l1"><a class="reference external" href="https://readthedocs.com/projects/espressif-esp-idf/downloads/">Guide Downloads</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index-2.html">ESP-IDF Programming Guide</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index-2.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">API Reference</a> &raquo;</li>
        
          <li><a href="index.html">Storage API</a> &raquo;</li>
        
      <li>Non-volatile storage library</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/espressif/esp-idf/blob/master/docs/en/api-reference/storage/nvs_flash.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="non-volatile-storage-library">
<h1>Non-volatile storage library<a class="headerlink" href="#non-volatile-storage-library" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/api-reference/storage/nvs_flash.html">[中文]</a></p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Non-volatile storage (NVS) library is designed to store key-value pairs in flash. This section introduces some concepts used by NVS.</p>
<div class="section" id="underlying-storage">
<h3>Underlying storage<a class="headerlink" href="#underlying-storage" title="Permalink to this headline">¶</a></h3>
<p>Currently, NVS uses a portion of main flash memory through <code class="docutils literal notranslate"><span class="pre">spi_flash_{read|write|erase}</span></code> APIs. The library uses all the partitions with <code class="docutils literal notranslate"><span class="pre">data</span></code> type and <code class="docutils literal notranslate"><span class="pre">nvs</span></code> subtype. The application can choose to use the partition with the label <code class="docutils literal notranslate"><span class="pre">nvs</span></code> through the <code class="docutils literal notranslate"><span class="pre">nvs_open</span></code> API function or any other partition by specifying its name using the <code class="docutils literal notranslate"><span class="pre">nvs_open_from_part</span></code> API function.</p>
<p>Future versions of this library may have other storage backends to keep data in another flash chip (SPI or I2C), RTC, FRAM, etc.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if an NVS partition is truncated (for example, when the partition table layout is changed), its contents should be erased. ESP-IDF build system provides a <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">erase_flash</span></code> target to erase all contents of the flash chip.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">NVS works best for storing many small values, rather than a few large values of the type ‘string’ and ‘blob’. If you need to store large blobs or strings, consider using the facilities provided by the FAT filesystem on top of the wear levelling library.</p>
</div>
</div>
<div class="section" id="keys-and-values">
<h3>Keys and values<a class="headerlink" href="#keys-and-values" title="Permalink to this headline">¶</a></h3>
<p>NVS operates on key-value pairs. Keys are ASCII strings; the maximum key length is currently 15 characters. Values can have one of the following types:</p>
<ul class="simple">
<li>integer types: <code class="docutils literal notranslate"><span class="pre">uint8_t</span></code>, <code class="docutils literal notranslate"><span class="pre">int8_t</span></code>, <code class="docutils literal notranslate"><span class="pre">uint16_t</span></code>, <code class="docutils literal notranslate"><span class="pre">int16_t</span></code>, <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code>, <code class="docutils literal notranslate"><span class="pre">int32_t</span></code>, <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, <code class="docutils literal notranslate"><span class="pre">int64_t</span></code></li>
<li>zero-terminated string</li>
<li>variable length binary data (blob)</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">String values are currently limited to 4000 bytes. This includes the null terminator. Blob values are limited to 508000 bytes or 97.6% of the partition size - 4000 bytes, whichever is lower.</p>
</div>
<p>Additional types, such as <code class="docutils literal notranslate"><span class="pre">float</span></code> and <code class="docutils literal notranslate"><span class="pre">double</span></code> might be added later.</p>
<p>Keys are required to be unique. Assigning a new value to an existing key works as follows:</p>
<ul class="simple">
<li>if the new value is of the same type as the old one, value is updated</li>
<li>if the new value has a different data type, an error is returned</li>
</ul>
<p>Data type check is also performed when reading a value. An error is returned if the data type of the read operation does not match the data type of the value.</p>
</div>
<div class="section" id="namespaces">
<h3>Namespaces<a class="headerlink" href="#namespaces" title="Permalink to this headline">¶</a></h3>
<p>To mitigate potential conflicts in key names between different components, NVS assigns each key-value pair to one of namespaces. Namespace names follow the same rules as key names, i.e., the maximum length is 15 characters. Namespace name is specified in the <code class="docutils literal notranslate"><span class="pre">nvs_open</span></code> or <code class="docutils literal notranslate"><span class="pre">nvs_open_from_part</span></code> call. This call returns an opaque handle, which is used in subsequent calls to the <code class="docutils literal notranslate"><span class="pre">nvs_get_*</span></code>, <code class="docutils literal notranslate"><span class="pre">nvs_set_*</span></code>, and <code class="docutils literal notranslate"><span class="pre">nvs_commit</span></code> functions. This way, a handle is associated with a namespace, and key names will not collide with same names in other namespaces.
Please note that the namespaces with the same name in different NVS partitions are considered as separate namespaces.</p>
</div>
<div class="section" id="security-tampering-and-robustness">
<h3>Security, tampering, and robustness<a class="headerlink" href="#security-tampering-and-robustness" title="Permalink to this headline">¶</a></h3>
<p>NVS is not directly compatible with the ESP32 flash encryption system. However, data can still be stored in encrypted form if NVS encryption is used together with ESP32 flash encryption. Please refer to <a class="reference internal" href="#nvs-encryption"><span class="std std-ref">NVS Encryption</span></a> for more details.</p>
<p>If NVS encryption is not used, it is possible for anyone with physical access to the flash chip to alter, erase, or add key-value pairs. With NVS encryption enabled, it is not possible to alter or add a key-value pair and get recognized as a valid pair without knowing corresponding NVS encryption keys. However, there is no tamper-resistance against the erase operation.</p>
<p>The library does try to recover from conditions when flash memory is in an inconsistent state. In particular, one should be able to power off the device at any point and time and then power it back on. This should not result in loss of data, except for the new key-value pair if it was being written at the moment of powering off. The library should also be able to initialize properly with any random data present in flash memory.</p>
</div>
</div>
<div class="section" id="internals">
<h2>Internals<a class="headerlink" href="#internals" title="Permalink to this headline">¶</a></h2>
<div class="section" id="log-of-key-value-pairs">
<h3>Log of key-value pairs<a class="headerlink" href="#log-of-key-value-pairs" title="Permalink to this headline">¶</a></h3>
<p>NVS stores key-value pairs sequentially, with new key-value pairs being added at the end. When a value of any given key has to be updated, a new key-value pair is added at the end of the log and the old key-value pair is marked as erased.</p>
</div>
<div class="section" id="pages-and-entries">
<h3>Pages and entries<a class="headerlink" href="#pages-and-entries" title="Permalink to this headline">¶</a></h3>
<p>NVS library uses two main entities in its operation: pages and entries. Page is a logical structure which stores a portion of the overall log. Logical page corresponds to one physical sector of flash memory. Pages which are in use have a <em>sequence number</em> associated with them. Sequence numbers impose an ordering on pages. Higher sequence numbers correspond to pages which were created later. Each page can be in one of the following states:</p>
<dl class="docutils">
<dt>Empty/uninitialized</dt>
<dd>Flash storage for the page is empty (all bytes are <code class="docutils literal notranslate"><span class="pre">0xff</span></code>). Page is not used to store any data at this point and does not have a sequence number.</dd>
<dt>Active</dt>
<dd>Flash storage is initialized, page header has been written to flash, page has a valid sequence number. Page has some empty entries and data can be written there. No more than one page can be in this state at any given moment.</dd>
<dt>Full</dt>
<dd>Flash storage is in a consistent state and is filled with key-value pairs.
Writing new key-value pairs into this page is not possible. It is still possible to mark some key-value pairs as erased.</dd>
<dt>Erasing</dt>
<dd>Non-erased key-value pairs are being moved into another page so that the current page can be erased. This is a transient state, i.e., page should never stay in this state at the time when any API call returns. In case of a sudden power off, the move-and-erase process will be completed upon the next power-on.</dd>
<dt>Corrupted</dt>
<dd>Page header contains invalid data, and further parsing of page data was canceled. Any items previously written into this page will not be accessible. The corresponding flash sector will not be erased immediately and will be kept along with sectors in <em>uninitialized</em> state for later use. This may be useful for debugging.</dd>
</dl>
<p>Mapping from flash sectors to logical pages does not have any particular order. The library will inspect sequence numbers of pages found in each flash sector and organize pages in a list based on these numbers.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+--------+</span>     <span class="o">+--------+</span>     <span class="o">+--------+</span>     <span class="o">+--------+</span>
<span class="o">|</span> <span class="n">Page</span> <span class="mi">1</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">Page</span> <span class="mi">2</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">Page</span> <span class="mi">3</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">Page</span> <span class="mi">4</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">Full</span>   <span class="o">+---&gt;</span> <span class="o">|</span> <span class="n">Full</span>   <span class="o">+---&gt;</span> <span class="o">|</span> <span class="n">Active</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">Empty</span>  <span class="o">|</span>   <span class="o">&lt;-</span> <span class="n">states</span>
<span class="o">|</span> <span class="c1">#11    |     | #12    |     | #14    |     |        |   &lt;- sequence numbers</span>
<span class="o">+---+----+</span>     <span class="o">+----+---+</span>     <span class="o">+----+---+</span>     <span class="o">+---+----+</span>
    <span class="o">|</span>               <span class="o">|</span>              <span class="o">|</span>             <span class="o">|</span>
    <span class="o">|</span>               <span class="o">|</span>              <span class="o">|</span>             <span class="o">|</span>
    <span class="o">|</span>               <span class="o">|</span>              <span class="o">|</span>             <span class="o">|</span>
<span class="o">+---</span><span class="n">v</span><span class="o">------+</span>  <span class="o">+-----</span><span class="n">v</span><span class="o">----+</span>  <span class="o">+------</span><span class="n">v</span><span class="o">---+</span>  <span class="o">+------</span><span class="n">v</span><span class="o">---+</span>
<span class="o">|</span> <span class="n">Sector</span> <span class="mi">3</span> <span class="o">|</span>  <span class="o">|</span> <span class="n">Sector</span> <span class="mi">0</span> <span class="o">|</span>  <span class="o">|</span> <span class="n">Sector</span> <span class="mi">2</span> <span class="o">|</span>  <span class="o">|</span> <span class="n">Sector</span> <span class="mi">1</span> <span class="o">|</span>    <span class="o">&lt;-</span> <span class="n">physical</span> <span class="n">sectors</span>
<span class="o">+----------+</span>  <span class="o">+----------+</span>  <span class="o">+----------+</span>  <span class="o">+----------+</span>
</pre></div>
</div>
</div>
<div class="section" id="structure-of-a-page">
<h3>Structure of a page<a class="headerlink" href="#structure-of-a-page" title="Permalink to this headline">¶</a></h3>
<p>For now, we assume that flash sector size is 4096 bytes and that ESP32 flash encryption hardware operates on 32-byte blocks. It is possible to introduce some settings configurable at compile-time (e.g., via menuconfig) to accommodate flash chips with different sector sizes (although it is not clear if other components in the system, e.g., SPI flash driver and SPI flash cache can support these other sizes).</p>
<p>Page consists of three parts: header, entry state bitmap, and entries themselves. To be compatible with ESP32 flash encryption, entry size is 32 bytes. For integer types, entry holds one key-value pair. For strings and blobs, an entry holds part of key-value pair (more on that in the entry structure description).</p>
<p>The following diagram illustrates the page structure. Numbers in parentheses indicate the size of each part in bytes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+-----------+--------------+-------------+-------------------------+</span>
<span class="o">|</span> <span class="n">State</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">Seq</span><span class="o">.</span> <span class="n">no</span><span class="o">.</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">version</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Unused</span> <span class="p">(</span><span class="mi">19</span><span class="p">)</span> <span class="o">|</span> <span class="n">CRC32</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span>   <span class="n">Header</span> <span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="o">+-----------+--------------+-------------+-------------------------+</span>
<span class="o">|</span>                <span class="n">Entry</span> <span class="n">state</span> <span class="n">bitmap</span> <span class="p">(</span><span class="mi">32</span><span class="p">)</span>                           <span class="o">|</span>
<span class="o">+------------------------------------------------------------------+</span>
<span class="o">|</span>                       <span class="n">Entry</span> <span class="mi">0</span> <span class="p">(</span><span class="mi">32</span><span class="p">)</span>                               <span class="o">|</span>
<span class="o">+------------------------------------------------------------------+</span>
<span class="o">|</span>                       <span class="n">Entry</span> <span class="mi">1</span> <span class="p">(</span><span class="mi">32</span><span class="p">)</span>                               <span class="o">|</span>
<span class="o">+------------------------------------------------------------------+</span>
<span class="o">/</span>                                                                  <span class="o">/</span>
<span class="o">/</span>                                                                  <span class="o">/</span>
<span class="o">+------------------------------------------------------------------+</span>
<span class="o">|</span>                       <span class="n">Entry</span> <span class="mi">125</span> <span class="p">(</span><span class="mi">32</span><span class="p">)</span>                             <span class="o">|</span>
<span class="o">+------------------------------------------------------------------+</span>
</pre></div>
</div>
<p>Page header and entry state bitmap are always written to flash unencrypted. Entries are encrypted if flash encryption feature of ESP32 is used.</p>
<p>Page state values are defined in such a way that changing state is possible by writing 0 into some of the bits. Therefore it is not necessary to erase the page to change its state unless that is a change to the <em>erased</em> state.</p>
<p>The version field in the header reflects the NVS format version used. For backward compatibility reasons, it is decremented for every version upgrade starting at 0xff (i.e., 0xff for version-1, 0xfe for version-2 and so on).</p>
<p>CRC32 value in the header is calculated over the part which does not include a state value (bytes 4 to 28). The unused part is currently filled with <code class="docutils literal notranslate"><span class="pre">0xff</span></code> bytes.</p>
<p>The following sections describe the structure of entry state bitmap and entry itself.</p>
</div>
<div class="section" id="entry-and-entry-state-bitmap">
<h3>Entry and entry state bitmap<a class="headerlink" href="#entry-and-entry-state-bitmap" title="Permalink to this headline">¶</a></h3>
<p>Each entry can be in one of the following three states represented with two bits in the entry state bitmap. The final four bits in the bitmap (256 - 2 * 126) are not used.</p>
<dl class="docutils">
<dt>Empty (2’b11)</dt>
<dd>Nothing is written into the specific entry yet. It is in an uninitialized state (all bytes are <code class="docutils literal notranslate"><span class="pre">0xff</span></code>).</dd>
<dt>Written (2’b10)</dt>
<dd>A key-value pair (or part of key-value pair which spans multiple entries) has been written into the entry.</dd>
<dt>Erased (2’b00)</dt>
<dd>A key-value pair in this entry has been discarded. Contents of this entry will not be parsed anymore.</dd>
</dl>
</div>
<div class="section" id="structure-of-entry">
<span id="id1"></span><h3>Structure of entry<a class="headerlink" href="#structure-of-entry" title="Permalink to this headline">¶</a></h3>
<p>For values of primitive types (currently integers from 1 to 8 bytes long), entry holds one key-value pair. For string and blob types, entry holds part of the whole key-value pair. For strings, in case when a key-value pair spans multiple entries, all entries are stored in the same page. Blobs are allowed to span over multiple pages by dividing them into smaller chunks. For tracking these chunks, an additional fixed length metadata entry is stored called “blob index”. Earlier formats of blobs are still supported (can be read and modified). However, once the blobs are modified, they are stored using the new format.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+--------+----------+----------+----------------+-----------+---------------+----------+</span>
<span class="o">|</span> <span class="n">NS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Type</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Span</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">ChunkIndex</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">CRC32</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span>    <span class="n">Key</span> <span class="p">(</span><span class="mi">16</span><span class="p">)</span>   <span class="o">|</span> <span class="n">Data</span> <span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
<span class="o">+--------+----------+----------+----------------+-----------+---------------+----------+</span>

                                         <span class="n">Primitive</span>  <span class="o">+--------------------------------+</span>
                                        <span class="o">+--------&gt;</span>  <span class="o">|</span>     <span class="n">Data</span> <span class="p">(</span><span class="mi">8</span><span class="p">)</span>                   <span class="o">|</span>
                                        <span class="o">|</span> <span class="n">Types</span>     <span class="o">+--------------------------------+</span>
                   <span class="o">+-&gt;</span> <span class="n">Fixed</span> <span class="n">length</span> <span class="o">--</span>
                   <span class="o">|</span>                    <span class="o">|</span>           <span class="o">+---------+--------------+---------------+-------+</span>
                   <span class="o">|</span>                    <span class="o">+--------&gt;</span>  <span class="o">|</span> <span class="n">Size</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">ChunkCount</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">|</span> <span class="n">ChunkStart</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Rsv</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">|</span>
    <span class="n">Data</span> <span class="nb">format</span> <span class="o">---+</span>                    <span class="n">Blob</span> <span class="n">Index</span>  <span class="o">+---------+--------------+---------------+-------+</span>
                   <span class="o">|</span>
                   <span class="o">|</span>                             <span class="o">+----------+---------+-----------+</span>
                   <span class="o">+-&gt;</span>   <span class="n">Variable</span> <span class="n">length</span>   <span class="o">--&gt;</span>   <span class="o">|</span> <span class="n">Size</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">Rsv</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">CRC32</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
                        <span class="p">(</span><span class="n">Strings</span><span class="p">,</span> <span class="n">Blob</span> <span class="n">Data</span><span class="p">)</span>     <span class="o">+----------+---------+-----------+</span>
</pre></div>
</div>
<p>Individual fields in entry structure have the following meanings:</p>
<dl class="docutils">
<dt>NS</dt>
<dd>Namespace index for this entry. For more information on this value, see the section on namespaces implementation.</dd>
<dt>Type</dt>
<dd>One byte indicating the value data type. See the <code class="docutils literal notranslate"><span class="pre">ItemType</span></code> enumeration in <code class="docutils literal notranslate"><span class="pre">nvs_types.h</span></code> for possible values.</dd>
<dt>Span</dt>
<dd>Number of entries used by this key-value pair. For integer types, this is equal to 1. For strings and blobs, this depends on value length.</dd>
<dt>ChunkIndex</dt>
<dd>Used to store the index of a blob-data chunk for blob types. For other types, this should be <code class="docutils literal notranslate"><span class="pre">0xff</span></code>.</dd>
<dt>CRC32</dt>
<dd>Checksum calculated over all the bytes in this entry, except for the CRC32 field itself.</dd>
<dt>Key</dt>
<dd>Zero-terminated ASCII string containing a key name. Maximum string length is 15 bytes, excluding a zero terminator.</dd>
<dt>Data</dt>
<dd><p class="first">For integer types, this field contains the value itself. If the value itself is shorter than 8 bytes, it is padded to the right, with unused bytes filled with <code class="docutils literal notranslate"><span class="pre">0xff</span></code>.</p>
<p>For “blob index” entry, these 8 bytes hold the following information about data-chunks:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>Size</dt>
<dd>(Only for blob index.) Size, in bytes, of complete blob data.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ChunkCount</dt>
<dd>(Only for blob index.) Total number of blob-data chunks into which the blob was divided during storage.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ChunkStart</dt>
<dd>(Only for blob index.) ChunkIndex of the first blob-data chunk of this blob. Subsequent chunks have chunkIndex incrementally allocated (step of 1).</dd>
</dl>
</li>
</ul>
<p>For string and blob data chunks, these 8 bytes hold additional data about the value, which are described below:</p>
<ul class="last simple">
<li><dl class="first docutils">
<dt>Size</dt>
<dd>(Only for strings and blobs.) Size, in bytes, of actual data. For strings, this includes zero terminators.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>CRC32</dt>
<dd>(Only for strings and blobs.) Checksum calculated over all bytes of data.</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Variable length values (strings and blobs) are written into subsequent entries, 32 bytes per entry. The <cite>Span</cite> field of the first entry indicates how many entries are used.</p>
</div>
<div class="section" id="id2">
<h3>Namespaces<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>As mentioned above, each key-value pair belongs to one of the namespaces. Namespace identifiers (strings) are stored as keys of key-value pairs in namespace with index 0. Values corresponding to these keys are indexes of these namespaces.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+-------------------------------------------+</span>
<span class="o">|</span> <span class="n">NS</span><span class="o">=</span><span class="mi">0</span> <span class="n">Type</span><span class="o">=</span><span class="n">uint8_t</span> <span class="n">Key</span><span class="o">=</span><span class="s2">&quot;wifi&quot;</span> <span class="n">Value</span><span class="o">=</span><span class="mi">1</span>      <span class="o">|</span>   <span class="n">Entry</span> <span class="n">describing</span> <span class="n">namespace</span> <span class="s2">&quot;wifi&quot;</span>
<span class="o">+-------------------------------------------+</span>
<span class="o">|</span> <span class="n">NS</span><span class="o">=</span><span class="mi">1</span> <span class="n">Type</span><span class="o">=</span><span class="n">uint32_t</span> <span class="n">Key</span><span class="o">=</span><span class="s2">&quot;channel&quot;</span> <span class="n">Value</span><span class="o">=</span><span class="mi">6</span>  <span class="o">|</span>   <span class="n">Key</span> <span class="s2">&quot;channel&quot;</span> <span class="ow">in</span> <span class="n">namespace</span> <span class="s2">&quot;wifi&quot;</span>
<span class="o">+-------------------------------------------+</span>
<span class="o">|</span> <span class="n">NS</span><span class="o">=</span><span class="mi">0</span> <span class="n">Type</span><span class="o">=</span><span class="n">uint8_t</span> <span class="n">Key</span><span class="o">=</span><span class="s2">&quot;pwm&quot;</span> <span class="n">Value</span><span class="o">=</span><span class="mi">2</span>       <span class="o">|</span>   <span class="n">Entry</span> <span class="n">describing</span> <span class="n">namespace</span> <span class="s2">&quot;pwm&quot;</span>
<span class="o">+-------------------------------------------+</span>
<span class="o">|</span> <span class="n">NS</span><span class="o">=</span><span class="mi">2</span> <span class="n">Type</span><span class="o">=</span><span class="n">uint16_t</span> <span class="n">Key</span><span class="o">=</span><span class="s2">&quot;channel&quot;</span> <span class="n">Value</span><span class="o">=</span><span class="mi">20</span> <span class="o">|</span>   <span class="n">Key</span> <span class="s2">&quot;channel&quot;</span> <span class="ow">in</span> <span class="n">namespace</span> <span class="s2">&quot;pwm&quot;</span>
<span class="o">+-------------------------------------------+</span>
</pre></div>
</div>
</div>
<div class="section" id="item-hash-list">
<h3>Item hash list<a class="headerlink" href="#item-hash-list" title="Permalink to this headline">¶</a></h3>
<p>To reduce the number of reads from flash memory, each member of the Page class maintains a list of pairs: item index; item hash. This list makes searches much quicker. Instead of iterating over all entries, reading them from flash one at a time, <code class="docutils literal notranslate"><span class="pre">Page::findItem</span></code> first performs a search for the item hash in the hash list. This gives the item index within the page if such an item exists. Due to a hash collision, it is possible that a different item will be found. This is handled by falling back to iteration over items in flash.</p>
<p>Each node in the hash list contains a 24-bit hash and 8-bit item index. Hash is calculated based on item namespace, key name, and ChunkIndex. CRC32 is used for calculation; the result is truncated to 24 bits. To reduce the overhead for storing 32-bit entries in a linked list, the list is implemented as a double-linked list of arrays. Each array holds 29 entries, for the total size of 128 bytes, together with linked list pointers and a 32-bit count field. The minimum amount of extra RAM usage per page is therefore 128 bytes; maximum is 640 bytes.</p>
</div>
</div>
<div class="section" id="nvs-encryption">
<span id="id3"></span><h2>NVS Encryption<a class="headerlink" href="#nvs-encryption" title="Permalink to this headline">¶</a></h2>
<p>Data stored in NVS partitions can be encrypted using AES-XTS in the manner similar to the one mentioned in disk encryption standard IEEE P1619. For the purpose of encryption, each entry is treated as one <cite>sector</cite> and relative address of the entry (w.r.t. partition-start) is fed to the encryption algorithm as <cite>sector-number</cite>. The keys required for NVS encryption are stored in yet another partition, which is protected using <a class="reference internal" href="../../security/flash-encryption.html"><span class="doc">Flash Encryption</span></a>. Therefore, enabling <a class="reference internal" href="../../security/flash-encryption.html"><span class="doc">Flash Encryption</span></a> is a prerequisite for NVS encryption.</p>
<div class="section" id="nvs-key-partition">
<span id="id4"></span><h3>NVS key partition<a class="headerlink" href="#nvs-key-partition" title="Permalink to this headline">¶</a></h3>
<p>An application requiring NVS encryption support needs to be compiled with a key-partition of the type <cite>data</cite> and subtype <cite>key</cite>. This partition should be marked as <cite>encrypted</cite>. Refer to <a class="reference internal" href="../../api-guides/partition-tables.html"><span class="doc">Partition Tables</span></a> for more details. The size of the partition should be 4096 bytes (minimum partition size). The structure of this partition is depicted below.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+-----------+--------------+-------------+----+</span>
<span class="o">|</span>              <span class="n">XTS</span> <span class="n">encryption</span> <span class="n">key</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>         <span class="o">|</span>
<span class="o">+---------------------------------------------+</span>
<span class="o">|</span>              <span class="n">XTS</span> <span class="n">tweak</span> <span class="n">key</span> <span class="p">(</span><span class="mi">32</span><span class="p">)</span>             <span class="o">|</span>
<span class="o">+---------------------------------------------+</span>
<span class="o">|</span>                  <span class="n">CRC32</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>                   <span class="o">|</span>
<span class="o">+---------------------------------------------+</span>
</pre></div>
</div>
<p>This partition can be generated using <cite>nvs partition generator</cite> utility and flashed onto the device. Since the partition is marked <cite>encrypted</cite> and <a class="reference internal" href="../../security/flash-encryption.html"><span class="doc">Flash Encryption</span></a> is enabled, bootloader will encrypt this partition using flash encryption key on the first boot. Alternatively, the keys can be generated after startup using the <code class="docutils literal notranslate"><span class="pre">nvs_flash_generate_keys</span></code> API function provided by <code class="docutils literal notranslate"><span class="pre">nvs_flash.h</span></code>, which will then write those keys onto the key-partition in encrypted form.</p>
<p>It is possible for an application to use different keys for different NVS partitions and thereby have multiple key-partitions. However, it is a responsibility of the application to provide correct key-partition/keys for the purpose of encryption/decryption.</p>
</div>
<div class="section" id="encrypted-read-write">
<h3>Encrypted Read/Write<a class="headerlink" href="#encrypted-read-write" title="Permalink to this headline">¶</a></h3>
<p>The same NVS API functions <code class="docutils literal notranslate"><span class="pre">nvs_get_*</span></code> or <code class="docutils literal notranslate"><span class="pre">nvs_set_*</span></code> can be used for reading of, and writing to an encrypted nvs partition as well. However, the API functions for initialising NVS partitions are different: <code class="docutils literal notranslate"><span class="pre">nvs_flash_secure_init</span></code> and <code class="docutils literal notranslate"><span class="pre">nvs_flash_secure_init_partition</span></code> instead of <code class="docutils literal notranslate"><span class="pre">nvs_flash_init</span></code> and <code class="docutils literal notranslate"><span class="pre">nvs_flash_init_partition</span></code> respectively. The <code class="docutils literal notranslate"><span class="pre">nvs_sec_cfg_t</span></code> structure required for these API functions can be populated using <code class="docutils literal notranslate"><span class="pre">nvs_flash_generate_keys</span></code> or <code class="docutils literal notranslate"><span class="pre">nvs_flash_read_security_cfg</span></code>.</p>
<p>Applications are expected to follow the steps below in order to perform NVS read/write operations with encryption enabled.</p>
<blockquote>
<div><ol class="arabic simple">
<li>Find key partition and NVS data partition using <code class="docutils literal notranslate"><span class="pre">esp_partition_find*</span></code> API functions.</li>
<li>Populate the <code class="docutils literal notranslate"><span class="pre">nvs_sec_cfg_t</span></code> struct using the <code class="docutils literal notranslate"><span class="pre">nvs_flash_read_security_cfg</span></code> or <code class="docutils literal notranslate"><span class="pre">nvs_flash_generate_keys</span></code> API functions.</li>
<li>Initialise NVS flash partition using the <code class="docutils literal notranslate"><span class="pre">nvs_flash_secure_init</span></code> or <code class="docutils literal notranslate"><span class="pre">nvs_flash_secure_init_partition</span></code> API functions.</li>
<li>Open a namespace using the <code class="docutils literal notranslate"><span class="pre">nvs_open</span></code> or <code class="docutils literal notranslate"><span class="pre">nvs_open_from_part</span></code> API functions.</li>
<li>Perform NVS read/write operations using <code class="docutils literal notranslate"><span class="pre">nvs_get_*</span></code> or <code class="docutils literal notranslate"><span class="pre">nvs_set_*</span></code>.</li>
<li>Deinitialise an NVS partition using <code class="docutils literal notranslate"><span class="pre">nvs_flash_deinit</span></code>.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="nvs-iterators">
<h3>NVS iterators<a class="headerlink" href="#nvs-iterators" title="Permalink to this headline">¶</a></h3>
<p>Iterators allow to list key-value pairs stored in NVS, based on specified partition name, namespace, and data type.</p>
<p>There are the following functions available:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">nvs_entry_find</span></code> returns an opaque handle, which is used in subsequent calls to the <code class="docutils literal notranslate"><span class="pre">nvs_entry_next</span></code> and <code class="docutils literal notranslate"><span class="pre">nvs_entry_info</span></code> functions.</li>
<li><code class="docutils literal notranslate"><span class="pre">nvs_entry_next</span></code> returns iterator to the next key-value pair.</li>
<li><code class="docutils literal notranslate"><span class="pre">nvs_entry_info</span></code> returns information about each key-value pair</li>
</ul>
<p>If none or no other key-value pair was found for given criteria, <code class="docutils literal notranslate"><span class="pre">nvs_entry_find</span></code> and <code class="docutils literal notranslate"><span class="pre">nvs_entry_next</span></code> return NULL. In that case, the iterator does not have to be released. If the iterator is no longer needed, you can release it by using the function <code class="docutils literal notranslate"><span class="pre">nvs_release_iterator</span></code>.</p>
</div>
</div>
<div class="section" id="nvs-partition-generator-utility">
<h2>NVS Partition Generator Utility<a class="headerlink" href="#nvs-partition-generator-utility" title="Permalink to this headline">¶</a></h2>
<p>This utility helps generate NVS partition binary files which can be flashed separately on a dedicated partition via a flashing utility. Key-value pairs to be flashed onto the partition can be provided via a CSV file. For more details, please refer to <a class="reference internal" href="nvs_partition_gen.html"><span class="doc">NVS Partition Generator Utility</span></a>.</p>
</div>
<div class="section" id="application-example">
<h2>Application Example<a class="headerlink" href="#application-example" title="Permalink to this headline">¶</a></h2>
<p>You can find two code examples in the <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/storage">storage</a> directory of ESP-IDF examples:</p>
<p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/storage/nvs_rw_value">storage/nvs_rw_value</a></p>
<blockquote>
<div><p>Demonstrates how to read a single integer value from, and write it to NVS.</p>
<p>The value checked in this example holds the number of the ESP32 module restarts. The value’s function as a counter is only possible due to its storing in NVS.</p>
<p>The example also shows how to check if a read / write operation was successful, or if a certain value has not been initialized in NVS. The diagnostic procedure is provided in plain text to help you track the program flow and capture any issues on the way.</p>
</div></blockquote>
<p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/storage/nvs_rw_blob">storage/nvs_rw_blob</a></p>
<blockquote>
<div><p>Demonstrates how to read a single integer value and a blob (binary large object), and write them to NVS to preserve this value between ESP32 module restarts.</p>
<blockquote>
<div><ul class="simple">
<li>value - tracks the number of the ESP32 module soft and hard restarts.</li>
<li>blob - contains a table with module run times. The table is read from NVS to dynamically allocated RAM. A new run time is added to the table on each manually triggered soft restart, and then the added run time is written to NVS. Triggering is done by pulling down GPIO0.</li>
</ul>
</div></blockquote>
<p>The example also shows how to implement the diagnostic procedure to check if the read / write operation was successful.</p>
</div></blockquote>
</div>
<div class="section" id="api-reference">
<h2>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="header-file">
<h3>Header File<a class="headerlink" href="#header-file" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/nvs_flash/include/nvs_flash.h">nvs_flash/include/nvs_flash.h</a></li>
</ul>
</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv414nvs_flash_initv">
<span id="_CPPv314nvs_flash_initv"></span><span id="_CPPv214nvs_flash_initv"></span><span id="nvs_flash_init__void"></span><span class="target" id="nvs__flash_8h_1a0c37702eca98ffe39ff4d8a47a0e093f"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_init</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414nvs_flash_initv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize the default NVS partition. </p>
<p>This API initialises the default NVS partition. The default NVS partition is the one that is labeled “nvs” in the partition table.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK if storage was successfully initialized.</li>
<li>ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages (which may happen if NVS partition was truncated)</li>
<li>ESP_ERR_NOT_FOUND if no partition with label “nvs” is found in the partition table</li>
<li>one of the error codes from the underlying flash storage driver </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424nvs_flash_init_partitionPKc">
<span id="_CPPv324nvs_flash_init_partitionPKc"></span><span id="_CPPv224nvs_flash_init_partitionPKc"></span><span id="nvs_flash_init_partition__cCP"></span><span class="target" id="nvs__flash_8h_1ae744286f362cca501e9f3cf753d538ea"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_init_partition</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>partition_label</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424nvs_flash_init_partitionPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize NVS flash storage for the specified partition. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK if storage was successfully initialized.</li>
<li>ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages (which may happen if NVS partition was truncated)</li>
<li>ESP_ERR_NOT_FOUND if specified partition is not found in the partition table</li>
<li>one of the error codes from the underlying flash storage driver </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">partition_label</span></code>: Label of the partition. Must be no longer than 16 characters.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416nvs_flash_deinitv">
<span id="_CPPv316nvs_flash_deinitv"></span><span id="_CPPv216nvs_flash_deinitv"></span><span id="nvs_flash_deinit__void"></span><span class="target" id="nvs__flash_8h_1ab0743d413ccfb038ea2cc78a151bbfb6"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_deinit</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416nvs_flash_deinitv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Deinitialize NVS storage for the default NVS partition. </p>
<p>Default NVS partition is the partition with “nvs” label in the partition table.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK on success (storage was deinitialized)</li>
<li>ESP_ERR_NVS_NOT_INITIALIZED if the storage was not initialized prior to this call </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426nvs_flash_deinit_partitionPKc">
<span id="_CPPv326nvs_flash_deinit_partitionPKc"></span><span id="_CPPv226nvs_flash_deinit_partitionPKc"></span><span id="nvs_flash_deinit_partition__cCP"></span><span class="target" id="nvs__flash_8h_1a16c7e9782bc34910db1e2811034a113c"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_deinit_partition</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>partition_label</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426nvs_flash_deinit_partitionPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Deinitialize NVS storage for the given NVS partition. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK on success</li>
<li>ESP_ERR_NVS_NOT_INITIALIZED if the storage for given partition was not initialized prior to this call </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">partition_label</span></code>: Label of the partition</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415nvs_flash_erasev">
<span id="_CPPv315nvs_flash_erasev"></span><span id="_CPPv215nvs_flash_erasev"></span><span id="nvs_flash_erase__void"></span><span class="target" id="nvs__flash_8h_1ac9e4c719ccdb0d92ba974012868435cf"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_erase</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415nvs_flash_erasev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Erase the default NVS partition. </p>
<p>This function erases all contents of the default NVS partition (one with label “nvs”)</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK on success</li>
<li>ESP_ERR_NOT_FOUND if there is no NVS partition labeled “nvs” in the partition table </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425nvs_flash_erase_partitionPKc">
<span id="_CPPv325nvs_flash_erase_partitionPKc"></span><span id="_CPPv225nvs_flash_erase_partitionPKc"></span><span id="nvs_flash_erase_partition__cCP"></span><span class="target" id="nvs__flash_8h_1aac0d1a70e1e4fb943c7a201bc27025b4"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_erase_partition</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>part_name</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425nvs_flash_erase_partitionPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Erase specified NVS partition. </p>
<p>This function erases all contents of specified NVS partition</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK on success</li>
<li>ESP_ERR_NOT_FOUND if there is no NVS partition with the specified name in the partition table </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">part_name</span></code>: Name (label) of the partition to be erased</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421nvs_flash_secure_initP13nvs_sec_cfg_t">
<span id="_CPPv321nvs_flash_secure_initP13nvs_sec_cfg_t"></span><span id="_CPPv221nvs_flash_secure_initP13nvs_sec_cfg_t"></span><span id="nvs_flash_secure_init__nvs_sec_cfg_tP"></span><span class="target" id="nvs__flash_8h_1a0ab41aa24c30907de227cfb31535071c"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_secure_init</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413nvs_sec_cfg_t" title="nvs_sec_cfg_t">nvs_sec_cfg_t</a> *<em>cfg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421nvs_flash_secure_initP13nvs_sec_cfg_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize the default NVS partition. </p>
<p>This API initialises the default NVS partition. The default NVS partition is the one that is labeled “nvs” in the partition table.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK if storage was successfully initialized.</li>
<li>ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages (which may happen if NVS partition was truncated)</li>
<li>ESP_ERR_NOT_FOUND if no partition with label “nvs” is found in the partition table</li>
<li>one of the error codes from the underlying flash storage driver </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>: Security configuration (keys) to be used for NVS encryption/decryption. If cfg is NULL, no encryption is used.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv431nvs_flash_secure_init_partitionPKcP13nvs_sec_cfg_t">
<span id="_CPPv331nvs_flash_secure_init_partitionPKcP13nvs_sec_cfg_t"></span><span id="_CPPv231nvs_flash_secure_init_partitionPKcP13nvs_sec_cfg_t"></span><span id="nvs_flash_secure_init_partition__cCP.nvs_sec_cfg_tP"></span><span class="target" id="nvs__flash_8h_1af14231de1efc20d250b0f953698350a5"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_secure_init_partition</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>partition_label</em>, <a class="reference internal" href="#_CPPv413nvs_sec_cfg_t" title="nvs_sec_cfg_t">nvs_sec_cfg_t</a> *<em>cfg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431nvs_flash_secure_init_partitionPKcP13nvs_sec_cfg_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize NVS flash storage for the specified partition. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK if storage was successfully initialized.</li>
<li>ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages (which may happen if NVS partition was truncated)</li>
<li>ESP_ERR_NOT_FOUND if specified partition is not found in the partition table</li>
<li>one of the error codes from the underlying flash storage driver </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">partition_label</span></code>: Label of the partition. Note that internally a reference to passed value is kept and it should be accessible for future operations</li>
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>: Security configuration (keys) to be used for NVS encryption/decryption. If cfg is null, no encryption/decryption is used. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423nvs_flash_generate_keysPK15esp_partition_tP13nvs_sec_cfg_t">
<span id="_CPPv323nvs_flash_generate_keysPK15esp_partition_tP13nvs_sec_cfg_t"></span><span id="_CPPv223nvs_flash_generate_keysPK15esp_partition_tP13nvs_sec_cfg_t"></span><span id="nvs_flash_generate_keys__esp_partition_tCP.nvs_sec_cfg_tP"></span><span class="target" id="nvs__flash_8h_1a1eb890121d0e1f76d9ba873783d53e51"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_generate_keys</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="spi_flash.html#_CPPv415esp_partition_t" title="esp_partition_t">esp_partition_t</a> *<em>partition</em>, <a class="reference internal" href="#_CPPv413nvs_sec_cfg_t" title="nvs_sec_cfg_t">nvs_sec_cfg_t</a> *<em>cfg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423nvs_flash_generate_keysPK15esp_partition_tP13nvs_sec_cfg_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Generate and store NVS keys in the provided esp partition. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>-ESP_OK, if cfg was read successfully; -or error codes from esp_partition_write/erase APIs. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">partition</span></code>: Pointer to partition structure obtained using esp_partition_find_first or esp_partition_get. Must be non-NULL. </li>
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>: Pointer to nvs security configuration structure. Pointer must be non-NULL. Generated keys will be populated in this structure.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv427nvs_flash_read_security_cfgPK15esp_partition_tP13nvs_sec_cfg_t">
<span id="_CPPv327nvs_flash_read_security_cfgPK15esp_partition_tP13nvs_sec_cfg_t"></span><span id="_CPPv227nvs_flash_read_security_cfgPK15esp_partition_tP13nvs_sec_cfg_t"></span><span id="nvs_flash_read_security_cfg__esp_partition_tCP.nvs_sec_cfg_tP"></span><span class="target" id="nvs__flash_8h_1ad2b9fc8e49a07eee8c83410686efad67"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_read_security_cfg</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="spi_flash.html#_CPPv415esp_partition_t" title="esp_partition_t">esp_partition_t</a> *<em>partition</em>, <a class="reference internal" href="#_CPPv413nvs_sec_cfg_t" title="nvs_sec_cfg_t">nvs_sec_cfg_t</a> *<em>cfg</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427nvs_flash_read_security_cfgPK15esp_partition_tP13nvs_sec_cfg_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read NVS security configuration from a partition. </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Provided parition is assumed to be marked ‘encrypted’.</dd>
<dt><strong>Return</strong></dt>
<dd>-ESP_OK, if cfg was read successfully; -ESP_ERR_NVS_KEYS_NOT_INITIALIZED, if the partition is not yet written with keys. -ESP_ERR_NVS_CORRUPT_KEY_PART, if the partition containing keys is found to be corrupt -or error codes from esp_partition_read API. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">partition</span></code>: Pointer to partition structure obtained using esp_partition_find_first or esp_partition_get. Must be non-NULL. </li>
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>: Pointer to nvs security configuration structure. Pointer must be non-NULL.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="structures">
<h3>Structures<a class="headerlink" href="#structures" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv413nvs_sec_cfg_t">
<span id="_CPPv313nvs_sec_cfg_t"></span><span id="_CPPv213nvs_sec_cfg_t"></span><span id="nvs_sec_cfg_t"></span><span class="target" id="structnvs__sec__cfg__t"></span><em class="property">struct </em><code class="descname">nvs_sec_cfg_t</code><a class="headerlink" href="#_CPPv413nvs_sec_cfg_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Key for encryption and decryption. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N13nvs_sec_cfg_t3ekyE">
<span id="_CPPv3N13nvs_sec_cfg_t3ekyE"></span><span id="_CPPv2N13nvs_sec_cfg_t3ekyE"></span><span id="nvs_sec_cfg_t::eky__uint8_tA"></span><span class="target" id="structnvs__sec__cfg__t_1aca7c1ea3cb7735702e159dbbd7059c0f"></span>uint8_t <code class="descname">eky</code>[<code class="descname">NVS_KEY_SIZE</code>]<a class="headerlink" href="#_CPPv4N13nvs_sec_cfg_t3ekyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>XTS encryption and decryption key </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N13nvs_sec_cfg_t3tkyE">
<span id="_CPPv3N13nvs_sec_cfg_t3tkyE"></span><span id="_CPPv2N13nvs_sec_cfg_t3tkyE"></span><span id="nvs_sec_cfg_t::tky__uint8_tA"></span><span class="target" id="structnvs__sec__cfg__t_1a2bcd305f3bdc0b10ea93c6c983073774"></span>uint8_t <code class="descname">tky</code>[<code class="descname">NVS_KEY_SIZE</code>]<a class="headerlink" href="#_CPPv4N13nvs_sec_cfg_t3tkyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>XTS tweak key </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="macros">
<h3>Macros<a class="headerlink" href="#macros" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.NVS_KEY_SIZE">
<span class="target" id="nvs__flash_8h_1a3c4e07a22cf5967ebf64fe7db4cec3bc"></span><code class="descname">NVS_KEY_SIZE</code><a class="headerlink" href="#c.NVS_KEY_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="id5">
<h3>Header File<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/nvs_flash/include/nvs.h">nvs_flash/include/nvs.h</a></li>
</ul>
</div>
<div class="section" id="id6">
<h3>Functions<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv410nvs_set_i812nvs_handle_tPKc6int8_t">
<span id="_CPPv310nvs_set_i812nvs_handle_tPKc6int8_t"></span><span id="_CPPv210nvs_set_i812nvs_handle_tPKc6int8_t"></span><span id="nvs_set_i8__nvs_handle_t.cCP.int8_t"></span><span class="target" id="nvs_8h_1a6a88f61dcb7d0dc2b76e0cbb019d1eca"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_i8</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, int8_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410nvs_set_i812nvs_handle_tPKc6int8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set value for given key </p>
<p>This family of functions set value for the key, given its name. Note that actual storage will not be updated until nvs_commit function is called.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK if value was set successfully</li>
<li>ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL</li>
<li>ESP_ERR_NVS_READ_ONLY if storage handle was opened as read only</li>
<li>ESP_ERR_NVS_INVALID_NAME if key name doesn’t satisfy constraints</li>
<li>ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is not enough space in the underlying storage to save the value</li>
<li>ESP_ERR_NVS_REMOVE_FAILED if the value wasn’t updated because flash write operation has failed. The value was written however, and update will be finished after re-initialization of nvs, provided that flash operation doesn’t fail again.</li>
<li>ESP_ERR_NVS_VALUE_TOO_LONG if the string value is too long </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: Handle obtained from nvs_open function. Handles that were opened read only cannot be used. </li>
<li><code class="docutils literal notranslate"><span class="pre">key</span></code>: Key name. Maximal length is determined by the underlying implementation, but is guaranteed to be at least 15 characters. Shouldn’t be empty. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value to set. For strings, the maximum length (including null character) is 4000 bytes.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410nvs_set_u812nvs_handle_tPKc7uint8_t">
<span id="_CPPv310nvs_set_u812nvs_handle_tPKc7uint8_t"></span><span id="_CPPv210nvs_set_u812nvs_handle_tPKc7uint8_t"></span><span id="nvs_set_u8__nvs_handle_t.cCP.uint8_t"></span><span class="target" id="nvs_8h_1a0305af52aebc7d263ca2403d22de69a9"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_u8</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, uint8_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410nvs_set_u812nvs_handle_tPKc7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411nvs_set_i1612nvs_handle_tPKc7int16_t">
<span id="_CPPv311nvs_set_i1612nvs_handle_tPKc7int16_t"></span><span id="_CPPv211nvs_set_i1612nvs_handle_tPKc7int16_t"></span><span id="nvs_set_i16__nvs_handle_t.cCP.int16_t"></span><span class="target" id="nvs_8h_1ae2bb6637981f4d32bc29cdd200330aaf"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_i16</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, int16_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_set_i1612nvs_handle_tPKc7int16_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411nvs_set_u1612nvs_handle_tPKc8uint16_t">
<span id="_CPPv311nvs_set_u1612nvs_handle_tPKc8uint16_t"></span><span id="_CPPv211nvs_set_u1612nvs_handle_tPKc8uint16_t"></span><span id="nvs_set_u16__nvs_handle_t.cCP.uint16_t"></span><span class="target" id="nvs_8h_1ae429cc09c14acb611a9f385480999de6"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_u16</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, uint16_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_set_u1612nvs_handle_tPKc8uint16_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411nvs_set_i3212nvs_handle_tPKc7int32_t">
<span id="_CPPv311nvs_set_i3212nvs_handle_tPKc7int32_t"></span><span id="_CPPv211nvs_set_i3212nvs_handle_tPKc7int32_t"></span><span id="nvs_set_i32__nvs_handle_t.cCP.int32_t"></span><span class="target" id="nvs_8h_1a3dae5d19be95ef744036ccd6684a0eea"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_i32</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, int32_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_set_i3212nvs_handle_tPKc7int32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411nvs_set_u3212nvs_handle_tPKc8uint32_t">
<span id="_CPPv311nvs_set_u3212nvs_handle_tPKc8uint32_t"></span><span id="_CPPv211nvs_set_u3212nvs_handle_tPKc8uint32_t"></span><span id="nvs_set_u32__nvs_handle_t.cCP.uint32_t"></span><span class="target" id="nvs_8h_1a7e447c2369a1c2823ae01f653bef0bab"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_u32</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, uint32_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_set_u3212nvs_handle_tPKc8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411nvs_set_i6412nvs_handle_tPKc7int64_t">
<span id="_CPPv311nvs_set_i6412nvs_handle_tPKc7int64_t"></span><span id="_CPPv211nvs_set_i6412nvs_handle_tPKc7int64_t"></span><span id="nvs_set_i64__nvs_handle_t.cCP.int64_t"></span><span class="target" id="nvs_8h_1a4f12f2d4d68a095278020b8c116a0f2d"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_i64</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, int64_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_set_i6412nvs_handle_tPKc7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411nvs_set_u6412nvs_handle_tPKc8uint64_t">
<span id="_CPPv311nvs_set_u6412nvs_handle_tPKc8uint64_t"></span><span id="_CPPv211nvs_set_u6412nvs_handle_tPKc8uint64_t"></span><span id="nvs_set_u64__nvs_handle_t.cCP.uint64_t"></span><span class="target" id="nvs_8h_1ab45a7dd95b3b2ada70cd1bba809f20a4"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_u64</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, uint64_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_set_u6412nvs_handle_tPKc8uint64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411nvs_set_str12nvs_handle_tPKcPKc">
<span id="_CPPv311nvs_set_str12nvs_handle_tPKcPKc"></span><span id="_CPPv211nvs_set_str12nvs_handle_tPKcPKc"></span><span id="nvs_set_str__nvs_handle_t.cCP.cCP"></span><span class="target" id="nvs_8h_1a66c6390e31cce9c4d59dc874d242ddac"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_str</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, <em class="property">const</em> char *<em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_set_str12nvs_handle_tPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv410nvs_get_i812nvs_handle_tPKcP6int8_t">
<span id="_CPPv310nvs_get_i812nvs_handle_tPKcP6int8_t"></span><span id="_CPPv210nvs_get_i812nvs_handle_tPKcP6int8_t"></span><span id="nvs_get_i8__nvs_handle_t.cCP.int8_tP"></span><span class="target" id="nvs_8h_1a6ecc74483c38916ea9f66fc07d086333"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_i8</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, int8_t *<em>out_value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410nvs_get_i812nvs_handle_tPKcP6int8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get value for given key </p>
<p>These functions retrieve value for the key, given its name. If key does not exist, or the requested variable type doesn’t match the type which was used when setting a value, an error is returned.</p>
<p>In case of any error, out_value is not modified.</p>
<p>All functions expect out_value to be a pointer to an already allocated variable of the given type.</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Example</span> <span class="n">of</span> <span class="n">using</span> <span class="n">nvs_get_i32</span><span class="p">:</span>
<span class="n">int32_t</span> <span class="n">max_buffer_size</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span> <span class="o">//</span> <span class="n">default</span> <span class="n">value</span>
<span class="n">esp_err_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">nvs_get_i32</span><span class="p">(</span><span class="n">my_handle</span><span class="p">,</span> <span class="s2">&quot;max_buffer_size&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_buffer_size</span><span class="p">);</span>
<span class="k">assert</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">ESP_OK</span> <span class="o">||</span> <span class="n">err</span> <span class="o">==</span> <span class="n">ESP_ERR_NVS_NOT_FOUND</span><span class="p">);</span>
<span class="o">//</span> <span class="k">if</span> <span class="n">ESP_ERR_NVS_NOT_FOUND</span> <span class="n">was</span> <span class="n">returned</span><span class="p">,</span> <span class="n">max_buffer_size</span> <span class="n">will</span> <span class="n">still</span>
<span class="o">//</span> <span class="n">have</span> <span class="n">its</span> <span class="n">default</span> <span class="n">value</span><span class="o">.</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK if the value was retrieved successfully</li>
<li>ESP_ERR_NVS_NOT_FOUND if the requested key doesn’t exist</li>
<li>ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL</li>
<li>ESP_ERR_NVS_INVALID_NAME if key name doesn’t satisfy constraints</li>
<li>ESP_ERR_NVS_INVALID_LENGTH if length is not sufficient to store data </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: Handle obtained from nvs_open function. </li>
<li><code class="docutils literal notranslate"><span class="pre">key</span></code>: Key name. Maximal length is determined by the underlying implementation, but is guaranteed to be at least 15 characters. Shouldn’t be empty. </li>
<li><code class="docutils literal notranslate"><span class="pre">out_value</span></code>: Pointer to the output value. May be NULL for nvs_get_str and nvs_get_blob, in this case required length will be returned in length argument.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410nvs_get_u812nvs_handle_tPKcP7uint8_t">
<span id="_CPPv310nvs_get_u812nvs_handle_tPKcP7uint8_t"></span><span id="_CPPv210nvs_get_u812nvs_handle_tPKcP7uint8_t"></span><span id="nvs_get_u8__nvs_handle_t.cCP.uint8_tP"></span><span class="target" id="nvs_8h_1aee87db8410ac85302127351c817d6bae"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_u8</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, uint8_t *<em>out_value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410nvs_get_u812nvs_handle_tPKcP7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411nvs_get_i1612nvs_handle_tPKcP7int16_t">
<span id="_CPPv311nvs_get_i1612nvs_handle_tPKcP7int16_t"></span><span id="_CPPv211nvs_get_i1612nvs_handle_tPKcP7int16_t"></span><span id="nvs_get_i16__nvs_handle_t.cCP.int16_tP"></span><span class="target" id="nvs_8h_1a6394a84e240d897d184ad5fc539e2aed"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_i16</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, int16_t *<em>out_value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_get_i1612nvs_handle_tPKcP7int16_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411nvs_get_u1612nvs_handle_tPKcP8uint16_t">
<span id="_CPPv311nvs_get_u1612nvs_handle_tPKcP8uint16_t"></span><span id="_CPPv211nvs_get_u1612nvs_handle_tPKcP8uint16_t"></span><span id="nvs_get_u16__nvs_handle_t.cCP.uint16_tP"></span><span class="target" id="nvs_8h_1a4b44fa374e23455a31cdc17a7fbc8207"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_u16</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, uint16_t *<em>out_value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_get_u1612nvs_handle_tPKcP8uint16_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411nvs_get_i3212nvs_handle_tPKcP7int32_t">
<span id="_CPPv311nvs_get_i3212nvs_handle_tPKcP7int32_t"></span><span id="_CPPv211nvs_get_i3212nvs_handle_tPKcP7int32_t"></span><span id="nvs_get_i32__nvs_handle_t.cCP.int32_tP"></span><span class="target" id="nvs_8h_1a911777e4654ca5bf1c46b1c20a8e7299"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_i32</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, int32_t *<em>out_value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_get_i3212nvs_handle_tPKcP7int32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411nvs_get_u3212nvs_handle_tPKcP8uint32_t">
<span id="_CPPv311nvs_get_u3212nvs_handle_tPKcP8uint32_t"></span><span id="_CPPv211nvs_get_u3212nvs_handle_tPKcP8uint32_t"></span><span id="nvs_get_u32__nvs_handle_t.cCP.uint32_tP"></span><span class="target" id="nvs_8h_1a85f3f2811ad0495884fb032406e557a6"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_u32</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, uint32_t *<em>out_value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_get_u3212nvs_handle_tPKcP8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411nvs_get_i6412nvs_handle_tPKcP7int64_t">
<span id="_CPPv311nvs_get_i6412nvs_handle_tPKcP7int64_t"></span><span id="_CPPv211nvs_get_i6412nvs_handle_tPKcP7int64_t"></span><span id="nvs_get_i64__nvs_handle_t.cCP.int64_tP"></span><span class="target" id="nvs_8h_1a92650d8ea9025da2c00e0f6ac4d11c85"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_i64</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, int64_t *<em>out_value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_get_i6412nvs_handle_tPKcP7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411nvs_get_u6412nvs_handle_tPKcP8uint64_t">
<span id="_CPPv311nvs_get_u6412nvs_handle_tPKcP8uint64_t"></span><span id="_CPPv211nvs_get_u6412nvs_handle_tPKcP8uint64_t"></span><span id="nvs_get_u64__nvs_handle_t.cCP.uint64_tP"></span><span class="target" id="nvs_8h_1ab9af4ab56ac2f338f3c076d35513bbd5"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_u64</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, uint64_t *<em>out_value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_get_u6412nvs_handle_tPKcP8uint64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv411nvs_get_str12nvs_handle_tPKcPcP6size_t">
<span id="_CPPv311nvs_get_str12nvs_handle_tPKcPcP6size_t"></span><span id="_CPPv211nvs_get_str12nvs_handle_tPKcPcP6size_t"></span><span id="nvs_get_str__nvs_handle_t.cCP.cP.sP"></span><span class="target" id="nvs_8h_1a9e6cf0362aba1ed1601ea2d4af427d3d"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_str</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, char *<em>out_value</em>, size_t *<em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411nvs_get_str12nvs_handle_tPKcPcP6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>get value for given key </p>
<p>These functions retrieve the data of an entry, given its key. If key does not exist, or the requested variable type doesn’t match the type which was used when setting a value, an error is returned.</p>
<p>In case of any error, out_value is not modified.</p>
<p>All functions expect out_value to be a pointer to an already allocated variable of the given type.</p>
<p>nvs_get_str and nvs_get_blob functions support WinAPI-style length queries. To get the size necessary to store the value, call nvs_get_str or nvs_get_blob with zero out_value and non-zero pointer to length. Variable pointed to by length argument will be set to the required length. For nvs_get_str, this length includes the zero terminator. When calling nvs_get_str and nvs_get_blob with non-zero out_value, length has to be non-zero and has to point to the length available in out_value. It is suggested that nvs_get/set_str is used for zero-terminated C strings, and nvs_get/set_blob used for arbitrary data structures.</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Example</span> <span class="p">(</span><span class="n">without</span> <span class="n">error</span> <span class="n">checking</span><span class="p">)</span> <span class="n">of</span> <span class="n">using</span> <span class="n">nvs_get_str</span> <span class="n">to</span> <span class="n">get</span> <span class="n">a</span> <span class="n">string</span> <span class="n">into</span> <span class="n">dynamic</span> <span class="n">array</span><span class="p">:</span>
<span class="n">size_t</span> <span class="n">required_size</span><span class="p">;</span>
<span class="n">nvs_get_str</span><span class="p">(</span><span class="n">my_handle</span><span class="p">,</span> <span class="s2">&quot;server_name&quot;</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">required_size</span><span class="p">);</span>
<span class="n">char</span><span class="o">*</span> <span class="n">server_name</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">required_size</span><span class="p">);</span>
<span class="n">nvs_get_str</span><span class="p">(</span><span class="n">my_handle</span><span class="p">,</span> <span class="s2">&quot;server_name&quot;</span><span class="p">,</span> <span class="n">server_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">required_size</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Example</span> <span class="p">(</span><span class="n">without</span> <span class="n">error</span> <span class="n">checking</span><span class="p">)</span> <span class="n">of</span> <span class="n">using</span> <span class="n">nvs_get_blob</span> <span class="n">to</span> <span class="n">get</span> <span class="n">a</span> <span class="n">binary</span> <span class="n">data</span>
<span class="n">into</span> <span class="n">a</span> <span class="n">static</span> <span class="n">array</span><span class="p">:</span>
<span class="n">uint8_t</span> <span class="n">mac_addr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="n">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">mac_addr</span><span class="p">);</span>
<span class="n">nvs_get_blob</span><span class="p">(</span><span class="n">my_handle</span><span class="p">,</span> <span class="s2">&quot;dst_mac_addr&quot;</span><span class="p">,</span> <span class="n">mac_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK if the value was retrieved successfully</li>
<li>ESP_ERR_NVS_NOT_FOUND if the requested key doesn’t exist</li>
<li>ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL</li>
<li>ESP_ERR_NVS_INVALID_NAME if key name doesn’t satisfy constraints</li>
<li>ESP_ERR_NVS_INVALID_LENGTH if length is not sufficient to store data </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: Handle obtained from nvs_open function. </li>
<li><code class="docutils literal notranslate"><span class="pre">key</span></code>: Key name. Maximal length is determined by the underlying implementation, but is guaranteed to be at least 15 characters. Shouldn’t be empty. </li>
<li><code class="docutils literal notranslate"><span class="pre">out_value</span></code>: Pointer to the output value. May be NULL for nvs_get_str and nvs_get_blob, in this case required length will be returned in length argument. </li>
<li><code class="docutils literal notranslate"><span class="pre">length</span></code>: A non-zero pointer to the variable holding the length of out_value. In case out_value a zero, will be set to the length required to hold the value. In case out_value is not zero, will be set to the actual length of the value written. For nvs_get_str this includes zero terminator.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412nvs_get_blob12nvs_handle_tPKcPvP6size_t">
<span id="_CPPv312nvs_get_blob12nvs_handle_tPKcPvP6size_t"></span><span id="_CPPv212nvs_get_blob12nvs_handle_tPKcPvP6size_t"></span><span id="nvs_get_blob__nvs_handle_t.cCP.voidP.sP"></span><span class="target" id="nvs_8h_1a407a597cf06407140d91f7898bf541f4"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_blob</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, void *<em>out_value</em>, size_t *<em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412nvs_get_blob12nvs_handle_tPKcPvP6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv48nvs_openPKc15nvs_open_mode_tP12nvs_handle_t">
<span id="_CPPv38nvs_openPKc15nvs_open_mode_tP12nvs_handle_t"></span><span id="_CPPv28nvs_openPKc15nvs_open_mode_tP12nvs_handle_t"></span><span id="nvs_open__cCP.nvs_open_mode_t.nvs_handle_tP"></span><span class="target" id="nvs_8h_1ab6677099a61deabc00d05b2c92f6b0dc"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_open</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em>, <a class="reference internal" href="#_CPPv415nvs_open_mode_t" title="nvs_open_mode_t">nvs_open_mode_t</a> <em>open_mode</em>, <a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> *<em>out_handle</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48nvs_openPKc15nvs_open_mode_tP12nvs_handle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Open non-volatile storage with a given namespace from the default NVS partition. </p>
<p>Multiple internal ESP-IDF and third party application modules can store their key-value pairs in the NVS module. In order to reduce possible conflicts on key names, each module can use its own namespace. The default NVS partition is the one that is labelled “nvs” in the partition table.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK if storage handle was opened successfully</li>
<li>ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized</li>
<li>ESP_ERR_NVS_PART_NOT_FOUND if the partition with label “nvs” is not found</li>
<li>ESP_ERR_NVS_NOT_FOUND id namespace doesn’t exist yet and mode is NVS_READONLY</li>
<li>ESP_ERR_NVS_INVALID_NAME if namespace name doesn’t satisfy constraints</li>
<li>other error codes from the underlying storage driver </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: Namespace name. Maximal length is determined by the underlying implementation, but is guaranteed to be at least 15 characters. Shouldn’t be empty. </li>
<li><code class="docutils literal notranslate"><span class="pre">open_mode</span></code>: NVS_READWRITE or NVS_READONLY. If NVS_READONLY, will open a handle for reading only. All write requests will be rejected for this handle. </li>
<li><code class="docutils literal notranslate"><span class="pre">out_handle</span></code>: If successful (return code is zero), handle will be returned in this argument.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423nvs_open_from_partitionPKcPKc15nvs_open_mode_tP12nvs_handle_t">
<span id="_CPPv323nvs_open_from_partitionPKcPKc15nvs_open_mode_tP12nvs_handle_t"></span><span id="_CPPv223nvs_open_from_partitionPKcPKc15nvs_open_mode_tP12nvs_handle_t"></span><span id="nvs_open_from_partition__cCP.cCP.nvs_open_mode_t.nvs_handle_tP"></span><span class="target" id="nvs_8h_1a2e144fcac4b67d4e587a947f099db16b"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_open_from_partition</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>part_name</em>, <em class="property">const</em> char *<em>name</em>, <a class="reference internal" href="#_CPPv415nvs_open_mode_t" title="nvs_open_mode_t">nvs_open_mode_t</a> <em>open_mode</em>, <a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> *<em>out_handle</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423nvs_open_from_partitionPKcPKc15nvs_open_mode_tP12nvs_handle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Open non-volatile storage with a given namespace from specified partition. </p>
<p>The behaviour is same as nvs_open() API. However this API can operate on a specified NVS partition instead of default NVS partition. Note that the specified partition must be registered with NVS using nvs_flash_init_partition() API.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK if storage handle was opened successfully</li>
<li>ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized</li>
<li>ESP_ERR_NVS_PART_NOT_FOUND if the partition with specified name is not found</li>
<li>ESP_ERR_NVS_NOT_FOUND id namespace doesn’t exist yet and mode is NVS_READONLY</li>
<li>ESP_ERR_NVS_INVALID_NAME if namespace name doesn’t satisfy constraints</li>
<li>other error codes from the underlying storage driver </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">part_name</span></code>: Label (name) of the partition of interest for object read/write/erase </li>
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: Namespace name. Maximal length is determined by the underlying implementation, but is guaranteed to be at least 15 characters. Shouldn’t be empty. </li>
<li><code class="docutils literal notranslate"><span class="pre">open_mode</span></code>: NVS_READWRITE or NVS_READONLY. If NVS_READONLY, will open a handle for reading only. All write requests will be rejected for this handle. </li>
<li><code class="docutils literal notranslate"><span class="pre">out_handle</span></code>: If successful (return code is zero), handle will be returned in this argument.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412nvs_set_blob12nvs_handle_tPKcPKv6size_t">
<span id="_CPPv312nvs_set_blob12nvs_handle_tPKcPKv6size_t"></span><span id="_CPPv212nvs_set_blob12nvs_handle_tPKcPKv6size_t"></span><span id="nvs_set_blob__nvs_handle_t.cCP.voidCP.s"></span><span class="target" id="nvs_8h_1a2a2a8a79c0df9a1682d0a1bc31f351c3"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_blob</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em>, <em class="property">const</em> void *<em>value</em>, size_t <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412nvs_set_blob12nvs_handle_tPKcPKv6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>set variable length binary value for given key </p>
<p>This family of functions set value for the key, given its name. Note that actual storage will not be updated until nvs_commit function is called.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK if value was set successfully</li>
<li>ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL</li>
<li>ESP_ERR_NVS_READ_ONLY if storage handle was opened as read only</li>
<li>ESP_ERR_NVS_INVALID_NAME if key name doesn’t satisfy constraints</li>
<li>ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is not enough space in the underlying storage to save the value</li>
<li>ESP_ERR_NVS_REMOVE_FAILED if the value wasn’t updated because flash write operation has failed. The value was written however, and update will be finished after re-initialization of nvs, provided that flash operation doesn’t fail again.</li>
<li>ESP_ERR_NVS_VALUE_TOO_LONG if the value is too long </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: Handle obtained from nvs_open function. Handles that were opened read only cannot be used. </li>
<li><code class="docutils literal notranslate"><span class="pre">key</span></code>: Key name. Maximal length is 15 characters. Shouldn’t be empty. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value to set. </li>
<li><code class="docutils literal notranslate"><span class="pre">length</span></code>: length of binary value to set, in bytes; Maximum length is 508000 bytes or (97.6% of the partition size - 4000) bytes whichever is lower.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413nvs_erase_key12nvs_handle_tPKc">
<span id="_CPPv313nvs_erase_key12nvs_handle_tPKc"></span><span id="_CPPv213nvs_erase_key12nvs_handle_tPKc"></span><span id="nvs_erase_key__nvs_handle_t.cCP"></span><span class="target" id="nvs_8h_1a0ba2174523872e14ef96b3add427e4dd"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_erase_key</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, <em class="property">const</em> char *<em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413nvs_erase_key12nvs_handle_tPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Erase key-value pair with given key name. </p>
<p>Note that actual storage may not be updated until nvs_commit function is called.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK if erase operation was successful</li>
<li>ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL</li>
<li>ESP_ERR_NVS_READ_ONLY if handle was opened as read only</li>
<li>ESP_ERR_NVS_NOT_FOUND if the requested key doesn’t exist</li>
<li>other error codes from the underlying storage driver </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: Storage handle obtained with nvs_open. Handles that were opened read only cannot be used.</li>
<li><code class="docutils literal notranslate"><span class="pre">key</span></code>: Key name. Maximal length is determined by the underlying implementation, but is guaranteed to be at least 15 characters. Shouldn’t be empty.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413nvs_erase_all12nvs_handle_t">
<span id="_CPPv313nvs_erase_all12nvs_handle_t"></span><span id="_CPPv213nvs_erase_all12nvs_handle_t"></span><span id="nvs_erase_all__nvs_handle_t"></span><span class="target" id="nvs_8h_1a8c72514b8e1a7c464ad0356e4927158b"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_erase_all</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413nvs_erase_all12nvs_handle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Erase all key-value pairs in a namespace. </p>
<p>Note that actual storage may not be updated until nvs_commit function is called.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK if erase operation was successful</li>
<li>ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL</li>
<li>ESP_ERR_NVS_READ_ONLY if handle was opened as read only</li>
<li>other error codes from the underlying storage driver </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: Storage handle obtained with nvs_open. Handles that were opened read only cannot be used.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410nvs_commit12nvs_handle_t">
<span id="_CPPv310nvs_commit12nvs_handle_t"></span><span id="_CPPv210nvs_commit12nvs_handle_t"></span><span id="nvs_commit__nvs_handle_t"></span><span class="target" id="nvs_8h_1a88e2da69bd240354fdc0be908a933ca1"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_commit</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410nvs_commit12nvs_handle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write any pending changes to non-volatile storage. </p>
<p>After setting any values, nvs_commit() must be called to ensure changes are written to non-volatile storage. Individual implementations may write to storage at other times, but this is not guaranteed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK if the changes have been written successfully</li>
<li>ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL</li>
<li>other error codes from the underlying storage driver </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: Storage handle obtained with nvs_open. Handles that were opened read only cannot be used.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49nvs_close12nvs_handle_t">
<span id="_CPPv39nvs_close12nvs_handle_t"></span><span id="_CPPv29nvs_close12nvs_handle_t"></span><span id="nvs_close__nvs_handle_t"></span><span class="target" id="nvs_8h_1a67e6e6b8ba9a43fc08ca9a9609905c8d"></span>void <code class="descname">nvs_close</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49nvs_close12nvs_handle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Close the storage handle and free any allocated resources. </p>
<p>This function should be called for each handle opened with nvs_open once the handle is not in use any more. Closing the handle may not automatically write the changes to nonvolatile storage. This has to be done explicitly using nvs_commit function. Once this function is called on a handle, the handle should no longer be used.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: Storage handle to close </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413nvs_get_statsPKcP11nvs_stats_t">
<span id="_CPPv313nvs_get_statsPKcP11nvs_stats_t"></span><span id="_CPPv213nvs_get_statsPKcP11nvs_stats_t"></span><span id="nvs_get_stats__cCP.nvs_stats_tP"></span><span class="target" id="nvs_8h_1a8fed09d46b77aa6dd0e8840959fe1933"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_stats</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>part_name</em>, <a class="reference internal" href="#_CPPv411nvs_stats_t" title="nvs_stats_t">nvs_stats_t</a> *<em>nvs_stats</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413nvs_get_statsPKcP11nvs_stats_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fill structure <a class="reference internal" href="#structnvs__stats__t"><span class="std std-ref">nvs_stats_t</span></a>. It provides info about used memory the partition. </p>
<p>This function calculates to runtime the number of used entries, free entries, total entries, and amount namespace in partition.</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Example</span> <span class="n">of</span> <span class="n">nvs_get_stats</span><span class="p">()</span> <span class="n">to</span> <span class="n">get</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">used</span> <span class="n">entries</span> <span class="ow">and</span> <span class="n">free</span> <span class="n">entries</span><span class="p">:</span>
<span class="n">nvs_stats_t</span> <span class="n">nvs_stats</span><span class="p">;</span>
<span class="n">nvs_get_stats</span><span class="p">(</span><span class="n">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nvs_stats</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Count: UsedEntries = (</span><span class="si">%d</span><span class="s2">), FreeEntries = (</span><span class="si">%d</span><span class="s2">), AllEntries = (</span><span class="si">%d</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
       <span class="n">nvs_stats</span><span class="o">.</span><span class="n">used_entries</span><span class="p">,</span> <span class="n">nvs_stats</span><span class="o">.</span><span class="n">free_entries</span><span class="p">,</span> <span class="n">nvs_stats</span><span class="o">.</span><span class="n">total_entries</span><span class="p">);</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK if the changes have been written successfully. Return param nvs_stats will be filled.</li>
<li>ESP_ERR_NVS_PART_NOT_FOUND if the partition with label “name” is not found. Return param nvs_stats will be filled 0.</li>
<li>ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized. Return param nvs_stats will be filled 0.</li>
<li>ESP_ERR_INVALID_ARG if nvs_stats equal to NULL.</li>
<li>ESP_ERR_INVALID_STATE if there is page with the status of INVALID. Return param nvs_stats will be filled not with correct values because not all pages will be counted. Counting will be interrupted at the first INVALID page. </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">part_name</span></code>: Partition name NVS in the partition table. If pass a NULL than will use NVS_DEFAULT_PART_NAME (“nvs”).</li>
<li><code class="docutils literal notranslate"><span class="pre">nvs_stats</span></code>: Returns filled structure nvs_states_t. It provides info about used memory the partition.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424nvs_get_used_entry_count12nvs_handle_tP6size_t">
<span id="_CPPv324nvs_get_used_entry_count12nvs_handle_tP6size_t"></span><span id="_CPPv224nvs_get_used_entry_count12nvs_handle_tP6size_t"></span><span id="nvs_get_used_entry_count__nvs_handle_t.sP"></span><span class="target" id="nvs_8h_1ae6b52d96c1dcfc9d4b2ef987503955f0"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_used_entry_count</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>handle</em>, size_t *<em>used_entries</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424nvs_get_used_entry_count12nvs_handle_tP6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calculate all entries in a namespace. </p>
<p>Note that to find out the total number of records occupied by the namespace, add one to the returned value used_entries (if err is equal to ESP_OK). Because the name space entry takes one entry.</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Example</span> <span class="n">of</span> <span class="n">nvs_get_used_entry_count</span><span class="p">()</span> <span class="n">to</span> <span class="n">get</span> <span class="n">amount</span> <span class="n">of</span> <span class="nb">all</span> <span class="n">key</span><span class="o">-</span><span class="n">value</span> <span class="n">pairs</span> <span class="ow">in</span> <span class="n">one</span> <span class="n">namespace</span><span class="p">:</span>
<span class="n">nvs_handle_t</span> <span class="n">handle</span><span class="p">;</span>
<span class="n">nvs_open</span><span class="p">(</span><span class="s2">&quot;namespace1&quot;</span><span class="p">,</span> <span class="n">NVS_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
<span class="o">...</span>
<span class="n">size_t</span> <span class="n">used_entries</span><span class="p">;</span>
<span class="n">size_t</span> <span class="n">total_entries_namespace</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">nvs_get_used_entry_count</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">used_entries</span><span class="p">)</span> <span class="o">==</span> <span class="n">ESP_OK</span><span class="p">){</span>
    <span class="o">//</span> <span class="n">the</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">records</span> <span class="n">occupied</span> <span class="n">by</span> <span class="n">the</span> <span class="n">namespace</span>
    <span class="n">total_entries_namespace</span> <span class="o">=</span> <span class="n">used_entries</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK if the changes have been written successfully. Return param used_entries will be filled valid value.</li>
<li>ESP_ERR_NVS_NOT_INITIALIZED if the storage driver is not initialized. Return param used_entries will be filled 0.</li>
<li>ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL. Return param used_entries will be filled 0.</li>
<li>ESP_ERR_INVALID_ARG if used_entries equal to NULL.</li>
<li>Other error codes from the underlying storage driver. Return param used_entries will be filled 0. </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: Handle obtained from nvs_open function.</li>
<li><code class="docutils literal notranslate"><span class="pre">used_entries</span></code>: Returns amount of used entries from a namespace.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414nvs_entry_findPKcPKc10nvs_type_t">
<span id="_CPPv314nvs_entry_findPKcPKc10nvs_type_t"></span><span id="_CPPv214nvs_entry_findPKcPKc10nvs_type_t"></span><span id="nvs_entry_find__cCP.cCP.nvs_type_t"></span><span class="target" id="nvs_8h_1a0cf723ae4ccbe18d6a5d0e7b7b132990"></span><a class="reference internal" href="#_CPPv414nvs_iterator_t" title="nvs_iterator_t">nvs_iterator_t</a> <code class="descname">nvs_entry_find</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>part_name</em>, <em class="property">const</em> char *<em>namespace_name</em>, <a class="reference internal" href="#_CPPv410nvs_type_t" title="nvs_type_t">nvs_type_t</a> <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414nvs_entry_findPKcPKc10nvs_type_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create an iterator to enumerate NVS entries based on one or more parameters. </p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Example</span> <span class="n">of</span> <span class="n">listing</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">key</span><span class="o">-</span><span class="n">value</span> <span class="n">pairs</span> <span class="n">of</span> <span class="nb">any</span> <span class="nb">type</span> <span class="n">under</span> <span class="n">specified</span> <span class="n">partition</span> <span class="ow">and</span> <span class="n">namespace</span>
<span class="n">nvs_iterator_t</span> <span class="n">it</span> <span class="o">=</span> <span class="n">nvs_entry_find</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="n">NVS_TYPE_ANY</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nvs_entry_info_t</span> <span class="n">info</span><span class="p">;</span>
        <span class="n">nvs_entry_info</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
        <span class="n">it</span> <span class="o">=</span> <span class="n">nvs_entry_next</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;key &#39;</span><span class="si">%s</span><span class="s2">&#39;, type &#39;</span><span class="si">%d</span><span class="s2">&#39; </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">type</span><span class="p">);</span>
<span class="p">};</span>
<span class="o">//</span> <span class="n">Note</span><span class="p">:</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">release</span> <span class="n">iterator</span> <span class="n">obtained</span> <span class="kn">from</span> <span class="nn">nvs_entry_find</span> <span class="n">function</span> <span class="n">when</span>
<span class="o">//</span>       <span class="n">nvs_entry_find</span> <span class="ow">or</span> <span class="n">nvs_entry_next</span> <span class="n">function</span> <span class="k">return</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">indicating</span> <span class="n">no</span> <span class="n">other</span>
<span class="o">//</span>       <span class="n">element</span> <span class="k">for</span> <span class="n">specified</span> <span class="n">criteria</span> <span class="n">was</span> <span class="n">found</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Iterator used to enumerate all the entries found, or NULL if no entry satisfying criteria was found. Iterator obtained through this function has to be released using nvs_release_iterator when not used any more. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">part_name</span></code>: Partition name</li>
<li><code class="docutils literal notranslate"><span class="pre">namespace_name</span></code>: Set this value if looking for entries with a specific namespace. Pass NULL otherwise.</li>
<li><code class="docutils literal notranslate"><span class="pre">type</span></code>: One of nvs_type_t values.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414nvs_entry_next14nvs_iterator_t">
<span id="_CPPv314nvs_entry_next14nvs_iterator_t"></span><span id="_CPPv214nvs_entry_next14nvs_iterator_t"></span><span id="nvs_entry_next__nvs_iterator_t"></span><span class="target" id="nvs_8h_1a2862fd9de99c7e5b6947d2e5706a194b"></span><a class="reference internal" href="#_CPPv414nvs_iterator_t" title="nvs_iterator_t">nvs_iterator_t</a> <code class="descname">nvs_entry_next</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414nvs_iterator_t" title="nvs_iterator_t">nvs_iterator_t</a> <em>iterator</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414nvs_entry_next14nvs_iterator_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns next item matching the iterator criteria, NULL if no such item exists. </p>
<p>Note that any copies of the iterator will be invalid after this call.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>NULL if no entry was found, valid nvs_iterator_t otherwise. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">iterator</span></code>: Iterator obtained from nvs_entry_find function. Must be non-NULL.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414nvs_entry_info14nvs_iterator_tP16nvs_entry_info_t">
<span id="_CPPv314nvs_entry_info14nvs_iterator_tP16nvs_entry_info_t"></span><span id="_CPPv214nvs_entry_info14nvs_iterator_tP16nvs_entry_info_t"></span><span id="nvs_entry_info__nvs_iterator_t.nvs_entry_info_tP"></span><span class="target" id="nvs_8h_1ae2c17aa8c05f476c47bf3c4b9ebba6b0"></span>void <code class="descname">nvs_entry_info</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414nvs_iterator_t" title="nvs_iterator_t">nvs_iterator_t</a> <em>iterator</em>, <a class="reference internal" href="#_CPPv416nvs_entry_info_t" title="nvs_entry_info_t">nvs_entry_info_t</a> *<em>out_info</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414nvs_entry_info14nvs_iterator_tP16nvs_entry_info_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fills <a class="reference internal" href="#structnvs__entry__info__t"><span class="std std-ref">nvs_entry_info_t</span></a> structure with information about entry pointed to by the iterator. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">iterator</span></code>: Iterator obtained from nvs_entry_find or nvs_entry_next function. Must be non-NULL.</li>
<li><code class="docutils literal notranslate"><span class="pre">out_info</span></code>: Structure to which entry information is copied. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420nvs_release_iterator14nvs_iterator_t">
<span id="_CPPv320nvs_release_iterator14nvs_iterator_t"></span><span id="_CPPv220nvs_release_iterator14nvs_iterator_t"></span><span id="nvs_release_iterator__nvs_iterator_t"></span><span class="target" id="nvs_8h_1a33eceb70a1cc57c2fe2bae30a76f819a"></span>void <code class="descname">nvs_release_iterator</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv414nvs_iterator_t" title="nvs_iterator_t">nvs_iterator_t</a> <em>iterator</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420nvs_release_iterator14nvs_iterator_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Release iterator. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">iterator</span></code>: Release iterator obtained from nvs_entry_find function. NULL argument is allowed. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="id7">
<h3>Structures<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv416nvs_entry_info_t">
<span id="_CPPv316nvs_entry_info_t"></span><span id="_CPPv216nvs_entry_info_t"></span><span id="nvs_entry_info_t"></span><span class="target" id="structnvs__entry__info__t"></span><em class="property">struct </em><code class="descname">nvs_entry_info_t</code><a class="headerlink" href="#_CPPv416nvs_entry_info_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>information about entry obtained from nvs_entry_info function </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N16nvs_entry_info_t14namespace_nameE">
<span id="_CPPv3N16nvs_entry_info_t14namespace_nameE"></span><span id="_CPPv2N16nvs_entry_info_t14namespace_nameE"></span><span id="nvs_entry_info_t::namespace_name__cA"></span><span class="target" id="structnvs__entry__info__t_1a03a06d6db4f237eee102381a0b8a3003"></span>char <code class="descname">namespace_name</code>[16]<a class="headerlink" href="#_CPPv4N16nvs_entry_info_t14namespace_nameE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Namespace to which key-value belong </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N16nvs_entry_info_t3keyE">
<span id="_CPPv3N16nvs_entry_info_t3keyE"></span><span id="_CPPv2N16nvs_entry_info_t3keyE"></span><span id="nvs_entry_info_t::key__cA"></span><span class="target" id="structnvs__entry__info__t_1a6b4bfc6c2fd04f1507a3a1428e8019e3"></span>char <code class="descname">key</code>[16]<a class="headerlink" href="#_CPPv4N16nvs_entry_info_t3keyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Key of stored key-value pair </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N16nvs_entry_info_t4typeE">
<span id="_CPPv3N16nvs_entry_info_t4typeE"></span><span id="_CPPv2N16nvs_entry_info_t4typeE"></span><span id="nvs_entry_info_t::type__nvs_type_t"></span><span class="target" id="structnvs__entry__info__t_1ad9cd8f3eb0f354e9f1074586bc7580dd"></span><a class="reference internal" href="#_CPPv410nvs_type_t" title="nvs_type_t">nvs_type_t</a> <code class="descname">type</code><a class="headerlink" href="#_CPPv4N16nvs_entry_info_t4typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type of stored key-value pair </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv411nvs_stats_t">
<span id="_CPPv311nvs_stats_t"></span><span id="_CPPv211nvs_stats_t"></span><span id="nvs_stats_t"></span><span class="target" id="structnvs__stats__t"></span><em class="property">struct </em><code class="descname">nvs_stats_t</code><a class="headerlink" href="#_CPPv411nvs_stats_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Info about storage space NVS. </dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N11nvs_stats_t12used_entriesE">
<span id="_CPPv3N11nvs_stats_t12used_entriesE"></span><span id="_CPPv2N11nvs_stats_t12used_entriesE"></span><span id="nvs_stats_t::used_entries__s"></span><span class="target" id="structnvs__stats__t_1a984ca538c8d5ed3657e79a61ae32290d"></span>size_t <code class="descname">used_entries</code><a class="headerlink" href="#_CPPv4N11nvs_stats_t12used_entriesE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Amount of used entries. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N11nvs_stats_t12free_entriesE">
<span id="_CPPv3N11nvs_stats_t12free_entriesE"></span><span id="_CPPv2N11nvs_stats_t12free_entriesE"></span><span id="nvs_stats_t::free_entries__s"></span><span class="target" id="structnvs__stats__t_1aabe96c61ba4d7e45986ade7662dd2976"></span>size_t <code class="descname">free_entries</code><a class="headerlink" href="#_CPPv4N11nvs_stats_t12free_entriesE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Amount of free entries. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N11nvs_stats_t13total_entriesE">
<span id="_CPPv3N11nvs_stats_t13total_entriesE"></span><span id="_CPPv2N11nvs_stats_t13total_entriesE"></span><span id="nvs_stats_t::total_entries__s"></span><span class="target" id="structnvs__stats__t_1aefc55846fa9a1c4b66002dc2064cb6f8"></span>size_t <code class="descname">total_entries</code><a class="headerlink" href="#_CPPv4N11nvs_stats_t13total_entriesE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Amount all available entries. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N11nvs_stats_t15namespace_countE">
<span id="_CPPv3N11nvs_stats_t15namespace_countE"></span><span id="_CPPv2N11nvs_stats_t15namespace_countE"></span><span id="nvs_stats_t::namespace_count__s"></span><span class="target" id="structnvs__stats__t_1ada57627fb643fd0ca4bda5110f47faa6"></span>size_t <code class="descname">namespace_count</code><a class="headerlink" href="#_CPPv4N11nvs_stats_t15namespace_countE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Amount name space. </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id8">
<h3>Macros<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_BASE">
<span class="target" id="nvs_8h_1a6ebf3d06cf50a876d6702b293e909d8b"></span><code class="descname">ESP_ERR_NVS_BASE</code><a class="headerlink" href="#c.ESP_ERR_NVS_BASE" title="Permalink to this definition">¶</a></dt>
<dd><p>Starting number of error codes </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_NOT_INITIALIZED">
<span class="target" id="nvs_8h_1ad943a82bd363a027c66c0a96be0d18c1"></span><code class="descname">ESP_ERR_NVS_NOT_INITIALIZED</code><a class="headerlink" href="#c.ESP_ERR_NVS_NOT_INITIALIZED" title="Permalink to this definition">¶</a></dt>
<dd><p>The storage driver is not initialized </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_NOT_FOUND">
<span class="target" id="nvs_8h_1a082e1ba076150e1c74f78bedf51f33d3"></span><code class="descname">ESP_ERR_NVS_NOT_FOUND</code><a class="headerlink" href="#c.ESP_ERR_NVS_NOT_FOUND" title="Permalink to this definition">¶</a></dt>
<dd><p>Id namespace doesn’t exist yet and mode is NVS_READONLY </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_TYPE_MISMATCH">
<span class="target" id="nvs_8h_1a879189233ef6af91693744b61315b8b0"></span><code class="descname">ESP_ERR_NVS_TYPE_MISMATCH</code><a class="headerlink" href="#c.ESP_ERR_NVS_TYPE_MISMATCH" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of set or get operation doesn’t match the type of value stored in NVS </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_READ_ONLY">
<span class="target" id="nvs_8h_1a0375ec3f706dae978eec4e5ea4b63595"></span><code class="descname">ESP_ERR_NVS_READ_ONLY</code><a class="headerlink" href="#c.ESP_ERR_NVS_READ_ONLY" title="Permalink to this definition">¶</a></dt>
<dd><p>Storage handle was opened as read only </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_NOT_ENOUGH_SPACE">
<span class="target" id="nvs_8h_1a749dd12cecf7a713767e02d82a691438"></span><code class="descname">ESP_ERR_NVS_NOT_ENOUGH_SPACE</code><a class="headerlink" href="#c.ESP_ERR_NVS_NOT_ENOUGH_SPACE" title="Permalink to this definition">¶</a></dt>
<dd><p>There is not enough space in the underlying storage to save the value </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_INVALID_NAME">
<span class="target" id="nvs_8h_1a1bd03eb2ed14371d21bad10191296603"></span><code class="descname">ESP_ERR_NVS_INVALID_NAME</code><a class="headerlink" href="#c.ESP_ERR_NVS_INVALID_NAME" title="Permalink to this definition">¶</a></dt>
<dd><p>Namespace name doesn’t satisfy constraints </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_INVALID_HANDLE">
<span class="target" id="nvs_8h_1a5f8311ac86b9c5148a5a462ed807bb9c"></span><code class="descname">ESP_ERR_NVS_INVALID_HANDLE</code><a class="headerlink" href="#c.ESP_ERR_NVS_INVALID_HANDLE" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle has been closed or is NULL </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_REMOVE_FAILED">
<span class="target" id="nvs_8h_1a6e2dd398a871449dacf60f7291f23033"></span><code class="descname">ESP_ERR_NVS_REMOVE_FAILED</code><a class="headerlink" href="#c.ESP_ERR_NVS_REMOVE_FAILED" title="Permalink to this definition">¶</a></dt>
<dd><p>The value wasn’t updated because flash write operation has failed. The value was written however, and update will be finished after re-initialization of nvs, provided that flash operation doesn’t fail again. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_KEY_TOO_LONG">
<span class="target" id="nvs_8h_1a43e34b6c49c7aa954db4f04fc41e3296"></span><code class="descname">ESP_ERR_NVS_KEY_TOO_LONG</code><a class="headerlink" href="#c.ESP_ERR_NVS_KEY_TOO_LONG" title="Permalink to this definition">¶</a></dt>
<dd><p>Key name is too long </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_PAGE_FULL">
<span class="target" id="nvs_8h_1a48b4105cbb5e8ddde83619b4ab88daa5"></span><code class="descname">ESP_ERR_NVS_PAGE_FULL</code><a class="headerlink" href="#c.ESP_ERR_NVS_PAGE_FULL" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal error; never returned by nvs API functions </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_INVALID_STATE">
<span class="target" id="nvs_8h_1a0a66474f77e59dd4e9d0f92402c71a08"></span><code class="descname">ESP_ERR_NVS_INVALID_STATE</code><a class="headerlink" href="#c.ESP_ERR_NVS_INVALID_STATE" title="Permalink to this definition">¶</a></dt>
<dd><p>NVS is in an inconsistent state due to a previous error. Call nvs_flash_init and nvs_open again, then retry. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_INVALID_LENGTH">
<span class="target" id="nvs_8h_1a8fe5478e998fcb6ba2504fad13563695"></span><code class="descname">ESP_ERR_NVS_INVALID_LENGTH</code><a class="headerlink" href="#c.ESP_ERR_NVS_INVALID_LENGTH" title="Permalink to this definition">¶</a></dt>
<dd><p>String or blob length is not sufficient to store data </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_NO_FREE_PAGES">
<span class="target" id="nvs_8h_1a0db9bc5030273dc8443de06de2bdf166"></span><code class="descname">ESP_ERR_NVS_NO_FREE_PAGES</code><a class="headerlink" href="#c.ESP_ERR_NVS_NO_FREE_PAGES" title="Permalink to this definition">¶</a></dt>
<dd><p>NVS partition doesn’t contain any empty pages. This may happen if NVS partition was truncated. Erase the whole partition and call nvs_flash_init again. </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_VALUE_TOO_LONG">
<span class="target" id="nvs_8h_1a069270375766125d42cd881d17e0caac"></span><code class="descname">ESP_ERR_NVS_VALUE_TOO_LONG</code><a class="headerlink" href="#c.ESP_ERR_NVS_VALUE_TOO_LONG" title="Permalink to this definition">¶</a></dt>
<dd><p>String or blob length is longer than supported by the implementation </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_PART_NOT_FOUND">
<span class="target" id="nvs_8h_1ab5c583c77736f31153212fc24e9ad428"></span><code class="descname">ESP_ERR_NVS_PART_NOT_FOUND</code><a class="headerlink" href="#c.ESP_ERR_NVS_PART_NOT_FOUND" title="Permalink to this definition">¶</a></dt>
<dd><p>Partition with specified name is not found in the partition table </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_NEW_VERSION_FOUND">
<span class="target" id="nvs_8h_1a719036fc53adfba75a722bc3b2c8088d"></span><code class="descname">ESP_ERR_NVS_NEW_VERSION_FOUND</code><a class="headerlink" href="#c.ESP_ERR_NVS_NEW_VERSION_FOUND" title="Permalink to this definition">¶</a></dt>
<dd><p>NVS partition contains data in new format and cannot be recognized by this version of code </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_XTS_ENCR_FAILED">
<span class="target" id="nvs_8h_1a8d6a9ee18ef709bfb31b5b0876fdb4e2"></span><code class="descname">ESP_ERR_NVS_XTS_ENCR_FAILED</code><a class="headerlink" href="#c.ESP_ERR_NVS_XTS_ENCR_FAILED" title="Permalink to this definition">¶</a></dt>
<dd><p>XTS encryption failed while writing NVS entry </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_XTS_DECR_FAILED">
<span class="target" id="nvs_8h_1a3b7991e1ece6f0a068188ff0e6446646"></span><code class="descname">ESP_ERR_NVS_XTS_DECR_FAILED</code><a class="headerlink" href="#c.ESP_ERR_NVS_XTS_DECR_FAILED" title="Permalink to this definition">¶</a></dt>
<dd><p>XTS decryption failed while reading NVS entry </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_XTS_CFG_FAILED">
<span class="target" id="nvs_8h_1a4304c1cc1a58723ba7e8cd52a3240fad"></span><code class="descname">ESP_ERR_NVS_XTS_CFG_FAILED</code><a class="headerlink" href="#c.ESP_ERR_NVS_XTS_CFG_FAILED" title="Permalink to this definition">¶</a></dt>
<dd><p>XTS configuration setting failed </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_XTS_CFG_NOT_FOUND">
<span class="target" id="nvs_8h_1a5ed7fdfd6c8d769f7148d7553b97f004"></span><code class="descname">ESP_ERR_NVS_XTS_CFG_NOT_FOUND</code><a class="headerlink" href="#c.ESP_ERR_NVS_XTS_CFG_NOT_FOUND" title="Permalink to this definition">¶</a></dt>
<dd><p>XTS configuration not found </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_ENCR_NOT_SUPPORTED">
<span class="target" id="nvs_8h_1a680919934f73044eef6d5a7d235d6bc5"></span><code class="descname">ESP_ERR_NVS_ENCR_NOT_SUPPORTED</code><a class="headerlink" href="#c.ESP_ERR_NVS_ENCR_NOT_SUPPORTED" title="Permalink to this definition">¶</a></dt>
<dd><p>NVS encryption is not supported in this version </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_KEYS_NOT_INITIALIZED">
<span class="target" id="nvs_8h_1a222febdb2697ebcd48f673582de503f7"></span><code class="descname">ESP_ERR_NVS_KEYS_NOT_INITIALIZED</code><a class="headerlink" href="#c.ESP_ERR_NVS_KEYS_NOT_INITIALIZED" title="Permalink to this definition">¶</a></dt>
<dd><p>NVS key partition is uninitialized </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_CORRUPT_KEY_PART">
<span class="target" id="nvs_8h_1ae0a1f13593d08f82d3e36f34838cb003"></span><code class="descname">ESP_ERR_NVS_CORRUPT_KEY_PART</code><a class="headerlink" href="#c.ESP_ERR_NVS_CORRUPT_KEY_PART" title="Permalink to this definition">¶</a></dt>
<dd><p>NVS key partition is corrupt </p>
</dd></dl>

<dl class="macro">
<dt id="c.ESP_ERR_NVS_CONTENT_DIFFERS">
<span class="target" id="nvs_8h_1ada3575eb4ea5831fbb35ac564f0d49e6"></span><code class="descname">ESP_ERR_NVS_CONTENT_DIFFERS</code><a class="headerlink" href="#c.ESP_ERR_NVS_CONTENT_DIFFERS" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal error; never returned by nvs API functions. NVS key is different in comparison </p>
</dd></dl>

<dl class="macro">
<dt id="c.NVS_DEFAULT_PART_NAME">
<span class="target" id="nvs_8h_1a4e567a079a04ef71a18d21de58bd9b5a"></span><code class="descname">NVS_DEFAULT_PART_NAME</code><a class="headerlink" href="#c.NVS_DEFAULT_PART_NAME" title="Permalink to this definition">¶</a></dt>
<dd><p>Default partition name of the NVS partition in the partition table </p>
</dd></dl>

<dl class="macro">
<dt id="c.NVS_PART_NAME_MAX_SIZE">
<span class="target" id="nvs_8h_1a1db8c93ce4ae61d2900cd70ebb021e1d"></span><code class="descname">NVS_PART_NAME_MAX_SIZE</code><a class="headerlink" href="#c.NVS_PART_NAME_MAX_SIZE" title="Permalink to this definition">¶</a></dt>
<dd><p>maximum length of partition name (excluding null terminator) </p>
</dd></dl>

</div>
<div class="section" id="type-definitions">
<h3>Type Definitions<a class="headerlink" href="#type-definitions" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv412nvs_handle_t">
<span id="_CPPv312nvs_handle_t"></span><span id="_CPPv212nvs_handle_t"></span><span id="nvs_handle_t"></span><span class="target" id="nvs_8h_1a1d7beddf57b3313de191f91ba639f9aa"></span><em class="property">typedef </em>uint32_t <code class="descname">nvs_handle_t</code><a class="headerlink" href="#_CPPv412nvs_handle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Opaque pointer type representing non-volatile storage handle </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv410nvs_handle">
<span id="_CPPv310nvs_handle"></span><span id="_CPPv210nvs_handle"></span><span id="nvs_handle"></span><span class="target" id="nvs_8h_1a2f2c716f08f30da049ffd5f8e10c40ea"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <code class="descname">nvs_handle</code><a class="headerlink" href="#_CPPv410nvs_handle" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv413nvs_open_mode">
<span id="_CPPv313nvs_open_mode"></span><span id="_CPPv213nvs_open_mode"></span><span id="nvs_open_mode"></span><span class="target" id="nvs_8h_1a58b11f9db94a9699f095102b1361e53f"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv415nvs_open_mode_t" title="nvs_open_mode_t">nvs_open_mode_t</a> <code class="descname">nvs_open_mode</code><a class="headerlink" href="#_CPPv413nvs_open_mode" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv414nvs_iterator_t">
<span id="_CPPv314nvs_iterator_t"></span><span id="_CPPv214nvs_iterator_t"></span><span id="nvs_iterator_t"></span><span class="target" id="nvs_8h_1addeca2dd4bededba2c1c5aac2dfd5cbf"></span><em class="property">typedef </em><em class="property">struct</em> nvs_opaque_iterator_t *<code class="descname">nvs_iterator_t</code><a class="headerlink" href="#_CPPv414nvs_iterator_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Opaque pointer type representing iterator to nvs entries </p>
</dd></dl>

</div>
<div class="section" id="enumerations">
<h3>Enumerations<a class="headerlink" href="#enumerations" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv415nvs_open_mode_t">
<span id="_CPPv315nvs_open_mode_t"></span><span id="_CPPv215nvs_open_mode_t"></span><span id="nvs_open_mode_t"></span><span class="target" id="nvs_8h_1a017e1932838b044b88f875edf56e3793"></span><em class="property">enum </em><code class="descname">nvs_open_mode_t</code><a class="headerlink" href="#_CPPv415nvs_open_mode_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Mode of opening the non-volatile storage. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv412NVS_READONLY">
<span id="_CPPv312NVS_READONLY"></span><span id="_CPPv212NVS_READONLY"></span><span class="target" id="nvs_8h_1a017e1932838b044b88f875edf56e3793adcb7dd95b10700e8855315dd2a88c02d"></span><code class="descname">NVS_READONLY</code><a class="headerlink" href="#_CPPv412NVS_READONLY" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read only </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv413NVS_READWRITE">
<span id="_CPPv313NVS_READWRITE"></span><span id="_CPPv213NVS_READWRITE"></span><span class="target" id="nvs_8h_1a017e1932838b044b88f875edf56e3793afd73ea5fe0b78c36af2a47b3bb788d7b"></span><code class="descname">NVS_READWRITE</code><a class="headerlink" href="#_CPPv413NVS_READWRITE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read and write </p>
</dd></dl>

</dd></dl>

<dl class="type">
<dt id="_CPPv410nvs_type_t">
<span id="_CPPv310nvs_type_t"></span><span id="_CPPv210nvs_type_t"></span><span id="nvs_type_t"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19"></span><em class="property">enum </em><code class="descname">nvs_type_t</code><a class="headerlink" href="#_CPPv410nvs_type_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Types of variables. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv411NVS_TYPE_U8">
<span id="_CPPv311NVS_TYPE_U8"></span><span id="_CPPv211NVS_TYPE_U8"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19a0bf45d256ba3969cfa47d938da79a610"></span><code class="descname">NVS_TYPE_U8</code> = 0x01<a class="headerlink" href="#_CPPv411NVS_TYPE_U8" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type uint8_t </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv411NVS_TYPE_I8">
<span id="_CPPv311NVS_TYPE_I8"></span><span id="_CPPv211NVS_TYPE_I8"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19a5b774222e037fe8762a52c10165b0cf7"></span><code class="descname">NVS_TYPE_I8</code> = 0x11<a class="headerlink" href="#_CPPv411NVS_TYPE_I8" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type int8_t </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412NVS_TYPE_U16">
<span id="_CPPv312NVS_TYPE_U16"></span><span id="_CPPv212NVS_TYPE_U16"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19af57a753522c97be5ca3dbfd4d90ee0a2"></span><code class="descname">NVS_TYPE_U16</code> = 0x02<a class="headerlink" href="#_CPPv412NVS_TYPE_U16" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type uint16_t </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412NVS_TYPE_I16">
<span id="_CPPv312NVS_TYPE_I16"></span><span id="_CPPv212NVS_TYPE_I16"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19acbb42175aac1f46510597c52f7eadf67"></span><code class="descname">NVS_TYPE_I16</code> = 0x12<a class="headerlink" href="#_CPPv412NVS_TYPE_I16" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type int16_t </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412NVS_TYPE_U32">
<span id="_CPPv312NVS_TYPE_U32"></span><span id="_CPPv212NVS_TYPE_U32"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19ae3f5df4fc9c206ab0a4311c40bcb07fd"></span><code class="descname">NVS_TYPE_U32</code> = 0x04<a class="headerlink" href="#_CPPv412NVS_TYPE_U32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type uint32_t </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412NVS_TYPE_I32">
<span id="_CPPv312NVS_TYPE_I32"></span><span id="_CPPv212NVS_TYPE_I32"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19a03285d076b980e0a1d125ea9150ed552"></span><code class="descname">NVS_TYPE_I32</code> = 0x14<a class="headerlink" href="#_CPPv412NVS_TYPE_I32" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type int32_t </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412NVS_TYPE_U64">
<span id="_CPPv312NVS_TYPE_U64"></span><span id="_CPPv212NVS_TYPE_U64"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19a0b95e503d55dbf29342ac491d7e66956"></span><code class="descname">NVS_TYPE_U64</code> = 0x08<a class="headerlink" href="#_CPPv412NVS_TYPE_U64" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type uint64_t </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412NVS_TYPE_I64">
<span id="_CPPv312NVS_TYPE_I64"></span><span id="_CPPv212NVS_TYPE_I64"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19ad2a38ac131962fdb89d8407795ee44aa"></span><code class="descname">NVS_TYPE_I64</code> = 0x18<a class="headerlink" href="#_CPPv412NVS_TYPE_I64" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type int64_t </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412NVS_TYPE_STR">
<span id="_CPPv312NVS_TYPE_STR"></span><span id="_CPPv212NVS_TYPE_STR"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19a2d4edb61489d985af5b358634e81dacc"></span><code class="descname">NVS_TYPE_STR</code> = 0x21<a class="headerlink" href="#_CPPv412NVS_TYPE_STR" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type string </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv413NVS_TYPE_BLOB">
<span id="_CPPv313NVS_TYPE_BLOB"></span><span id="_CPPv213NVS_TYPE_BLOB"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19ada2916eec53ebf6fd7b00de6b9037c16"></span><code class="descname">NVS_TYPE_BLOB</code> = 0x42<a class="headerlink" href="#_CPPv413NVS_TYPE_BLOB" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type blob </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv412NVS_TYPE_ANY">
<span id="_CPPv312NVS_TYPE_ANY"></span><span id="_CPPv212NVS_TYPE_ANY"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19a3cec9452563a30fb500a17e77c3dc257"></span><code class="descname">NVS_TYPE_ANY</code> = 0xff<a class="headerlink" href="#_CPPv412NVS_TYPE_ANY" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Must be last </p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="nvs_partition_gen.html" class="btn btn-neutral float-right" title="NVS Partition Generator Utility" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="mass_mfg.html" class="btn btn-neutral float-left" title="Manufacturing Utility" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016 - 2019, Espressif Systems (Shanghai) CO., LTD
      
        <span class="commit">
          Revision <code>f9108063</code>.
        </span>
      

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org/">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: latest
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="https://docs.espressif.com/en/latest/">latest</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/stable/">stable</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v4.0-rc/">v4.0-rc</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v4.0-beta2/">v4.0-beta2</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.3.1/">v3.3.1</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.3/">v3.3</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.2.3/">v3.2.3</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.2.2/">v3.2.2</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.1.6/">v3.1.6</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.1.5/">v3.1.5</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.0.9/">v3.0.9</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/release-v4.1/">release-v4.1</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/release-v4.0/">release-v4.0</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/release-v3.3/">release-v3.3</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/release-v3.2/">release-v3.2</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/release-v3.1/">release-v3.1</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/release-v3.0/">release-v3.0</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="http://docs.espressif.com/_/downloads/esp-idf/en/latest/pdf/">pdf</a></dd>
        
      </dl>
      <dl>
        <dt>On Read the Docs</dt>
          <dd>
            <a href="http://readthedocs.com/projects/espressif-esp-idf/?fromdocs=espressif-esp-idf">Project Home</a>
          </dd>
          <dd>
            <a href="http://readthedocs.com/builds/espressif-esp-idf/?fromdocs=espressif-esp-idf">Builds</a>
          </dd>
      </dl>
      <hr/>
      Free document hosting provided by <a href="http://www.readthedocs.org/">Read the Docs</a>.

    </div>
  </div>



  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
   

</body>

<!-- Mirrored from docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/nvs_flash.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 29 Feb 2020 06:26:21 GMT -->
</html>