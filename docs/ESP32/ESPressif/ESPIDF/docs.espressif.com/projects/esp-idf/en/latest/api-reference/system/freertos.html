

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->

<!-- Mirrored from docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/freertos.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 29 Feb 2020 06:26:11 GMT -->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>FreeRTOS &mdash; ESP-IDF Programming Guide v4.1-dev-2071-gf91080637 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../../../../../media.readthedocs.com/javascript/readthedocs-doc-embed.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="FreeRTOS Additions" href="freertos_additions.html" />
    <link rel="prev" title="Legacy event loop" href="esp_event_legacy.html" /> 

<!-- RTD Extra Head -->

<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link rel="canonical" href="freertos.html" />

<link rel="stylesheet" href="../../../../../../../media.readthedocs.com/css/readthedocs-doc-embed.css" type="text/css" />

<script type="text/javascript" src="../../_static/readthedocs-data.js"></script>

<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = "api-reference/system/freertos"
READTHEDOCS_DATA['source_suffix'] = ".rst"
</script>

<script type="text/javascript" src="../../../../../../../media.readthedocs.com/javascript/readthedocs-analytics.js"></script>

<!-- end RTD <extrahead> -->
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index-2.html" class="icon icon-home"> ESP-IDF Programming Guide
          

          
            
            <img src="../../_static/espressif-logo.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="https://docs.espressif.com/projects/esp-idf/en/latest/search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">Get Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../peripherals/index.html">Peripherals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">Provisioning</a></li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">Storage</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">System</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="app_image_format.html">App image format</a></li>
<li class="toctree-l3"><a class="reference internal" href="app_trace.html">Application Level Tracing</a></li>
<li class="toctree-l3"><a class="reference internal" href="efuse.html">eFuse Manager</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_err.html">Error Codes and Helper Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_https_ota.html">ESP HTTPS OTA</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_pthread.html">ESP pthread</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_event.html">Event Loop Library</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">FreeRTOS</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-api">Task API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#queue-api">Queue API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#semaphore-api">Semaphore API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#timer-api">Timer API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#event-group-api">Event Group API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="freertos_additions.html">FreeRTOS Additions</a></li>
<li class="toctree-l3"><a class="reference internal" href="mem_alloc.html">Heap Memory Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="heap_debug.html">Heap Memory Debugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_timer.html">High Resolution Timer</a></li>
<li class="toctree-l3"><a class="reference internal" href="himem.html">Himem (large external SPI RAM) API</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipc.html">Inter-Processor Call</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_expression_with_stack.html">Call function with external stack</a></li>
<li class="toctree-l3"><a class="reference internal" href="intr_alloc.html">Interrupt Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="log.html">Logging</a></li>
<li class="toctree-l3"><a class="reference internal" href="system.html">Miscellaneous System APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="ota.html">Over The Air Updates (OTA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="perfmon.html">Performance Monitor</a></li>
<li class="toctree-l3"><a class="reference internal" href="power_management.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="sleep_modes.html">Sleep Modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="wdts.html">Watchdogs</a></li>
<li class="toctree-l3"><a class="reference internal" href="system_time.html">System Time</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">Configuration Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">Error Codes Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">H/W Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../esp32s2.html">ESP32-S2 Preview Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">Libraries and Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">Copyrights</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">语言/Languages</a></li>
<li class="toctree-l1"><a class="reference external" href="https://readthedocs.com/projects/espressif-esp-idf/downloads/">Guide Downloads</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index-2.html">ESP-IDF Programming Guide</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index-2.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">API Reference</a> &raquo;</li>
        
          <li><a href="index.html">System API</a> &raquo;</li>
        
      <li>FreeRTOS</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/espressif/esp-idf/blob/master/docs/en/api-reference/system/freertos.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="freertos">
<h1>FreeRTOS<a class="headerlink" href="#freertos" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>This section contains documentation of FreeRTOS types, functions, and macros. It is automatically generated from FreeRTOS header files.</p>
<p>For more information about FreeRTOS features specific to ESP-IDF, see <a class="reference internal" href="../../api-guides/freertos-smp.html"><span class="doc">ESP-IDF FreeRTOS SMP Changes</span></a>
and <a class="reference internal" href="freertos_additions.html"><span class="doc">ESP-IDF FreeRTOS Additions</span></a>.</p>
</div>
<div class="section" id="task-api">
<h2>Task API<a class="headerlink" href="#task-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="header-file">
<h3>Header File<a class="headerlink" href="#header-file" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/freertos/include/freertos/task.h">freertos/include/freertos/task.h</a></li>
</ul>
</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv423xTaskCreatePinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_tK10BaseType_t">
<span id="_CPPv323xTaskCreatePinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_tK10BaseType_t"></span><span id="_CPPv223xTaskCreatePinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_tK10BaseType_t"></span><span id="xTaskCreatePinnedToCore__TaskFunction_t.cCPC.uint32_tC.voidPC.UBaseType_t.TaskHandle_tPC.BaseType_tC"></span><span class="target" id="task_8h_1a27c6feed2bffa9de57b93f20abafa44c"></span>BaseType_t <code class="descname">xTaskCreatePinnedToCore</code><span class="sig-paren">(</span>TaskFunction_t <em>pvTaskCode</em>, <em class="property">const</em> char *<em class="property">const</em> <em>pcName</em>, <em class="property">const</em> uint32_t <em>usStackDepth</em>, void *<em class="property">const</em> <em>pvParameters</em>, UBaseType_t <em>uxPriority</em>, <a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> *<em class="property">const</em> <em>pvCreatedTask</em>, <em class="property">const</em> BaseType_t <em>xCoreID</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423xTaskCreatePinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_tK10BaseType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new task with a specified affinity.</p>
<p>This function is similar to xTaskCreate, but allows setting task affinity in SMP system.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdPASS if the task was successfully created and added to a ready list, otherwise an error code defined in the file projdefs.h </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pvTaskCode</span></code>: Pointer to the task entry function. Tasks must be implemented to never return (i.e. continuous loop).</li>
<li><code class="docutils literal notranslate"><span class="pre">pcName</span></code>: A descriptive name for the task. This is mainly used to facilitate debugging. Max length defined by configMAX_TASK_NAME_LEN - default is 16.</li>
<li><code class="docutils literal notranslate"><span class="pre">usStackDepth</span></code>: The size of the task stack specified as the number of bytes. Note that this differs from vanilla FreeRTOS.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvParameters</span></code>: Pointer that will be used as the parameter for the task being created.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxPriority</span></code>: The priority at which the task should run. Systems that include MPU support can optionally create tasks in a privileged (system) mode by setting bit portPRIVILEGE_BIT of the priority parameter. For example, to create a privileged task at priority 2 the uxPriority parameter should be set to ( 2 | portPRIVILEGE_BIT ).</li>
<li><code class="docutils literal notranslate"><span class="pre">pvCreatedTask</span></code>: Used to pass back a handle by which the created task can be referenced.</li>
<li><code class="docutils literal notranslate"><span class="pre">xCoreID</span></code>: If the value is tskNO_AFFINITY, the created task is not pinned to any CPU, and the scheduler can run it on any core available. Values 0 or 1 indicate the index number of the CPU which the task should be pinned to. Specifying values larger than (portNUM_PROCESSORS - 1) will cause the function to fail.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411xTaskCreate14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_t">
<span id="_CPPv311xTaskCreate14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_t"></span><span id="_CPPv211xTaskCreate14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_t"></span><span id="xTaskCreate__TaskFunction_t.cCPC.uint32_tC.voidPC.UBaseType_t.TaskHandle_tPC"></span><span class="target" id="task_8h_1a178c0f619519faf823e5cd9c87f8f201"></span><em class="property">static</em> BaseType_t <code class="descname">xTaskCreate</code><span class="sig-paren">(</span>TaskFunction_t <em>pvTaskCode</em>, <em class="property">const</em> char *<em class="property">const</em> <em>pcName</em>, <em class="property">const</em> uint32_t <em>usStackDepth</em>, void *<em class="property">const</em> <em>pvParameters</em>, UBaseType_t <em>uxPriority</em>, <a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> *<em class="property">const</em> <em>pvCreatedTask</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411xTaskCreate14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new task and add it to the list of tasks that are ready to run.</p>
<p>Internally, within the FreeRTOS implementation, tasks use two blocks of memory. The first block is used to hold the task’s data structures. The second block is used by the task as its stack. If a task is created using xTaskCreate() then both blocks of memory are automatically dynamically allocated inside the xTaskCreate() function. (see <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). If a task is created using xTaskCreateStatic() then the application writer must provide the required memory. xTaskCreateStatic() therefore allows a task to be created without using any dynamic memory allocation.</p>
<p>See xTaskCreateStatic() for a version that does not use any dynamic memory allocation.</p>
<p>xTaskCreate() can only be used to create a task that has unrestricted access to the entire microcontroller memory map. Systems that include MPU support can alternatively create an MPU constrained task using xTaskCreateRestricted().</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Task</span> <span class="n">to</span> <span class="n">be</span> <span class="n">created</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vTaskCode</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
 <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">)</span>
 <span class="p">{</span>
     <span class="o">//</span> <span class="n">Task</span> <span class="n">code</span> <span class="n">goes</span> <span class="n">here</span><span class="o">.</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">Function</span> <span class="n">that</span> <span class="n">creates</span> <span class="n">a</span> <span class="n">task</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vOtherFunction</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">static</span> <span class="n">uint8_t</span> <span class="n">ucParameterToPass</span><span class="p">;</span>
<span class="n">TaskHandle_t</span> <span class="n">xHandle</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

 <span class="o">//</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">task</span><span class="p">,</span> <span class="n">storing</span> <span class="n">the</span> <span class="n">handle</span><span class="o">.</span>  <span class="n">Note</span> <span class="n">that</span> <span class="n">the</span> <span class="n">passed</span> <span class="n">parameter</span> <span class="n">ucParameterToPass</span>
 <span class="o">//</span> <span class="n">must</span> <span class="n">exist</span> <span class="k">for</span> <span class="n">the</span> <span class="n">lifetime</span> <span class="n">of</span> <span class="n">the</span> <span class="n">task</span><span class="p">,</span> <span class="n">so</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">case</span> <span class="ow">is</span> <span class="n">declared</span> <span class="n">static</span><span class="o">.</span>  <span class="n">If</span> <span class="n">it</span> <span class="n">was</span> <span class="n">just</span> <span class="n">an</span>
 <span class="o">//</span> <span class="n">an</span> <span class="n">automatic</span> <span class="n">stack</span> <span class="n">variable</span> <span class="n">it</span> <span class="n">might</span> <span class="n">no</span> <span class="n">longer</span> <span class="n">exist</span><span class="p">,</span> <span class="ow">or</span> <span class="n">at</span> <span class="n">least</span> <span class="n">have</span> <span class="n">been</span> <span class="n">corrupted</span><span class="p">,</span> <span class="n">by</span> <span class="n">the</span> <span class="n">time</span>
 <span class="o">//</span> <span class="n">the</span> <span class="n">new</span> <span class="n">task</span> <span class="n">attempts</span> <span class="n">to</span> <span class="n">access</span> <span class="n">it</span><span class="o">.</span>
 <span class="n">xTaskCreate</span><span class="p">(</span> <span class="n">vTaskCode</span><span class="p">,</span> <span class="s2">&quot;NAME&quot;</span><span class="p">,</span> <span class="n">STACK_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ucParameterToPass</span><span class="p">,</span> <span class="n">tskIDLE_PRIORITY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHandle</span> <span class="p">);</span>
    <span class="n">configASSERT</span><span class="p">(</span> <span class="n">xHandle</span> <span class="p">);</span>

 <span class="o">//</span> <span class="n">Use</span> <span class="n">the</span> <span class="n">handle</span> <span class="n">to</span> <span class="n">delete</span> <span class="n">the</span> <span class="n">task</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xHandle</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="p">)</span>
    <span class="p">{</span>
     <span class="n">vTaskDelete</span><span class="p">(</span> <span class="n">xHandle</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdPASS if the task was successfully created and added to a ready list, otherwise an error code defined in the file projdefs.h</dd>
<dt><strong>Note</strong></dt>
<dd>If program uses thread local variables (ones specified with “__thread” keyword) then storage for them will be allocated on the task’s stack.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pvTaskCode</span></code>: Pointer to the task entry function. Tasks must be implemented to never return (i.e. continuous loop).</li>
<li><code class="docutils literal notranslate"><span class="pre">pcName</span></code>: A descriptive name for the task. This is mainly used to facilitate debugging. Max length defined by configMAX_TASK_NAME_LEN - default is 16.</li>
<li><code class="docutils literal notranslate"><span class="pre">usStackDepth</span></code>: The size of the task stack specified as the number of bytes. Note that this differs from vanilla FreeRTOS.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvParameters</span></code>: Pointer that will be used as the parameter for the task being created.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxPriority</span></code>: The priority at which the task should run. Systems that include MPU support can optionally create tasks in a privileged (system) mode by setting bit portPRIVILEGE_BIT of the priority parameter. For example, to create a privileged task at priority 2 the uxPriority parameter should be set to ( 2 | portPRIVILEGE_BIT ).</li>
<li><code class="docutils literal notranslate"><span class="pre">pvCreatedTask</span></code>: Used to pass back a handle by which the created task can be referenced.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv429xTaskCreateStaticPinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_tK10BaseType_t">
<span id="_CPPv329xTaskCreateStaticPinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_tK10BaseType_t"></span><span id="_CPPv229xTaskCreateStaticPinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_tK10BaseType_t"></span><span id="xTaskCreateStaticPinnedToCore__TaskFunction_t.cCPC.uint32_tC.voidPC.UBaseType_t.StackType_tPC.StaticTask_tPC.BaseType_tC"></span><span class="target" id="task_8h_1a8655dc497b2205f7b8fb6947859124eb"></span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <code class="descname">xTaskCreateStaticPinnedToCore</code><span class="sig-paren">(</span>TaskFunction_t <em>pvTaskCode</em>, <em class="property">const</em> char *<em class="property">const</em> <em>pcName</em>, <em class="property">const</em> uint32_t <em>ulStackDepth</em>, void *<em class="property">const</em> <em>pvParameters</em>, UBaseType_t <em>uxPriority</em>, StackType_t *<em class="property">const</em> <em>pxStackBuffer</em>, StaticTask_t *<em class="property">const</em> <em>pxTaskBuffer</em>, <em class="property">const</em> BaseType_t <em>xCoreID</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429xTaskCreateStaticPinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_tK10BaseType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new task with a specified affinity.</p>
<p>This function is similar to xTaskCreateStatic, but allows specifying task affinity in an SMP system.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will be created and a task handle will be returned by which the created task can be referenced. If either pxStackBuffer or pxTaskBuffer are NULL then the task will not be created and NULL is returned. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pvTaskCode</span></code>: Pointer to the task entry function. Tasks must be implemented to never return (i.e. continuous loop).</li>
<li><code class="docutils literal notranslate"><span class="pre">pcName</span></code>: A descriptive name for the task. This is mainly used to facilitate debugging. The maximum length of the string is defined by configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.</li>
<li><code class="docutils literal notranslate"><span class="pre">ulStackDepth</span></code>: The size of the task stack specified as the number of bytes. Note that this differs from vanilla FreeRTOS.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvParameters</span></code>: Pointer that will be used as the parameter for the task being created.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxPriority</span></code>: The priority at which the task will run.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxStackBuffer</span></code>: Must point to a StackType_t array that has at least ulStackDepth indexes - the array will then be used as the task’s stack, removing the need for the stack to be allocated dynamically.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxTaskBuffer</span></code>: Must point to a variable of type StaticTask_t, which will then be used to hold the task’s data structures, removing the need for the memory to be allocated dynamically.</li>
<li><code class="docutils literal notranslate"><span class="pre">xCoreID</span></code>: If the value is tskNO_AFFINITY, the created task is not pinned to any CPU, and the scheduler can run it on any core available. Values 0 or 1 indicate the index number of the CPU which the task should be pinned to. Specifying values larger than (portNUM_PROCESSORS - 1) will cause the function to fail.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417xTaskCreateStatic14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_t">
<span id="_CPPv317xTaskCreateStatic14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_t"></span><span id="_CPPv217xTaskCreateStatic14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_t"></span><span id="xTaskCreateStatic__TaskFunction_t.cCPC.uint32_tC.voidPC.UBaseType_t.StackType_tPC.StaticTask_tPC"></span><span class="target" id="task_8h_1a415a359e0177add17a963f5e97c16f8c"></span><em class="property">static</em> <a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <code class="descname">xTaskCreateStatic</code><span class="sig-paren">(</span>TaskFunction_t <em>pvTaskCode</em>, <em class="property">const</em> char *<em class="property">const</em> <em>pcName</em>, <em class="property">const</em> uint32_t <em>ulStackDepth</em>, void *<em class="property">const</em> <em>pvParameters</em>, UBaseType_t <em>uxPriority</em>, StackType_t *<em class="property">const</em> <em>pxStackBuffer</em>, StaticTask_t *<em class="property">const</em> <em>pxTaskBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417xTaskCreateStatic14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new task and add it to the list of tasks that are ready to run.</p>
<p>Internally, within the FreeRTOS implementation, tasks use two blocks of memory. The first block is used to hold the task’s data structures. The second block is used by the task as its stack. If a task is created using xTaskCreate() then both blocks of memory are automatically dynamically allocated inside the xTaskCreate() function. (see <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). If a task is created using xTaskCreateStatic() then the application writer must provide the required memory. xTaskCreateStatic() therefore allows a task to be created without using any dynamic memory allocation.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Dimensions</span> <span class="n">the</span> <span class="n">buffer</span> <span class="n">that</span> <span class="n">the</span> <span class="n">task</span> <span class="n">being</span> <span class="n">created</span> <span class="n">will</span> <span class="n">use</span> <span class="k">as</span> <span class="n">its</span> <span class="n">stack</span><span class="o">.</span>
<span class="o">//</span> <span class="n">NOTE</span><span class="p">:</span>  <span class="n">This</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="nb">bytes</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">will</span> <span class="n">hold</span><span class="p">,</span> <span class="ow">not</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span>
<span class="o">//</span> <span class="n">words</span> <span class="k">as</span> <span class="n">found</span> <span class="ow">in</span> <span class="n">vanilla</span> <span class="n">FreeRTOS</span><span class="o">.</span>
<span class="c1">#define STACK_SIZE 200</span>

<span class="o">//</span> <span class="n">Structure</span> <span class="n">that</span> <span class="n">will</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">TCB</span> <span class="n">of</span> <span class="n">the</span> <span class="n">task</span> <span class="n">being</span> <span class="n">created</span><span class="o">.</span>
<span class="n">StaticTask_t</span> <span class="n">xTaskBuffer</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Buffer</span> <span class="n">that</span> <span class="n">the</span> <span class="n">task</span> <span class="n">being</span> <span class="n">created</span> <span class="n">will</span> <span class="n">use</span> <span class="k">as</span> <span class="n">its</span> <span class="n">stack</span><span class="o">.</span>  <span class="n">Note</span> <span class="n">this</span> <span class="ow">is</span>
<span class="o">//</span> <span class="n">an</span> <span class="n">array</span> <span class="n">of</span> <span class="n">StackType_t</span> <span class="n">variables</span><span class="o">.</span>  <span class="n">The</span> <span class="n">size</span> <span class="n">of</span> <span class="n">StackType_t</span> <span class="ow">is</span> <span class="n">dependent</span> <span class="n">on</span>
<span class="o">//</span> <span class="n">the</span> <span class="n">RTOS</span> <span class="n">port</span><span class="o">.</span>
<span class="n">StackType_t</span> <span class="n">xStack</span><span class="p">[</span> <span class="n">STACK_SIZE</span> <span class="p">];</span>

<span class="o">//</span> <span class="n">Function</span> <span class="n">that</span> <span class="n">implements</span> <span class="n">the</span> <span class="n">task</span> <span class="n">being</span> <span class="n">created</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vTaskCode</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">The</span> <span class="n">parameter</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="n">be</span> <span class="mi">1</span> <span class="k">as</span> <span class="mi">1</span> <span class="ow">is</span> <span class="n">passed</span> <span class="ow">in</span> <span class="n">the</span>
    <span class="o">//</span> <span class="n">pvParameters</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">call</span> <span class="n">to</span> <span class="n">xTaskCreateStatic</span><span class="p">()</span><span class="o">.</span>
    <span class="n">configASSERT</span><span class="p">(</span> <span class="p">(</span> <span class="n">uint32_t</span> <span class="p">)</span> <span class="n">pvParameters</span> <span class="o">==</span> <span class="mi">1</span><span class="n">UL</span> <span class="p">);</span>

    <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Task</span> <span class="n">code</span> <span class="n">goes</span> <span class="n">here</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">Function</span> <span class="n">that</span> <span class="n">creates</span> <span class="n">a</span> <span class="n">task</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vOtherFunction</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">TaskHandle_t</span> <span class="n">xHandle</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">task</span> <span class="n">without</span> <span class="n">using</span> <span class="nb">any</span> <span class="n">dynamic</span> <span class="n">memory</span> <span class="n">allocation</span><span class="o">.</span>
    <span class="n">xHandle</span> <span class="o">=</span> <span class="n">xTaskCreateStatic</span><span class="p">(</span>
                  <span class="n">vTaskCode</span><span class="p">,</span>       <span class="o">//</span> <span class="n">Function</span> <span class="n">that</span> <span class="n">implements</span> <span class="n">the</span> <span class="n">task</span><span class="o">.</span>
                  <span class="s2">&quot;NAME&quot;</span><span class="p">,</span>          <span class="o">//</span> <span class="n">Text</span> <span class="n">name</span> <span class="k">for</span> <span class="n">the</span> <span class="n">task</span><span class="o">.</span>
                  <span class="n">STACK_SIZE</span><span class="p">,</span>      <span class="o">//</span> <span class="n">Stack</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">bytes</span><span class="p">,</span> <span class="ow">not</span> <span class="n">words</span><span class="o">.</span>
                  <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="mi">1</span><span class="p">,</span>    <span class="o">//</span> <span class="n">Parameter</span> <span class="n">passed</span> <span class="n">into</span> <span class="n">the</span> <span class="n">task</span><span class="o">.</span>
                  <span class="n">tskIDLE_PRIORITY</span><span class="p">,</span><span class="o">//</span> <span class="n">Priority</span> <span class="n">at</span> <span class="n">which</span> <span class="n">the</span> <span class="n">task</span> <span class="ow">is</span> <span class="n">created</span><span class="o">.</span>
                  <span class="n">xStack</span><span class="p">,</span>          <span class="o">//</span> <span class="n">Array</span> <span class="n">to</span> <span class="n">use</span> <span class="k">as</span> <span class="n">the</span> <span class="n">task</span><span class="s1">&#39;s stack.</span>
                  <span class="o">&amp;</span><span class="n">xTaskBuffer</span> <span class="p">);</span>  <span class="o">//</span> <span class="n">Variable</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">task</span><span class="s1">&#39;s data structure.</span>

    <span class="o">//</span> <span class="n">puxStackBuffer</span> <span class="ow">and</span> <span class="n">pxTaskBuffer</span> <span class="n">were</span> <span class="ow">not</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">so</span> <span class="n">the</span> <span class="n">task</span> <span class="n">will</span> <span class="n">have</span>
    <span class="o">//</span> <span class="n">been</span> <span class="n">created</span><span class="p">,</span> <span class="ow">and</span> <span class="n">xHandle</span> <span class="n">will</span> <span class="n">be</span> <span class="n">the</span> <span class="n">task</span><span class="s1">&#39;s handle.  Use the handle</span>
    <span class="o">//</span> <span class="n">to</span> <span class="n">suspend</span> <span class="n">the</span> <span class="n">task</span><span class="o">.</span>
    <span class="n">vTaskSuspend</span><span class="p">(</span> <span class="n">xHandle</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will be created and a task handle will be returned by which the created task can be referenced. If either pxStackBuffer or pxTaskBuffer are NULL then the task will not be created and NULL is returned.</dd>
<dt><strong>Note</strong></dt>
<dd>If program uses thread local variables (ones specified with “__thread” keyword) then storage for them will be allocated on the task’s stack.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pvTaskCode</span></code>: Pointer to the task entry function. Tasks must be implemented to never return (i.e. continuous loop).</li>
<li><code class="docutils literal notranslate"><span class="pre">pcName</span></code>: A descriptive name for the task. This is mainly used to facilitate debugging. The maximum length of the string is defined by configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.</li>
<li><code class="docutils literal notranslate"><span class="pre">ulStackDepth</span></code>: The size of the task stack specified as the number of bytes. Note that this differs from vanilla FreeRTOS.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvParameters</span></code>: Pointer that will be used as the parameter for the task being created.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxPriority</span></code>: The priority at which the task will run.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxStackBuffer</span></code>: Must point to a StackType_t array that has at least ulStackDepth indexes - the array will then be used as the task’s stack, removing the need for the stack to be allocated dynamically.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxTaskBuffer</span></code>: Must point to a variable of type StaticTask_t, which will then be used to hold the task’s data structures, removing the need for the memory to be allocated dynamically.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411vTaskDelete12TaskHandle_t">
<span id="_CPPv311vTaskDelete12TaskHandle_t"></span><span id="_CPPv211vTaskDelete12TaskHandle_t"></span><span id="vTaskDelete__TaskHandle_t"></span><span class="target" id="task_8h_1a27ff4ebce26565bef136bda84201ff80"></span>void <code class="descname">vTaskDelete</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToDelete</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411vTaskDelete12TaskHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Remove a task from the RTOS real time kernel’s management.</p>
<p>The task being deleted will be removed from all ready, blocked, suspended and event lists.</p>
<p>INCLUDE_vTaskDelete must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p><p>See the demo application file death.c for sample code that utilises vTaskDelete ().</p>
<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The idle task is responsible for freeing the kernel allocated memory from tasks that have been deleted. It is therefore important that the idle task is not starved of microcontroller processing time if your application makes any calls to vTaskDelete (). Memory allocated by the task code is not automatically freed, and should be freed before the task is deleted.</dd>
</dl>
</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vOtherFunction</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">TaskHandle_t</span> <span class="n">xHandle</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">task</span><span class="p">,</span> <span class="n">storing</span> <span class="n">the</span> <span class="n">handle</span><span class="o">.</span>
    <span class="n">xTaskCreate</span><span class="p">(</span> <span class="n">vTaskCode</span><span class="p">,</span> <span class="s2">&quot;NAME&quot;</span><span class="p">,</span> <span class="n">STACK_SIZE</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">tskIDLE_PRIORITY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHandle</span> <span class="p">);</span>

    <span class="o">//</span> <span class="n">Use</span> <span class="n">the</span> <span class="n">handle</span> <span class="n">to</span> <span class="n">delete</span> <span class="n">the</span> <span class="n">task</span><span class="o">.</span>
    <span class="n">vTaskDelete</span><span class="p">(</span> <span class="n">xHandle</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToDelete</span></code>: The handle of the task to be deleted. Passing NULL will cause the calling task to be deleted.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv410vTaskDelayK10TickType_t">
<span id="_CPPv310vTaskDelayK10TickType_t"></span><span id="_CPPv210vTaskDelayK10TickType_t"></span><span id="vTaskDelay__TickType_tC"></span><span class="target" id="task_8h_1aa154068cecd7f31446a7a84af44ab1a3"></span>void <code class="descname">vTaskDelay</code><span class="sig-paren">(</span><em class="property">const</em> TickType_t <em>xTicksToDelay</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410vTaskDelayK10TickType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Delay a task for a given number of ticks.</p>
<p>The actual time that the task remains blocked depends on the tick rate. The constant portTICK_PERIOD_MS can be used to calculate real time from the tick rate - with the resolution of one tick period.</p>
<p>INCLUDE_vTaskDelay must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>vTaskDelay() specifies a time at which the task wishes to unblock relative to the time at which vTaskDelay() is called. For example, specifying a block period of 100 ticks will cause the task to unblock 100 ticks after vTaskDelay() is called. vTaskDelay() does not therefore provide a good method of controlling the frequency of a periodic task as the path taken through the code, as well as other task and interrupt activity, will effect the frequency at which vTaskDelay() gets called and therefore the time at which the task next executes. See vTaskDelayUntil() for an alternative API function designed to facilitate fixed frequency execution. It does this by specifying an absolute time (rather than a relative time) at which the calling task should unblock.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vTaskFunction</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="o">//</span> <span class="n">Block</span> <span class="k">for</span> <span class="mi">500</span><span class="n">ms</span><span class="o">.</span>
<span class="n">const</span> <span class="n">TickType_t</span> <span class="n">xDelay</span> <span class="o">=</span> <span class="mi">500</span> <span class="o">/</span> <span class="n">portTICK_PERIOD_MS</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Simply</span> <span class="n">toggle</span> <span class="n">the</span> <span class="n">LED</span> <span class="n">every</span> <span class="mi">500</span><span class="n">ms</span><span class="p">,</span> <span class="n">blocking</span> <span class="n">between</span> <span class="n">each</span> <span class="n">toggle</span><span class="o">.</span>
        <span class="n">vToggleLED</span><span class="p">();</span>
        <span class="n">vTaskDelay</span><span class="p">(</span> <span class="n">xDelay</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTicksToDelay</span></code>: The amount of time, in tick periods, that the calling task should block.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415vTaskDelayUntilPC10TickType_tK10TickType_t">
<span id="_CPPv315vTaskDelayUntilPC10TickType_tK10TickType_t"></span><span id="_CPPv215vTaskDelayUntilPC10TickType_tK10TickType_t"></span><span id="vTaskDelayUntil__TickType_tPC.TickType_tC"></span><span class="target" id="task_8h_1a067da3e949e248096ec6c01f9cb75a47"></span>void <code class="descname">vTaskDelayUntil</code><span class="sig-paren">(</span>TickType_t *<em class="property">const</em> <em>pxPreviousWakeTime</em>, <em class="property">const</em> TickType_t <em>xTimeIncrement</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415vTaskDelayUntilPC10TickType_tK10TickType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Delay a task until a specified time.</p>
<p>INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>This function can be used by periodic tasks to ensure a constant execution frequency.</p>
<p>This function differs from vTaskDelay () in one important aspect: vTaskDelay () will cause a task to block for the specified number of ticks from the time vTaskDelay () is called. It is therefore difficult to use vTaskDelay () by itself to generate a fixed execution frequency as the time between a task starting to execute and that task calling vTaskDelay () may not be fixed [the task may take a different path though the code between calls, or may get interrupted or preempted a different number of times each time it executes].</p>
<p>Whereas vTaskDelay () specifies a wake time relative to the time at which the function is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to unblock.</p>
<p>The constant portTICK_PERIOD_MS can be used to calculate real time from the tick rate - with the resolution of one tick period.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Perform</span> <span class="n">an</span> <span class="n">action</span> <span class="n">every</span> <span class="mi">10</span> <span class="n">ticks</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vTaskFunction</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">TickType_t</span> <span class="n">xLastWakeTime</span><span class="p">;</span>
<span class="n">const</span> <span class="n">TickType_t</span> <span class="n">xFrequency</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Initialise</span> <span class="n">the</span> <span class="n">xLastWakeTime</span> <span class="n">variable</span> <span class="k">with</span> <span class="n">the</span> <span class="n">current</span> <span class="n">time</span><span class="o">.</span>
    <span class="n">xLastWakeTime</span> <span class="o">=</span> <span class="n">xTaskGetTickCount</span> <span class="p">();</span>
    <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Wait</span> <span class="k">for</span> <span class="n">the</span> <span class="nb">next</span> <span class="n">cycle</span><span class="o">.</span>
        <span class="n">vTaskDelayUntil</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">xLastWakeTime</span><span class="p">,</span> <span class="n">xFrequency</span> <span class="p">);</span>

        <span class="o">//</span> <span class="n">Perform</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pxPreviousWakeTime</span></code>: Pointer to a variable that holds the time at which the task was last unblocked. The variable must be initialised with the current time prior to its first use (see the example below). Following this the variable is automatically updated within vTaskDelayUntil ().</li>
<li><code class="docutils literal notranslate"><span class="pre">xTimeIncrement</span></code>: The cycle time period. The task will be unblocked at time *pxPreviousWakeTime + xTimeIncrement. Calling vTaskDelayUntil with the same xTimeIncrement parameter value will cause the task to execute with a fixed interface period.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417uxTaskPriorityGet12TaskHandle_t">
<span id="_CPPv317uxTaskPriorityGet12TaskHandle_t"></span><span id="_CPPv217uxTaskPriorityGet12TaskHandle_t"></span><span id="uxTaskPriorityGet__TaskHandle_t"></span><span class="target" id="task_8h_1a3edc3f1a0adc8403f42529bce4ae3446"></span>UBaseType_t <code class="descname">uxTaskPriorityGet</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTask</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417uxTaskPriorityGet12TaskHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Obtain the priority of any task.</p>
<p>INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> void vAFunction( void )
 {
 TaskHandle_t xHandle;

  // Create a task, storing the handle.
  xTaskCreate( vTaskCode, &quot;NAME&quot;, STACK_SIZE, NULL, tskIDLE_PRIORITY, &amp;xHandle );

  // ...

  // Use the handle to obtain the priority of the created task.
  // It was created with tskIDLE_PRIORITY, but may have changed
  // it itself.
  if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
  {
      // The task has changed it&#39;s priority.
  }

  // ...

  // Is our priority higher than the created task?
  if( uxTaskPriorityGet( xHandle ) &lt; uxTaskPriorityGet( NULL ) )
  {
      // Our priority (obtained using NULL handle) is higher.
  }
}
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The priority of xTask.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTask</span></code>: Handle of the task to be queried. Passing a NULL handle results in the priority of the calling task being returned.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424uxTaskPriorityGetFromISR12TaskHandle_t">
<span id="_CPPv324uxTaskPriorityGetFromISR12TaskHandle_t"></span><span id="_CPPv224uxTaskPriorityGetFromISR12TaskHandle_t"></span><span id="uxTaskPriorityGetFromISR__TaskHandle_t"></span><span class="target" id="task_8h_1abc808e43d257a47de4b431483c65ea15"></span>UBaseType_t <code class="descname">uxTaskPriorityGetFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTask</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424uxTaskPriorityGetFromISR12TaskHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A version of uxTaskPriorityGet() that can be used from an ISR.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The priority of xTask. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTask</span></code>: Handle of the task to be queried. Passing a NULL handle results in the priority of the calling task being returned.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv413eTaskGetState12TaskHandle_t">
<span id="_CPPv313eTaskGetState12TaskHandle_t"></span><span id="_CPPv213eTaskGetState12TaskHandle_t"></span><span id="eTaskGetState__TaskHandle_t"></span><span class="target" id="task_8h_1a954df77397d616484edb7c58c7760b10"></span><a class="reference internal" href="#_CPPv410eTaskState" title="eTaskState">eTaskState</a> <code class="descname">eTaskGetState</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTask</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413eTaskGetState12TaskHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Obtain the state of any task.</p>
<p>States are encoded by the eTaskState enumerated type.</p>
<p>INCLUDE_eTaskGetState must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The state of xTask at the time the function was called. Note the state of the task might change between the function being called, and the functions return value being tested by the calling task. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTask</span></code>: Handle of the task to be queried.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416vTaskPrioritySet12TaskHandle_t11UBaseType_t">
<span id="_CPPv316vTaskPrioritySet12TaskHandle_t11UBaseType_t"></span><span id="_CPPv216vTaskPrioritySet12TaskHandle_t11UBaseType_t"></span><span id="vTaskPrioritySet__TaskHandle_t.UBaseType_t"></span><span class="target" id="task_8h_1a1ee31be76e326e0644dbd6ac40a787b6"></span>void <code class="descname">vTaskPrioritySet</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTask</em>, UBaseType_t <em>uxNewPriority</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416vTaskPrioritySet12TaskHandle_t11UBaseType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the priority of any task.</p>
<p>INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>A context switch will occur before the function returns if the priority being set is higher than the currently executing task.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vAFunction</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">TaskHandle_t</span> <span class="n">xHandle</span><span class="p">;</span>

 <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="n">storing</span> <span class="n">the</span> <span class="n">handle</span><span class="o">.</span>
 <span class="n">xTaskCreate</span><span class="p">(</span> <span class="n">vTaskCode</span><span class="p">,</span> <span class="s2">&quot;NAME&quot;</span><span class="p">,</span> <span class="n">STACK_SIZE</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">tskIDLE_PRIORITY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHandle</span> <span class="p">);</span>

 <span class="o">//</span> <span class="o">...</span>

 <span class="o">//</span> <span class="n">Use</span> <span class="n">the</span> <span class="n">handle</span> <span class="n">to</span> <span class="k">raise</span> <span class="n">the</span> <span class="n">priority</span> <span class="n">of</span> <span class="n">the</span> <span class="n">created</span> <span class="n">task</span><span class="o">.</span>
 <span class="n">vTaskPrioritySet</span><span class="p">(</span> <span class="n">xHandle</span><span class="p">,</span> <span class="n">tskIDLE_PRIORITY</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>

 <span class="o">//</span> <span class="o">...</span>

 <span class="o">//</span> <span class="n">Use</span> <span class="n">a</span> <span class="n">NULL</span> <span class="n">handle</span> <span class="n">to</span> <span class="k">raise</span> <span class="n">our</span> <span class="n">priority</span> <span class="n">to</span> <span class="n">the</span> <span class="n">same</span> <span class="n">value</span><span class="o">.</span>
 <span class="n">vTaskPrioritySet</span><span class="p">(</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">tskIDLE_PRIORITY</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTask</span></code>: Handle to the task for which the priority is being set. Passing a NULL handle results in the priority of the calling task being set.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxNewPriority</span></code>: The priority to which the task will be set.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412vTaskSuspend12TaskHandle_t">
<span id="_CPPv312vTaskSuspend12TaskHandle_t"></span><span id="_CPPv212vTaskSuspend12TaskHandle_t"></span><span id="vTaskSuspend__TaskHandle_t"></span><span class="target" id="task_8h_1a84d4e660b04630be2939d91b3c2412f8"></span>void <code class="descname">vTaskSuspend</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToSuspend</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412vTaskSuspend12TaskHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Suspend a task.</p>
<p>INCLUDE_vTaskSuspend must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>When suspended, a task will never get any microcontroller processing time, no matter what its priority.</p>
<p>Calls to vTaskSuspend are not accumulative - i.e. calling vTaskSuspend () twice on the same task still only requires one call to vTaskResume () to ready the suspended task.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vAFunction</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">TaskHandle_t</span> <span class="n">xHandle</span><span class="p">;</span>

 <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="n">storing</span> <span class="n">the</span> <span class="n">handle</span><span class="o">.</span>
 <span class="n">xTaskCreate</span><span class="p">(</span> <span class="n">vTaskCode</span><span class="p">,</span> <span class="s2">&quot;NAME&quot;</span><span class="p">,</span> <span class="n">STACK_SIZE</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">tskIDLE_PRIORITY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHandle</span> <span class="p">);</span>

 <span class="o">//</span> <span class="o">...</span>

 <span class="o">//</span> <span class="n">Use</span> <span class="n">the</span> <span class="n">handle</span> <span class="n">to</span> <span class="n">suspend</span> <span class="n">the</span> <span class="n">created</span> <span class="n">task</span><span class="o">.</span>
 <span class="n">vTaskSuspend</span><span class="p">(</span> <span class="n">xHandle</span> <span class="p">);</span>

 <span class="o">//</span> <span class="o">...</span>

 <span class="o">//</span> <span class="n">The</span> <span class="n">created</span> <span class="n">task</span> <span class="n">will</span> <span class="ow">not</span> <span class="n">run</span> <span class="n">during</span> <span class="n">this</span> <span class="n">period</span><span class="p">,</span> <span class="n">unless</span>
 <span class="o">//</span> <span class="n">another</span> <span class="n">task</span> <span class="n">calls</span> <span class="n">vTaskResume</span><span class="p">(</span> <span class="n">xHandle</span> <span class="p">)</span><span class="o">.</span>

 <span class="o">//...</span>


 <span class="o">//</span> <span class="n">Suspend</span> <span class="n">ourselves</span><span class="o">.</span>
 <span class="n">vTaskSuspend</span><span class="p">(</span> <span class="n">NULL</span> <span class="p">);</span>

 <span class="o">//</span> <span class="n">We</span> <span class="n">cannot</span> <span class="n">get</span> <span class="n">here</span> <span class="n">unless</span> <span class="n">another</span> <span class="n">task</span> <span class="n">calls</span> <span class="n">vTaskResume</span>
 <span class="o">//</span> <span class="k">with</span> <span class="n">our</span> <span class="n">handle</span> <span class="k">as</span> <span class="n">the</span> <span class="n">parameter</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToSuspend</span></code>: Handle to the task being suspended. Passing a NULL handle will cause the calling task to be suspended.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411vTaskResume12TaskHandle_t">
<span id="_CPPv311vTaskResume12TaskHandle_t"></span><span id="_CPPv211vTaskResume12TaskHandle_t"></span><span id="vTaskResume__TaskHandle_t"></span><span class="target" id="task_8h_1a84a1584f29fb7736a1aa72ad5b3e9b44"></span>void <code class="descname">vTaskResume</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToResume</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411vTaskResume12TaskHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resumes a suspended task.</p>
<p>INCLUDE_vTaskSuspend must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>A task that has been suspended by one or more calls to vTaskSuspend () will be made available for running again by a single call to vTaskResume ().</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vAFunction</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">TaskHandle_t</span> <span class="n">xHandle</span><span class="p">;</span>

 <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="n">storing</span> <span class="n">the</span> <span class="n">handle</span><span class="o">.</span>
 <span class="n">xTaskCreate</span><span class="p">(</span> <span class="n">vTaskCode</span><span class="p">,</span> <span class="s2">&quot;NAME&quot;</span><span class="p">,</span> <span class="n">STACK_SIZE</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">tskIDLE_PRIORITY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHandle</span> <span class="p">);</span>

 <span class="o">//</span> <span class="o">...</span>

 <span class="o">//</span> <span class="n">Use</span> <span class="n">the</span> <span class="n">handle</span> <span class="n">to</span> <span class="n">suspend</span> <span class="n">the</span> <span class="n">created</span> <span class="n">task</span><span class="o">.</span>
 <span class="n">vTaskSuspend</span><span class="p">(</span> <span class="n">xHandle</span> <span class="p">);</span>

 <span class="o">//</span> <span class="o">...</span>

 <span class="o">//</span> <span class="n">The</span> <span class="n">created</span> <span class="n">task</span> <span class="n">will</span> <span class="ow">not</span> <span class="n">run</span> <span class="n">during</span> <span class="n">this</span> <span class="n">period</span><span class="p">,</span> <span class="n">unless</span>
 <span class="o">//</span> <span class="n">another</span> <span class="n">task</span> <span class="n">calls</span> <span class="n">vTaskResume</span><span class="p">(</span> <span class="n">xHandle</span> <span class="p">)</span><span class="o">.</span>

 <span class="o">//...</span>


 <span class="o">//</span> <span class="n">Resume</span> <span class="n">the</span> <span class="n">suspended</span> <span class="n">task</span> <span class="n">ourselves</span><span class="o">.</span>
 <span class="n">vTaskResume</span><span class="p">(</span> <span class="n">xHandle</span> <span class="p">);</span>

 <span class="o">//</span> <span class="n">The</span> <span class="n">created</span> <span class="n">task</span> <span class="n">will</span> <span class="n">once</span> <span class="n">again</span> <span class="n">get</span> <span class="n">microcontroller</span> <span class="n">processing</span>
 <span class="o">//</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">accordance</span> <span class="k">with</span> <span class="n">its</span> <span class="n">priority</span> <span class="n">within</span> <span class="n">the</span> <span class="n">system</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToResume</span></code>: Handle to the task being readied.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418xTaskResumeFromISR12TaskHandle_t">
<span id="_CPPv318xTaskResumeFromISR12TaskHandle_t"></span><span id="_CPPv218xTaskResumeFromISR12TaskHandle_t"></span><span id="xTaskResumeFromISR__TaskHandle_t"></span><span class="target" id="task_8h_1aefbfd37c0661c3062fafd7334bff9aed"></span>BaseType_t <code class="descname">xTaskResumeFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToResume</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418xTaskResumeFromISR12TaskHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>An implementation of vTaskResume() that can be called from within an ISR.</p>
<p>INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>A task that has been suspended by one or more calls to vTaskSuspend () will be made available for running again by a single call to xTaskResumeFromISR ().</p>
<p>xTaskResumeFromISR() should not be used to synchronise a task with an interrupt if there is a chance that the interrupt could arrive prior to the task being suspended - as this can lead to interrupts being missed. Use of a semaphore as a synchronisation mechanism would avoid this eventuality.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if resuming the task should result in a context switch, otherwise pdFALSE. This is used by the ISR to determine if a context switch may be required following the ISR. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToResume</span></code>: Handle to the task being readied.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415vTaskSuspendAllv">
<span id="_CPPv315vTaskSuspendAllv"></span><span id="_CPPv215vTaskSuspendAllv"></span><span id="vTaskSuspendAll__void"></span><span class="target" id="task_8h_1a366b302eba79d10b5ee2a3756f0fcc43"></span>void <code class="descname">vTaskSuspendAll</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415vTaskSuspendAllv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Suspends the scheduler without disabling interrupts.</p>
<p>Context switches will not occur while the scheduler is suspended.</p>
<p>After calling vTaskSuspendAll () the calling task will continue to execute without risk of being swapped out until a call to xTaskResumeAll () has been made.</p>
<p>API functions that have the potential to cause a context switch (for example, vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler is suspended.</p>
<p>Example usage: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vTask1</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
 <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">)</span>
 <span class="p">{</span>
     <span class="o">//</span> <span class="n">Task</span> <span class="n">code</span> <span class="n">goes</span> <span class="n">here</span><span class="o">.</span>

     <span class="o">//</span> <span class="o">...</span>

     <span class="o">//</span> <span class="n">At</span> <span class="n">some</span> <span class="n">point</span> <span class="n">the</span> <span class="n">task</span> <span class="n">wants</span> <span class="n">to</span> <span class="n">perform</span> <span class="n">a</span> <span class="n">long</span> <span class="n">operation</span> <span class="n">during</span>
     <span class="o">//</span> <span class="n">which</span> <span class="n">it</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">want</span> <span class="n">to</span> <span class="n">get</span> <span class="n">swapped</span> <span class="n">out</span><span class="o">.</span>  <span class="n">It</span> <span class="n">cannot</span> <span class="n">use</span>
     <span class="o">//</span> <span class="n">taskENTER_CRITICAL</span> <span class="p">()</span><span class="o">/</span><span class="n">taskEXIT_CRITICAL</span> <span class="p">()</span> <span class="k">as</span> <span class="n">the</span> <span class="n">length</span> <span class="n">of</span> <span class="n">the</span>
     <span class="o">//</span> <span class="n">operation</span> <span class="n">may</span> <span class="n">cause</span> <span class="n">interrupts</span> <span class="n">to</span> <span class="n">be</span> <span class="n">missed</span> <span class="o">-</span> <span class="n">including</span> <span class="n">the</span>
     <span class="o">//</span> <span class="n">ticks</span><span class="o">.</span>

     <span class="o">//</span> <span class="n">Prevent</span> <span class="n">the</span> <span class="n">real</span> <span class="n">time</span> <span class="n">kernel</span> <span class="n">swapping</span> <span class="n">out</span> <span class="n">the</span> <span class="n">task</span><span class="o">.</span>
     <span class="n">vTaskSuspendAll</span> <span class="p">();</span>

     <span class="o">//</span> <span class="n">Perform</span> <span class="n">the</span> <span class="n">operation</span> <span class="n">here</span><span class="o">.</span>  <span class="n">There</span> <span class="ow">is</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">use</span> <span class="n">critical</span>
     <span class="o">//</span> <span class="n">sections</span> <span class="k">as</span> <span class="n">we</span> <span class="n">have</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">microcontroller</span> <span class="n">processing</span> <span class="n">time</span><span class="o">.</span>
     <span class="o">//</span> <span class="n">During</span> <span class="n">this</span> <span class="n">time</span> <span class="n">interrupts</span> <span class="n">will</span> <span class="n">still</span> <span class="n">operate</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">kernel</span>
     <span class="o">//</span> <span class="n">tick</span> <span class="n">count</span> <span class="n">will</span> <span class="n">be</span> <span class="n">maintained</span><span class="o">.</span>

     <span class="o">//</span> <span class="o">...</span>

     <span class="o">//</span> <span class="n">The</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">complete</span><span class="o">.</span>  <span class="n">Restart</span> <span class="n">the</span> <span class="n">kernel</span><span class="o">.</span>
     <span class="n">xTaskResumeAll</span> <span class="p">();</span>
 <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414xTaskResumeAllv">
<span id="_CPPv314xTaskResumeAllv"></span><span id="_CPPv214xTaskResumeAllv"></span><span id="xTaskResumeAll__void"></span><span class="target" id="task_8h_1a003f8ae6d649225abd030cc76e1c7d0e"></span>BaseType_t <code class="descname">xTaskResumeAll</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414xTaskResumeAllv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resumes scheduler activity after it was suspended by a call to vTaskSuspendAll().</p>
<p>xTaskResumeAll() only resumes the scheduler. It does not unsuspend tasks that were previously suspended by a call to vTaskSuspend().</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>void vTask1( void * pvParameters )
{
 for( ;; )
 {
     // Task code goes here.

     // ...

     // At some point the task wants to perform a long operation during
     // which it does not want to get swapped out.  It cannot use
     // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
     // operation may cause interrupts to be missed - including the
     // ticks.

     // Prevent the real time kernel swapping out the task.
     vTaskSuspendAll ();

     // Perform the operation here.  There is no need to use critical
     // sections as we have all the microcontroller processing time.
     // During this time interrupts will still operate and the real
     // time kernel tick count will be maintained.

     // ...

     // The operation is complete.  Restart the kernel.  We want to force
     // a context switch - but there is no point if resuming the scheduler
     // caused a context switch already.
     if( !xTaskResumeAll () )
     {
          taskYIELD ();
     }
 }
}
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If resuming the scheduler caused a context switch then pdTRUE is returned, otherwise pdFALSE is returned.</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417xTaskGetTickCountv">
<span id="_CPPv317xTaskGetTickCountv"></span><span id="_CPPv217xTaskGetTickCountv"></span><span id="xTaskGetTickCount__void"></span><span class="target" id="task_8h_1a753ecfe23e7386066ecccad5d16422f7"></span>TickType_t <code class="descname">xTaskGetTickCount</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417xTaskGetTickCountv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get tick count</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The count of ticks since vTaskStartScheduler was called. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424xTaskGetTickCountFromISRv">
<span id="_CPPv324xTaskGetTickCountFromISRv"></span><span id="_CPPv224xTaskGetTickCountFromISRv"></span><span id="xTaskGetTickCountFromISR__void"></span><span class="target" id="task_8h_1a092be3fd5752625303c307620be523ff"></span>TickType_t <code class="descname">xTaskGetTickCountFromISR</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424xTaskGetTickCountFromISRv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get tick count from ISR</p>
<p><p>This is a version of xTaskGetTickCount() that is safe to be called from an ISR - provided that TickType_t is the natural word size of the microcontroller being used or interrupt nesting is either not supported or not being used. </p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The count of ticks since vTaskStartScheduler was called.</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422uxTaskGetNumberOfTasksv">
<span id="_CPPv322uxTaskGetNumberOfTasksv"></span><span id="_CPPv222uxTaskGetNumberOfTasksv"></span><span id="uxTaskGetNumberOfTasks__void"></span><span class="target" id="task_8h_1a70a89a0f07c7db5d695707d1f6f44a4a"></span>UBaseType_t <code class="descname">uxTaskGetNumberOfTasks</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422uxTaskGetNumberOfTasksv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get current number of tasks</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The number of tasks that the real time kernel is currently managing. This includes all ready, blocked and suspended tasks. A task that has been deleted but not yet freed by the idle task will also be included in the count. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417pcTaskGetTaskName12TaskHandle_t">
<span id="_CPPv317pcTaskGetTaskName12TaskHandle_t"></span><span id="_CPPv217pcTaskGetTaskName12TaskHandle_t"></span><span id="pcTaskGetTaskName__TaskHandle_t"></span><span class="target" id="task_8h_1a4344bd56963429dfa26b0af913349e84"></span>char *<code class="descname">pcTaskGetTaskName</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToQuery</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417pcTaskGetTaskName12TaskHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get task name</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The text (human readable) name of the task referenced by the handle xTaskToQuery. A task can query its own name by either passing in its own handle, or by setting xTaskToQuery to NULL. INCLUDE_pcTaskGetTaskName must be set to 1 in FreeRTOSConfig.h for pcTaskGetTaskName() to be available. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv427uxTaskGetStackHighWaterMark12TaskHandle_t">
<span id="_CPPv327uxTaskGetStackHighWaterMark12TaskHandle_t"></span><span id="_CPPv227uxTaskGetStackHighWaterMark12TaskHandle_t"></span><span id="uxTaskGetStackHighWaterMark__TaskHandle_t"></span><span class="target" id="task_8h_1a799967af01d328132cde814e47733437"></span>UBaseType_t <code class="descname">uxTaskGetStackHighWaterMark</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTask</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427uxTaskGetStackHighWaterMark12TaskHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the high water mark of the stack associated with xTask.</p>
<p>INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for this function to be available.</p>
<p>High water mark is the minimum free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task started. The smaller the returned number the closer the task has come to overflowing its stack.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The smallest amount of free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task referenced by xTask was created. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTask</span></code>: Handle of the task associated with the stack to be checked. Set xTask to NULL to check the stack of the calling task.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419pxTaskGetStackStart12TaskHandle_t">
<span id="_CPPv319pxTaskGetStackStart12TaskHandle_t"></span><span id="_CPPv219pxTaskGetStackStart12TaskHandle_t"></span><span id="pxTaskGetStackStart__TaskHandle_t"></span><span class="target" id="task_8h_1aba038232967f96f9f572d85c01637ad9"></span>uint8_t *<code class="descname">pxTaskGetStackStart</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTask</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419pxTaskGetStackStart12TaskHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the start of the stack associated with xTask.</p>
<p>INCLUDE_pxTaskGetStackStart must be set to 1 in FreeRTOSConfig.h for this function to be available.</p>
<p>Returns the highest stack memory address on architectures where the stack grows down from high memory, and the lowest memory address on architectures where the stack grows up from low memory.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A pointer to the start of the stack. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTask</span></code>: Handle of the task associated with the stack returned. Set xTask to NULL to return the stack of the calling task.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426vTaskSetApplicationTaskTag12TaskHandle_t18TaskHookFunction_t">
<span id="_CPPv326vTaskSetApplicationTaskTag12TaskHandle_t18TaskHookFunction_t"></span><span id="_CPPv226vTaskSetApplicationTaskTag12TaskHandle_t18TaskHookFunction_t"></span><span id="vTaskSetApplicationTaskTag__TaskHandle_t.TaskHookFunction_t"></span><span class="target" id="task_8h_1a179295989890733e4f049eacb5114443"></span>void <code class="descname">vTaskSetApplicationTaskTag</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTask</em>, <a class="reference internal" href="#_CPPv418TaskHookFunction_t" title="TaskHookFunction_t">TaskHookFunction_t</a> <em>pxHookFunction</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426vTaskSetApplicationTaskTag12TaskHandle_t18TaskHookFunction_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets pxHookFunction to be the task hook function used by the task xTask. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTask</span></code>: Handle of the task to set the hook function for Passing xTask as NULL has the effect of setting the calling tasks hook function. </li>
<li><code class="docutils literal notranslate"><span class="pre">pxHookFunction</span></code>: Pointer to the hook function. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426xTaskGetApplicationTaskTag12TaskHandle_t">
<span id="_CPPv326xTaskGetApplicationTaskTag12TaskHandle_t"></span><span id="_CPPv226xTaskGetApplicationTaskTag12TaskHandle_t"></span><span id="xTaskGetApplicationTaskTag__TaskHandle_t"></span><span class="target" id="task_8h_1a990a40ecfe8059b0a8adbf8daa4512dd"></span><a class="reference internal" href="#_CPPv418TaskHookFunction_t" title="TaskHookFunction_t">TaskHookFunction_t</a> <code class="descname">xTaskGetApplicationTaskTag</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTask</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426xTaskGetApplicationTaskTag12TaskHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the hook function assigned to given task. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The pxHookFunction value assigned to the task xTask. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTask</span></code>: Handle of the task to get the hook function for Passing xTask as NULL has the effect of getting the calling tasks hook function. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv433vTaskSetThreadLocalStoragePointer12TaskHandle_t10BaseType_tPv">
<span id="_CPPv333vTaskSetThreadLocalStoragePointer12TaskHandle_t10BaseType_tPv"></span><span id="_CPPv233vTaskSetThreadLocalStoragePointer12TaskHandle_t10BaseType_tPv"></span><span id="vTaskSetThreadLocalStoragePointer__TaskHandle_t.BaseType_t.voidP"></span><span class="target" id="task_8h_1a33e663d3bab72a691d131e125503e59b"></span>void <code class="descname">vTaskSetThreadLocalStoragePointer</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToSet</em>, BaseType_t <em>xIndex</em>, void *<em>pvValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv433vTaskSetThreadLocalStoragePointer12TaskHandle_t10BaseType_tPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set local storage pointer specific to the given task.</p>
<p>Each task contains an array of pointers that is dimensioned by the configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h. The kernel does not use the pointers itself, so the application writer can use the pointers for any purpose they wish.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToSet</span></code>: Task to set thread local storage pointer for </li>
<li><code class="docutils literal notranslate"><span class="pre">xIndex</span></code>: The index of the pointer to set, from 0 to configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1. </li>
<li><code class="docutils literal notranslate"><span class="pre">pvValue</span></code>: Pointer value to set. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv434pvTaskGetThreadLocalStoragePointer12TaskHandle_t10BaseType_t">
<span id="_CPPv334pvTaskGetThreadLocalStoragePointer12TaskHandle_t10BaseType_t"></span><span id="_CPPv234pvTaskGetThreadLocalStoragePointer12TaskHandle_t10BaseType_t"></span><span id="pvTaskGetThreadLocalStoragePointer__TaskHandle_t.BaseType_t"></span><span class="target" id="task_8h_1a41c410d6ee9fbf9e882d1a2962f437e0"></span>void *<code class="descname">pvTaskGetThreadLocalStoragePointer</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToQuery</em>, BaseType_t <em>xIndex</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv434pvTaskGetThreadLocalStoragePointer12TaskHandle_t10BaseType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get local storage pointer specific to the given task.</p>
<p>Each task contains an array of pointers that is dimensioned by the configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h. The kernel does not use the pointers itself, so the application writer can use the pointers for any purpose they wish.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Pointer value </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToQuery</span></code>: Task to get thread local storage pointer for </li>
<li><code class="docutils literal notranslate"><span class="pre">xIndex</span></code>: The index of the pointer to get, from 0 to configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv447vTaskSetThreadLocalStoragePointerAndDelCallback12TaskHandle_t10BaseType_tPv27TlsDeleteCallbackFunction_t">
<span id="_CPPv347vTaskSetThreadLocalStoragePointerAndDelCallback12TaskHandle_t10BaseType_tPv27TlsDeleteCallbackFunction_t"></span><span id="_CPPv247vTaskSetThreadLocalStoragePointerAndDelCallback12TaskHandle_t10BaseType_tPv27TlsDeleteCallbackFunction_t"></span><span id="vTaskSetThreadLocalStoragePointerAndDelCallback__TaskHandle_t.BaseType_t.voidP.TlsDeleteCallbackFunction_t"></span><span class="target" id="task_8h_1ae29bfc51bcf923b80f2d2598c3b51dcd"></span>void <code class="descname">vTaskSetThreadLocalStoragePointerAndDelCallback</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToSet</em>, BaseType_t <em>xIndex</em>, void *<em>pvValue</em>, <a class="reference internal" href="#_CPPv427TlsDeleteCallbackFunction_t" title="TlsDeleteCallbackFunction_t">TlsDeleteCallbackFunction_t</a> <em>pvDelCallback</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv447vTaskSetThreadLocalStoragePointerAndDelCallback12TaskHandle_t10BaseType_tPv27TlsDeleteCallbackFunction_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set local storage pointer and deletion callback.</p>
<p>Each task contains an array of pointers that is dimensioned by the configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h. The kernel does not use the pointers itself, so the application writer can use the pointers for any purpose they wish.</p>
<p>Local storage pointers set for a task can reference dynamically allocated resources. This function is similar to vTaskSetThreadLocalStoragePointer, but provides a way to release these resources when the task gets deleted. For each pointer, a callback function can be set. This function will be called when task is deleted, with the local storage pointer index and value as arguments.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToSet</span></code>: Task to set thread local storage pointer for </li>
<li><code class="docutils literal notranslate"><span class="pre">xIndex</span></code>: The index of the pointer to set, from 0 to configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1. </li>
<li><code class="docutils literal notranslate"><span class="pre">pvValue</span></code>: Pointer value to set. </li>
<li><code class="docutils literal notranslate"><span class="pre">pvDelCallback</span></code>: Function to call to dispose of the local storage pointer when the task is deleted. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv428xTaskCallApplicationTaskHook12TaskHandle_tPv">
<span id="_CPPv328xTaskCallApplicationTaskHook12TaskHandle_tPv"></span><span id="_CPPv228xTaskCallApplicationTaskHook12TaskHandle_tPv"></span><span id="xTaskCallApplicationTaskHook__TaskHandle_t.voidP"></span><span class="target" id="task_8h_1ab6607e5d8a9664e3aa9fe16efa694e83"></span>BaseType_t <code class="descname">xTaskCallApplicationTaskHook</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTask</em>, void *<em>pvParameter</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428xTaskCallApplicationTaskHook12TaskHandle_tPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Calls the hook function associated with xTask. Passing xTask as NULL has the effect of calling the Running tasks (the calling task) hook function.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTask</span></code>: Handle of the task to call the hook for. </li>
<li><code class="docutils literal notranslate"><span class="pre">pvParameter</span></code>: Parameter passed to the hook function for the task to interpret as it wants. The return value is the value returned by the task hook function registered by the user. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422xTaskGetIdleTaskHandlev">
<span id="_CPPv322xTaskGetIdleTaskHandlev"></span><span id="_CPPv222xTaskGetIdleTaskHandlev"></span><span id="xTaskGetIdleTaskHandle__void"></span><span class="target" id="task_8h_1a38e3c3df6fc5b28c14459e32474917fb"></span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <code class="descname">xTaskGetIdleTaskHandle</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422xTaskGetIdleTaskHandlev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the handle of idle task for the current CPU.</p>
<p>xTaskGetIdleTaskHandle() is only available if INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The handle of the idle task. It is not valid to call xTaskGetIdleTaskHandle() before the scheduler has been started. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv428xTaskGetIdleTaskHandleForCPU11UBaseType_t">
<span id="_CPPv328xTaskGetIdleTaskHandleForCPU11UBaseType_t"></span><span id="_CPPv228xTaskGetIdleTaskHandleForCPU11UBaseType_t"></span><span id="xTaskGetIdleTaskHandleForCPU__UBaseType_t"></span><span class="target" id="task_8h_1a9cc9b6611e5b3d64ab32d6e07651ae9b"></span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <code class="descname">xTaskGetIdleTaskHandleForCPU</code><span class="sig-paren">(</span>UBaseType_t <em>cpuid</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428xTaskGetIdleTaskHandleForCPU11UBaseType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the handle of idle task for the given CPU.</p>
<p>xTaskGetIdleTaskHandleForCPU() is only available if INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Idle task handle of a given cpu. It is not valid to call xTaskGetIdleTaskHandleForCPU() before the scheduler has been started. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">cpuid</span></code>: The CPU to get the handle for</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420uxTaskGetSystemStatePC12TaskStatus_tK11UBaseType_tPC8uint32_t">
<span id="_CPPv320uxTaskGetSystemStatePC12TaskStatus_tK11UBaseType_tPC8uint32_t"></span><span id="_CPPv220uxTaskGetSystemStatePC12TaskStatus_tK11UBaseType_tPC8uint32_t"></span><span id="uxTaskGetSystemState__TaskStatus_tPC.UBaseType_tC.uint32_tPC"></span><span class="target" id="task_8h_1a5bd92b080086390cae790e5bd74bd018"></span>UBaseType_t <code class="descname">uxTaskGetSystemState</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskStatus_t" title="TaskStatus_t">TaskStatus_t</a> *<em class="property">const</em> <em>pxTaskStatusArray</em>, <em class="property">const</em> UBaseType_t <em>uxArraySize</em>, uint32_t *<em class="property">const</em> <em>pulTotalRunTime</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420uxTaskGetSystemStatePC12TaskStatus_tK11UBaseType_tPC8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the state of tasks in the system.</p>
<p>configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for uxTaskGetSystemState() to be available.</p>
<p>uxTaskGetSystemState() populates an TaskStatus_t structure for each task in the system. TaskStatus_t structures contain, among other things, members for the task handle, task name, task priority, task state, and total amount of run time consumed by the task. See the TaskStatus_t structure definition in this file for the full member list.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// This example demonstrates how a human readable table of run time stats
// information is generated from raw data provided by uxTaskGetSystemState().
// The human readable table is written to pcWriteBuffer
void vTaskGetRunTimeStats( char *pcWriteBuffer )
{
TaskStatus_t *pxTaskStatusArray;
volatile UBaseType_t uxArraySize, x;
uint32_t ulTotalRunTime, ulStatsAsPercentage;

 // Make sure the write buffer does not contain a string.
 *pcWriteBuffer = 0x00;

 // Take a snapshot of the number of tasks in case it changes while this
 // function is executing.
 uxArraySize = uxTaskGetNumberOfTasks();

 // Allocate a TaskStatus_t structure for each task.  An array could be
 // allocated statically at compile time.
 pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );

 if( pxTaskStatusArray != NULL )
 {
     // Generate raw status information about each task.
     uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &amp;ulTotalRunTime );

     // For percentage calculations.
     ulTotalRunTime /= 100UL;

     // Avoid divide by zero errors.
     if( ulTotalRunTime &gt; 0 )
     {
         // For each populated position in the pxTaskStatusArray array,
         // format the raw data as human readable ASCII data
         for( x = 0; x &lt; uxArraySize; x++ )
         {
             // What percentage of the total run time has the task used?
             // This will always be rounded down to the nearest integer.
             // ulTotalRunTimeDiv100 has already been divided by 100.
             ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;

             if( ulStatsAsPercentage &gt; 0UL )
             {
                 sprintf( pcWriteBuffer, &quot;%s\t\t%lu\t\t%lu%%\r\n&quot;, pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
             }
             else
             {
                 // If the percentage is zero here then the task has
                 // consumed less than 1% of the total run time.
                 sprintf( pcWriteBuffer, &quot;%s\t\t%lu\t\t&lt;1%%\r\n&quot;, pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
             }

             pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
         }
     }

     // The array is no longer needed, free the memory it consumes.
     vPortFree( pxTaskStatusArray );
 }
}
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is intended for debugging use only as its use results in the scheduler remaining suspended for an extended period.</dd>
<dt><strong>Return</strong></dt>
<dd>The number of TaskStatus_t structures that were populated by uxTaskGetSystemState(). This should equal the number returned by the uxTaskGetNumberOfTasks() API function, but will be zero if the value passed in the uxArraySize parameter was too small.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pxTaskStatusArray</span></code>: A pointer to an array of TaskStatus_t structures. The array must contain at least one TaskStatus_t structure for each task that is under the control of the RTOS. The number of tasks under the control of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxArraySize</span></code>: The size of the array pointed to by the pxTaskStatusArray parameter. The size is specified as the number of indexes in the array, or the number of TaskStatus_t structures contained in the array, not by the number of bytes in the array.</li>
<li><code class="docutils literal notranslate"><span class="pre">pulTotalRunTime</span></code>: If configGENERATE_RUN_TIME_STATS is set to 1 in FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the total run time (as defined by the run time stats clock, see <a class="reference external" href="http://www.freertos.org/rtos-run-time-stats.html">http://www.freertos.org/rtos-run-time-stats.html</a>) since the target booted. pulTotalRunTime can be set to NULL to omit the total run time information.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49vTaskListPc">
<span id="_CPPv39vTaskListPc"></span><span id="_CPPv29vTaskListPc"></span><span id="vTaskList__cP"></span><span class="target" id="task_8h_1ab87abc717f34ddced76802d12588a93d"></span>void <code class="descname">vTaskList</code><span class="sig-paren">(</span>char *<em>pcWriteBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49vTaskListPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List all the current tasks.</p>
<p>configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must both be defined as 1 for this function to be available. See the configuration section of the FreeRTOS.org website for more information.</p>
<p><p>Lists all the current tasks, along with their current state and stack usage high water mark.</p>
<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function will disable interrupts for its duration. It is not intended for normal application runtime use but as a debug aid.</dd>
</dl>
</p>
<p>Tasks are reported as blocked (‘B’), ready (‘R’), deleted (‘D’) or suspended (‘S’).</p>
<p><p>vTaskList() calls uxTaskGetSystemState(), then formats part of the uxTaskGetSystemState() output into a human readable table that displays task names, states and stack usage.</p>
<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is provided for convenience only, and is used by many of the demo applications. Do not consider it to be part of the scheduler.</dd>
</dl>
</p>
<p>vTaskList() has a dependency on the sprintf() C library function that might bloat the code size, use a lot of stack, and provide different results on different platforms. An alternative, tiny, third party, and limited functionality implementation of sprintf() is provided in many of the FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note printf-stdarg.c does not provide a full snprintf() implementation!).</p>
<p>It is recommended that production systems call uxTaskGetSystemState() directly to get access to raw stats data, rather than indirectly through a call to vTaskList().</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pcWriteBuffer</span></code>: A buffer into which the above mentioned details will be written, in ASCII form. This buffer is assumed to be large enough to contain the generated report. Approximately 40 bytes per task should be sufficient. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420vTaskGetRunTimeStatsPc">
<span id="_CPPv320vTaskGetRunTimeStatsPc"></span><span id="_CPPv220vTaskGetRunTimeStatsPc"></span><span id="vTaskGetRunTimeStats__cP"></span><span class="target" id="task_8h_1a52da9b427041a48dc9f6802e10f151d4"></span>void <code class="descname">vTaskGetRunTimeStats</code><span class="sig-paren">(</span>char *<em>pcWriteBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420vTaskGetRunTimeStatsPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the state of running tasks as a string</p>
<p>configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS must both be defined as 1 for this function to be available. The application must also then provide definitions for portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE() to configure a peripheral timer/counter and return the timers current count value respectively. The counter should be at least 10 times the frequency of the tick count.</p>
<p><p>Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total accumulated execution time being stored for each task. The resolution of the accumulated time value depends on the frequency of the timer configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro. Calling vTaskGetRunTimeStats() writes the total execution time of each task into a buffer, both as an absolute count value and as a percentage of the total system execution time.</p>
<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function will disable interrupts for its duration. It is not intended for normal application runtime use but as a debug aid.</dd>
</dl>
</p>
<p><p>vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the uxTaskGetSystemState() output into a human readable table that displays the amount of time each task has spent in the Running state in both absolute and percentage terms.</p>
<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is provided for convenience only, and is used by many of the demo applications. Do not consider it to be part of the scheduler.</dd>
</dl>
</p>
<p>vTaskGetRunTimeStats() has a dependency on the sprintf() C library function that might bloat the code size, use a lot of stack, and provide different results on different platforms. An alternative, tiny, third party, and limited functionality implementation of sprintf() is provided in many of the FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note printf-stdarg.c does not provide a full snprintf() implementation!).</p>
<p>It is recommended that production systems call uxTaskGetSystemState() directly to get access to raw stats data, rather than indirectly through a call to vTaskGetRunTimeStats().</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pcWriteBuffer</span></code>: A buffer into which the execution times will be written, in ASCII form. This buffer is assumed to be large enough to contain the generated report. Approximately 40 bytes per task should be sufficient. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411xTaskNotify12TaskHandle_t8uint32_t13eNotifyAction">
<span id="_CPPv311xTaskNotify12TaskHandle_t8uint32_t13eNotifyAction"></span><span id="_CPPv211xTaskNotify12TaskHandle_t8uint32_t13eNotifyAction"></span><span id="xTaskNotify__TaskHandle_t.uint32_t.eNotifyAction"></span><span class="target" id="task_8h_1af765b8c28d01be648c56efe92d544b44"></span>BaseType_t <code class="descname">xTaskNotify</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToNotify</em>, uint32_t <em>ulValue</em>, <a class="reference internal" href="#_CPPv413eNotifyAction" title="eNotifyAction">eNotifyAction</a> <em>eAction</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411xTaskNotify12TaskHandle_t8uint32_t13eNotifyAction" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Send task notification.</p>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this function to be available.</p>
<p>When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private “notification value”, which is a 32-bit unsigned integer (uint32_t).</p>
<p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p>
<p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment the task’s notification value. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p>
<p>A notification sent to a task will remain pending until it is cleared by the task calling xTaskNotifyWait() or ulTaskNotifyTake(). If the task was already in the Blocked state to wait for a notification when the notification arrives then the task will automatically be removed from the Blocked state (unblocked) and the notification cleared.</p>
<p>A task can use xTaskNotifyWait() to [optionally] block to wait for a notification to be pending, or ulTaskNotifyTake() to [optionally] block to wait for its notification value to have a non-zero value. The task does not consume any CPU time while it is in the Blocked state.</p>
<p>See <a class="reference external" href="http://www.freertos.org/RTOS-task-notifications.html">http://www.FreeRTOS.org/RTOS-task-notifications.html</a> for details.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Dependent on the value of eAction. See the description of the eAction parameter. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToNotify</span></code>: The handle of the task being notified. The handle to a task can be returned from the xTaskCreate() API function used to create the task, and the handle of the currently running task can be obtained by calling xTaskGetCurrentTaskHandle().</li>
<li><code class="docutils literal notranslate"><span class="pre">ulValue</span></code>: Data that can be sent with the notification. How the data is used depends on the value of the eAction parameter.</li>
<li><code class="docutils literal notranslate"><span class="pre">eAction</span></code>: Specifies how the notification updates the task’s notification value, if at all. Valid values for eAction are as follows:<ul>
<li>eSetBits: The task’s notification value is bitwise ORed with ulValue. xTaskNofify() always returns pdPASS in this case.</li>
<li>eIncrement: The task’s notification value is incremented. ulValue is not used and xTaskNotify() always returns pdPASS in this case.</li>
<li>eSetValueWithOverwrite: The task’s notification value is set to the value of ulValue, even if the task being notified had not yet processed the previous notification (the task already had a notification pending). xTaskNotify() always returns pdPASS in this case.</li>
<li>eSetValueWithoutOverwrite: If the task being notified did not already have a notification pending then the task’s notification value is set to ulValue and xTaskNotify() will return pdPASS. If the task being notified already had a notification pending then no action is performed and pdFAIL is returned.</li>
<li>eNoAction: The task receives a notification without its notification value being &nbsp;&nbsp;updated. ulValue is not used and xTaskNotify() always returns pdPASS in this case.</li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418xTaskNotifyFromISR12TaskHandle_t8uint32_t13eNotifyActionP10BaseType_t">
<span id="_CPPv318xTaskNotifyFromISR12TaskHandle_t8uint32_t13eNotifyActionP10BaseType_t"></span><span id="_CPPv218xTaskNotifyFromISR12TaskHandle_t8uint32_t13eNotifyActionP10BaseType_t"></span><span id="xTaskNotifyFromISR__TaskHandle_t.uint32_t.eNotifyAction.BaseType_tP"></span><span class="target" id="task_8h_1a2c7892a9835d67e7b080eddafc6ce0e7"></span>BaseType_t <code class="descname">xTaskNotifyFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToNotify</em>, uint32_t <em>ulValue</em>, <a class="reference internal" href="#_CPPv413eNotifyAction" title="eNotifyAction">eNotifyAction</a> <em>eAction</em>, BaseType_t *<em>pxHigherPriorityTaskWoken</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418xTaskNotifyFromISR12TaskHandle_t8uint32_t13eNotifyActionP10BaseType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Send task notification from an ISR.</p>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this function to be available.</p>
<p>When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private “notification value”, which is a 32-bit unsigned integer (uint32_t).</p>
<p>A version of xTaskNotify() that can be used from an interrupt service routine (ISR).</p>
<p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p>
<p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment the task’s notification value. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p>
<p>A notification sent to a task will remain pending until it is cleared by the task calling xTaskNotifyWait() or ulTaskNotifyTake(). If the task was already in the Blocked state to wait for a notification when the notification arrives then the task will automatically be removed from the Blocked state (unblocked) and the notification cleared.</p>
<p>A task can use xTaskNotifyWait() to [optionally] block to wait for a notification to be pending, or ulTaskNotifyTake() to [optionally] block to wait for its notification value to have a non-zero value. The task does not consume any CPU time while it is in the Blocked state.</p>
<p>See <a class="reference external" href="http://www.freertos.org/RTOS-task-notifications.html">http://www.FreeRTOS.org/RTOS-task-notifications.html</a> for details.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Dependent on the value of eAction. See the description of the eAction parameter. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToNotify</span></code>: The handle of the task being notified. The handle to a task can be returned from the xTaskCreate() API function used to create the task, and the handle of the currently running task can be obtained by calling xTaskGetCurrentTaskHandle().</li>
<li><code class="docutils literal notranslate"><span class="pre">ulValue</span></code>: Data that can be sent with the notification. How the data is used depends on the value of the eAction parameter.</li>
<li><code class="docutils literal notranslate"><span class="pre">eAction</span></code>: Specifies how the notification updates the task’s notification value, if at all. Valid values for eAction are as follows:<ul>
<li>eSetBits: The task’s notification value is bitwise ORed with ulValue. xTaskNofify() always returns pdPASS in this case.</li>
<li>eIncrement: The task’s notification value is incremented. ulValue is not used and xTaskNotify() always returns pdPASS in this case.</li>
<li>eSetValueWithOverwrite: The task’s notification value is set to the value of ulValue, even if the task being notified had not yet processed the previous notification (the task already had a notification pending). xTaskNotify() always returns pdPASS in this case.</li>
<li>eSetValueWithoutOverwrite: If the task being notified did not already have a notification pending then the task’s notification value is set to ulValue and xTaskNotify() will return pdPASS. If the task being notified already had a notification pending then no action is performed and pdFAIL is returned.</li>
<li>eNoAction: The task receives a notification without its notification value being updated. ulValue is not used and xTaskNotify() always returns pdPASS in this case.</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>: xTaskNotifyFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the task to which the notification was sent to leave the Blocked state, and the unblocked task has a priority higher than the currently running task. If xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited. How a context switch is requested from an ISR is dependent on the port - see the documentation page for the port in use.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415xTaskNotifyWait8uint32_t8uint32_tP8uint32_t10TickType_t">
<span id="_CPPv315xTaskNotifyWait8uint32_t8uint32_tP8uint32_t10TickType_t"></span><span id="_CPPv215xTaskNotifyWait8uint32_t8uint32_tP8uint32_t10TickType_t"></span><span id="xTaskNotifyWait__uint32_t.uint32_t.uint32_tP.TickType_t"></span><span class="target" id="task_8h_1a7cab914767933dc732f2c36e3915f6b0"></span>BaseType_t <code class="descname">xTaskNotifyWait</code><span class="sig-paren">(</span>uint32_t <em>ulBitsToClearOnEntry</em>, uint32_t <em>ulBitsToClearOnExit</em>, uint32_t *<em>pulNotificationValue</em>, TickType_t <em>xTicksToWait</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415xTaskNotifyWait8uint32_t8uint32_tP8uint32_t10TickType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait for task notification</p>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this function to be available.</p>
<p>When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private “notification value”, which is a 32-bit unsigned integer (uint32_t).</p>
<p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p>
<p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment the task’s notification value. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p>
<p>A notification sent to a task will remain pending until it is cleared by the task calling xTaskNotifyWait() or ulTaskNotifyTake(). If the task was already in the Blocked state to wait for a notification when the notification arrives then the task will automatically be removed from the Blocked state (unblocked) and the notification cleared.</p>
<p>A task can use xTaskNotifyWait() to [optionally] block to wait for a notification to be pending, or ulTaskNotifyTake() to [optionally] block to wait for its notification value to have a non-zero value. The task does not consume any CPU time while it is in the Blocked state.</p>
<p>See <a class="reference external" href="http://www.freertos.org/RTOS-task-notifications.html">http://www.FreeRTOS.org/RTOS-task-notifications.html</a> for details.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If a notification was received (including notifications that were already pending when xTaskNotifyWait was called) then pdPASS is returned. Otherwise pdFAIL is returned. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ulBitsToClearOnEntry</span></code>: Bits that are set in ulBitsToClearOnEntry value will be cleared in the calling task’s notification value before the task checks to see if any notifications are pending, and optionally blocks if no notifications are pending. Setting ulBitsToClearOnEntry to ULONG_MAX (if limits.h is included) or 0xffffffffUL (if limits.h is not included) will have the effect of resetting the task’s notification value to 0. Setting ulBitsToClearOnEntry to 0 will leave the task’s notification value unchanged.</li>
<li><code class="docutils literal notranslate"><span class="pre">ulBitsToClearOnExit</span></code>: If a notification is pending or received before the calling task exits the xTaskNotifyWait() function then the task’s notification value (see the xTaskNotify() API function) is passed out using the pulNotificationValue parameter. Then any bits that are set in ulBitsToClearOnExit will be cleared in the task’s notification value (note *pulNotificationValue is set before any bits are cleared). Setting ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL (if limits.h is not included) will have the effect of resetting the task’s notification value to 0 before the function exits. Setting ulBitsToClearOnExit to 0 will leave the task’s notification value unchanged when the function exits (in which case the value passed out in pulNotificationValue will match the task’s notification value).</li>
<li><code class="docutils literal notranslate"><span class="pre">pulNotificationValue</span></code>: Used to pass the task’s notification value out of the function. Note the value passed out will not be effected by the clearing of any bits caused by ulBitsToClearOnExit being non-zero.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: The maximum amount of time that the task should wait in the Blocked state for a notification to be received, should a notification not already be pending when xTaskNotifyWait() was called. The task will not consume any processing time while it is in the Blocked state. This is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time specified in milliseconds to a time specified in ticks.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422vTaskNotifyGiveFromISR12TaskHandle_tP10BaseType_t">
<span id="_CPPv322vTaskNotifyGiveFromISR12TaskHandle_tP10BaseType_t"></span><span id="_CPPv222vTaskNotifyGiveFromISR12TaskHandle_tP10BaseType_t"></span><span id="vTaskNotifyGiveFromISR__TaskHandle_t.BaseType_tP"></span><span class="target" id="task_8h_1a0c31cb4be76285f05909de23ede05331"></span>void <code class="descname">vTaskNotifyGiveFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToNotify</em>, BaseType_t *<em>pxHigherPriorityTaskWoken</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422vTaskNotifyGiveFromISR12TaskHandle_tP10BaseType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Simplified macro for sending task notification from ISR.</p>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro to be available.</p>
<p>When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private “notification value”, which is a 32-bit unsigned integer (uint32_t).</p>
<p>A version of xTaskNotifyGive() that can be called from an interrupt service routine (ISR).</p>
<p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p>
<p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment the task’s notification value. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p>
<p>vTaskNotifyGiveFromISR() is intended for use when task notifications are used as light weight and faster binary or counting semaphore equivalents. Actual FreeRTOS semaphores are given from an ISR using the xSemaphoreGiveFromISR() API function, the equivalent action that instead uses a task notification is vTaskNotifyGiveFromISR().</p>
<p>When task notifications are being used as a binary or counting semaphore equivalent then the task being notified should wait for the notification using the ulTaskNotificationTake() API function rather than the xTaskNotifyWait() API function.</p>
<p>See <a class="reference external" href="http://www.freertos.org/RTOS-task-notifications.html">http://www.FreeRTOS.org/RTOS-task-notifications.html</a> for more details.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToNotify</span></code>: The handle of the task being notified. The handle to a task can be returned from the xTaskCreate() API function used to create the task, and the handle of the currently running task can be obtained by calling xTaskGetCurrentTaskHandle().</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>: vTaskNotifyGiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the task to which the notification was sent to leave the Blocked state, and the unblocked task has a priority higher than the currently running task. If vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited. How a context switch is requested from an ISR is dependent on the port - see the documentation page for the port in use. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416ulTaskNotifyTake10BaseType_t10TickType_t">
<span id="_CPPv316ulTaskNotifyTake10BaseType_t10TickType_t"></span><span id="_CPPv216ulTaskNotifyTake10BaseType_t10TickType_t"></span><span id="ulTaskNotifyTake__BaseType_t.TickType_t"></span><span class="target" id="task_8h_1a1dd29cf3d25f9968ac86b0ca35af8ada"></span>uint32_t <code class="descname">ulTaskNotifyTake</code><span class="sig-paren">(</span>BaseType_t <em>xClearCountOnExit</em>, TickType_t <em>xTicksToWait</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416ulTaskNotifyTake10BaseType_t10TickType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Simplified macro for receiving task notification.</p>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this function to be available.</p>
<p>When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private “notification value”, which is a 32-bit unsigned integer (uint32_t).</p>
<p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p>
<p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment the task’s notification value. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p>
<p>ulTaskNotifyTake() is intended for use when a task notification is used as a faster and lighter weight binary or counting semaphore alternative. Actual FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the equivalent action that instead uses a task notification is ulTaskNotifyTake().</p>
<p>When a task is using its notification value as a binary or counting semaphore other tasks should send notifications to it using the xTaskNotifyGive() macro, or xTaskNotify() function with the eAction parameter set to eIncrement.</p>
<p>ulTaskNotifyTake() can either clear the task’s notification value to zero on exit, in which case the notification value acts like a binary semaphore, or decrement the task’s notification value on exit, in which case the notification value acts like a counting semaphore.</p>
<p>A task can use ulTaskNotifyTake() to [optionally] block to wait for a the task’s notification value to be non-zero. The task does not consume any CPU time while it is in the Blocked state.</p>
<p>Where as xTaskNotifyWait() will return when a notification is pending, ulTaskNotifyTake() will return when the task’s notification value is not zero.</p>
<p>See <a class="reference external" href="http://www.freertos.org/RTOS-task-notifications.html">http://www.FreeRTOS.org/RTOS-task-notifications.html</a> for details.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The task’s notification count before it is either cleared to zero or decremented (see the xClearCountOnExit parameter). </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xClearCountOnExit</span></code>: if xClearCountOnExit is pdFALSE then the task’s notification value is decremented when the function exits. In this way the notification value acts like a counting semaphore. If xClearCountOnExit is not pdFALSE then the task’s notification value is cleared to zero when the function exits. In this way the notification value acts like a binary semaphore.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: The maximum amount of time that the task should wait in the Blocked state for the task’s notification value to be greater than zero, should the count not already be greater than zero when ulTaskNotifyTake() was called. The task will not consume any processing time while it is in the Blocked state. This is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time specified in milliseconds to a time specified in ticks.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="structures">
<h3>Structures<a class="headerlink" href="#structures" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv412xTASK_STATUS">
<span id="_CPPv312xTASK_STATUS"></span><span id="_CPPv212xTASK_STATUS"></span><span id="xTASK_STATUS"></span><span class="target" id="structxTASK__STATUS"></span><em class="property">struct </em><code class="descname">xTASK_STATUS</code><a class="headerlink" href="#_CPPv412xTASK_STATUS" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Used with the uxTaskGetSystemState() function to return the state of each task in the system. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS7xHandleE">
<span id="_CPPv3N12xTASK_STATUS7xHandleE"></span><span id="_CPPv2N12xTASK_STATUS7xHandleE"></span><span id="xTASK_STATUS::xHandle__TaskHandle_t"></span><span class="target" id="structxTASK__STATUS_1ac57f825f365c3c64bba827285fe3c2a0"></span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <code class="descname">xHandle</code><a class="headerlink" href="#_CPPv4N12xTASK_STATUS7xHandleE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The handle of the task to which the rest of the information in the structure relates. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS10pcTaskNameE">
<span id="_CPPv3N12xTASK_STATUS10pcTaskNameE"></span><span id="_CPPv2N12xTASK_STATUS10pcTaskNameE"></span><span id="xTASK_STATUS::pcTaskName__cCP"></span><span class="target" id="structxTASK__STATUS_1ad272663e2560bd9ea088384a39ba6192"></span><em class="property">const</em> char *<code class="descname">pcTaskName</code><a class="headerlink" href="#_CPPv4N12xTASK_STATUS10pcTaskNameE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A pointer to the task’s name. This value will be invalid if the task was deleted since the structure was populated! </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS11xTaskNumberE">
<span id="_CPPv3N12xTASK_STATUS11xTaskNumberE"></span><span id="_CPPv2N12xTASK_STATUS11xTaskNumberE"></span><span id="xTASK_STATUS::xTaskNumber__UBaseType_t"></span><span class="target" id="structxTASK__STATUS_1acd44468ba37270b04f83d0833c098057"></span>UBaseType_t <code class="descname">xTaskNumber</code><a class="headerlink" href="#_CPPv4N12xTASK_STATUS11xTaskNumberE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A number unique to the task. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS13eCurrentStateE">
<span id="_CPPv3N12xTASK_STATUS13eCurrentStateE"></span><span id="_CPPv2N12xTASK_STATUS13eCurrentStateE"></span><span id="xTASK_STATUS::eCurrentState__eTaskState"></span><span class="target" id="structxTASK__STATUS_1a727e904e3afe49472b0fc6a4e96439cb"></span><a class="reference internal" href="#_CPPv410eTaskState" title="eTaskState">eTaskState</a> <code class="descname">eCurrentState</code><a class="headerlink" href="#_CPPv4N12xTASK_STATUS13eCurrentStateE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The state in which the task existed when the structure was populated. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS17uxCurrentPriorityE">
<span id="_CPPv3N12xTASK_STATUS17uxCurrentPriorityE"></span><span id="_CPPv2N12xTASK_STATUS17uxCurrentPriorityE"></span><span id="xTASK_STATUS::uxCurrentPriority__UBaseType_t"></span><span class="target" id="structxTASK__STATUS_1a39df647234fc0d6de5852042a2741a94"></span>UBaseType_t <code class="descname">uxCurrentPriority</code><a class="headerlink" href="#_CPPv4N12xTASK_STATUS17uxCurrentPriorityE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The priority at which the task was running (may be inherited) when the structure was populated. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS14uxBasePriorityE">
<span id="_CPPv3N12xTASK_STATUS14uxBasePriorityE"></span><span id="_CPPv2N12xTASK_STATUS14uxBasePriorityE"></span><span id="xTASK_STATUS::uxBasePriority__UBaseType_t"></span><span class="target" id="structxTASK__STATUS_1a692f4c8957b7270f1579cdee63ff287e"></span>UBaseType_t <code class="descname">uxBasePriority</code><a class="headerlink" href="#_CPPv4N12xTASK_STATUS14uxBasePriorityE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The priority to which the task will return if the task’s current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex. Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS16ulRunTimeCounterE">
<span id="_CPPv3N12xTASK_STATUS16ulRunTimeCounterE"></span><span id="_CPPv2N12xTASK_STATUS16ulRunTimeCounterE"></span><span id="xTASK_STATUS::ulRunTimeCounter__uint32_t"></span><span class="target" id="structxTASK__STATUS_1a92ab83f4f376c255dedf8e06a78261f7"></span>uint32_t <code class="descname">ulRunTimeCounter</code><a class="headerlink" href="#_CPPv4N12xTASK_STATUS16ulRunTimeCounterE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The total run time allocated to the task so far, as defined by the run time stats clock. See <a class="reference external" href="http://www.freertos.org/rtos-run-time-stats.html">http://www.freertos.org/rtos-run-time-stats.html</a>. Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS11pxStackBaseE">
<span id="_CPPv3N12xTASK_STATUS11pxStackBaseE"></span><span id="_CPPv2N12xTASK_STATUS11pxStackBaseE"></span><span id="xTASK_STATUS::pxStackBase__StackType_tP"></span><span class="target" id="structxTASK__STATUS_1a0ee59674d2cc57d3a5a29c777d5452ed"></span>StackType_t *<code class="descname">pxStackBase</code><a class="headerlink" href="#_CPPv4N12xTASK_STATUS11pxStackBaseE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Points to the lowest address of the task’s stack area. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS20usStackHighWaterMarkE">
<span id="_CPPv3N12xTASK_STATUS20usStackHighWaterMarkE"></span><span id="_CPPv2N12xTASK_STATUS20usStackHighWaterMarkE"></span><span id="xTASK_STATUS::usStackHighWaterMark__uint32_t"></span><span class="target" id="structxTASK__STATUS_1a847c7fd0baf85d88586341a5a219538a"></span>uint32_t <code class="descname">usStackHighWaterMark</code><a class="headerlink" href="#_CPPv4N12xTASK_STATUS20usStackHighWaterMarkE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The minimum amount of stack space that has remained for the task since the task was created. The closer this value is to zero the closer the task has come to overflowing its stack. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS7xCoreIDE">
<span id="_CPPv3N12xTASK_STATUS7xCoreIDE"></span><span id="_CPPv2N12xTASK_STATUS7xCoreIDE"></span><span id="xTASK_STATUS::xCoreID__BaseType_t"></span><span class="target" id="structxTASK__STATUS_1a43dafa875f1490a8adfa4d588ead2f31"></span>BaseType_t <code class="descname">xCoreID</code><a class="headerlink" href="#_CPPv4N12xTASK_STATUS7xCoreIDE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Core this task is pinned to (0, 1, or -1 for tskNO_AFFINITY). This field is present if CONFIG_FREERTOS_VTASKLIST_INCLUDE_COREID is set. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv414xTASK_SNAPSHOT">
<span id="_CPPv314xTASK_SNAPSHOT"></span><span id="_CPPv214xTASK_SNAPSHOT"></span><span id="xTASK_SNAPSHOT"></span><span class="target" id="structxTASK__SNAPSHOT"></span><em class="property">struct </em><code class="descname">xTASK_SNAPSHOT</code><a class="headerlink" href="#_CPPv414xTASK_SNAPSHOT" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Used with the uxTaskGetSnapshotAll() function to save memory snapshot of each task in the system. We need this struct because TCB_t is defined (hidden) in tasks.c. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N14xTASK_SNAPSHOT5pxTCBE">
<span id="_CPPv3N14xTASK_SNAPSHOT5pxTCBE"></span><span id="_CPPv2N14xTASK_SNAPSHOT5pxTCBE"></span><span id="xTASK_SNAPSHOT::pxTCB__voidP"></span><span class="target" id="structxTASK__SNAPSHOT_1ae2941ec1a55d5f8ffb31b85a1a7c4503"></span>void *<code class="descname">pxTCB</code><a class="headerlink" href="#_CPPv4N14xTASK_SNAPSHOT5pxTCBE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Address of task control block. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N14xTASK_SNAPSHOT12pxTopOfStackE">
<span id="_CPPv3N14xTASK_SNAPSHOT12pxTopOfStackE"></span><span id="_CPPv2N14xTASK_SNAPSHOT12pxTopOfStackE"></span><span id="xTASK_SNAPSHOT::pxTopOfStack__StackType_tP"></span><span class="target" id="structxTASK__SNAPSHOT_1a731e2dd7cd18a09a340fd5590450b9da"></span>StackType_t *<code class="descname">pxTopOfStack</code><a class="headerlink" href="#_CPPv4N14xTASK_SNAPSHOT12pxTopOfStackE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Points to the location of the last item placed on the tasks stack. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N14xTASK_SNAPSHOT12pxEndOfStackE">
<span id="_CPPv3N14xTASK_SNAPSHOT12pxEndOfStackE"></span><span id="_CPPv2N14xTASK_SNAPSHOT12pxEndOfStackE"></span><span id="xTASK_SNAPSHOT::pxEndOfStack__StackType_tP"></span><span class="target" id="structxTASK__SNAPSHOT_1a47be43ea65d03d703016e854032a87bc"></span>StackType_t *<code class="descname">pxEndOfStack</code><a class="headerlink" href="#_CPPv4N14xTASK_SNAPSHOT12pxEndOfStackE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Points to the end of the stack. pxTopOfStack &lt; pxEndOfStack, stack grows hi2lo pxTopOfStack &gt; pxEndOfStack, stack grows lo2hi </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="macros">
<h3>Macros<a class="headerlink" href="#macros" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.tskKERNEL_VERSION_NUMBER">
<span class="target" id="task_8h_1a3de6ae5641d96a68aa027673b6588016"></span><code class="descname">tskKERNEL_VERSION_NUMBER</code><a class="headerlink" href="#c.tskKERNEL_VERSION_NUMBER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.tskKERNEL_VERSION_MAJOR">
<span class="target" id="task_8h_1a790e0e16f79e71d4791435a31d5b0fc7"></span><code class="descname">tskKERNEL_VERSION_MAJOR</code><a class="headerlink" href="#c.tskKERNEL_VERSION_MAJOR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.tskKERNEL_VERSION_MINOR">
<span class="target" id="task_8h_1ab0b5ab04d8419227d0a5ac94af6b3639"></span><code class="descname">tskKERNEL_VERSION_MINOR</code><a class="headerlink" href="#c.tskKERNEL_VERSION_MINOR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.tskKERNEL_VERSION_BUILD">
<span class="target" id="task_8h_1a4cb001d5c86f4a8a5272f27227eb3247"></span><code class="descname">tskKERNEL_VERSION_BUILD</code><a class="headerlink" href="#c.tskKERNEL_VERSION_BUILD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.tskNO_AFFINITY">
<span class="target" id="task_8h_1aaef304a55bdc7162666e9bedcf9182a3"></span><code class="descname">tskNO_AFFINITY</code><a class="headerlink" href="#c.tskNO_AFFINITY" title="Permalink to this definition">¶</a></dt>
<dd><p>Argument of xTaskCreatePinnedToCore indicating that task has no affinity. </p>
</dd></dl>

<dl class="macro">
<dt id="c.tskIDLE_PRIORITY">
<span class="target" id="task_8h_1a94ed0b9b3b4e8ccc859c322f18583e67"></span><code class="descname">tskIDLE_PRIORITY</code><a class="headerlink" href="#c.tskIDLE_PRIORITY" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the priority used by the idle task. This must not be modified. </p>
</dd></dl>

<dl class="macro">
<dt id="c.taskYIELD">
<span class="target" id="task_8h_1a767e474430db1e60056e9678763f9202"></span><code class="descname">taskYIELD</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.taskYIELD" title="Permalink to this definition">¶</a></dt>
<dd><p>task. h</p>
<p>Macro for forcing a context switch. </p>
</dd></dl>

<dl class="macro">
<dt id="c.taskENTER_CRITICAL">
<span class="target" id="task_8h_1ad090b3b8b3d5ae61316bfacc9fcdae30"></span><code class="descname">taskENTER_CRITICAL</code><span class="sig-paren">(</span>mux<span class="sig-paren">)</span><a class="headerlink" href="#c.taskENTER_CRITICAL" title="Permalink to this definition">¶</a></dt>
<dd><p>task. h</p>
<p>Macro to mark the start of a critical code region. Preemptive context switches cannot occur when in a critical region.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This may alter the stack (depending on the portable implementation) so must be used with care! </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.taskENTER_CRITICAL_ISR">
<span class="target" id="task_8h_1adc0bf2970bce64b6b53b67d843530038"></span><code class="descname">taskENTER_CRITICAL_ISR</code><span class="sig-paren">(</span>mux<span class="sig-paren">)</span><a class="headerlink" href="#c.taskENTER_CRITICAL_ISR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.taskEXIT_CRITICAL">
<span class="target" id="task_8h_1af092583ebd99ba0823e432c02a7923b4"></span><code class="descname">taskEXIT_CRITICAL</code><span class="sig-paren">(</span>mux<span class="sig-paren">)</span><a class="headerlink" href="#c.taskEXIT_CRITICAL" title="Permalink to this definition">¶</a></dt>
<dd><p>task. h</p>
<p>Macro to mark the end of a critical code region. Preemptive context switches cannot occur when in a critical region.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This may alter the stack (depending on the portable implementation) so must be used with care! </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.taskEXIT_CRITICAL_ISR">
<span class="target" id="task_8h_1a616d3e63657279faa06fe6d935555b6a"></span><code class="descname">taskEXIT_CRITICAL_ISR</code><span class="sig-paren">(</span>mux<span class="sig-paren">)</span><a class="headerlink" href="#c.taskEXIT_CRITICAL_ISR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.taskDISABLE_INTERRUPTS">
<span class="target" id="task_8h_1aa455a648c2224964ee57758b8794198e"></span><code class="descname">taskDISABLE_INTERRUPTS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.taskDISABLE_INTERRUPTS" title="Permalink to this definition">¶</a></dt>
<dd><p>task. h</p>
<p>Macro to disable all maskable interrupts. </p>
</dd></dl>

<dl class="macro">
<dt id="c.taskENABLE_INTERRUPTS">
<span class="target" id="task_8h_1a04361ba499e91eb35324e4cba6feea17"></span><code class="descname">taskENABLE_INTERRUPTS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.taskENABLE_INTERRUPTS" title="Permalink to this definition">¶</a></dt>
<dd><p>task. h</p>
<p>Macro to enable microcontroller interrupts. </p>
</dd></dl>

<dl class="macro">
<dt id="c.taskSCHEDULER_SUSPENDED">
<span class="target" id="task_8h_1a0cad071ca127a35df93166e9ed5b6ada"></span><code class="descname">taskSCHEDULER_SUSPENDED</code><a class="headerlink" href="#c.taskSCHEDULER_SUSPENDED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.taskSCHEDULER_NOT_STARTED">
<span class="target" id="task_8h_1a0923fdaae1bfe42ac5cccd9e9ddca9ed"></span><code class="descname">taskSCHEDULER_NOT_STARTED</code><a class="headerlink" href="#c.taskSCHEDULER_NOT_STARTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.taskSCHEDULER_RUNNING">
<span class="target" id="task_8h_1acbb675035741787d29da475b5a887545"></span><code class="descname">taskSCHEDULER_RUNNING</code><a class="headerlink" href="#c.taskSCHEDULER_RUNNING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.xTaskNotifyGive">
<span class="target" id="task_8h_1ac60cbd05577a3e4f3c3587dd9b213930"></span><code class="descname">xTaskNotifyGive</code><span class="sig-paren">(</span>xTaskToNotify<span class="sig-paren">)</span><a class="headerlink" href="#c.xTaskNotifyGive" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplified macro for sending task notification.</p>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro to be available.</p>
<p>When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private “notification value”, which is a 32-bit unsigned integer (uint32_t).</p>
<p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p>
<p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment the task’s notification value. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p>
<p>xTaskNotifyGive() is a helper macro intended for use when task notifications are used as light weight and faster binary or counting semaphore equivalents. Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function, the equivalent action that instead uses a task notification is xTaskNotifyGive().</p>
<p>When task notifications are being used as a binary or counting semaphore equivalent then the task being notified should wait for the notification using the ulTaskNotificationTake() API function rather than the xTaskNotifyWait() API function.</p>
<p>See <a class="reference external" href="http://www.freertos.org/RTOS-task-notifications.html">http://www.FreeRTOS.org/RTOS-task-notifications.html</a> for more details.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>xTaskNotifyGive() is a macro that calls xTaskNotify() with the eAction parameter set to eIncrement - so pdPASS is always returned. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToNotify</span></code>: The handle of the task being notified. The handle to a task can be returned from the xTaskCreate() API function used to create the task, and the handle of the currently running task can be obtained by calling xTaskGetCurrentTaskHandle().</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="type-definitions">
<h3>Type Definitions<a class="headerlink" href="#type-definitions" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv412TaskHandle_t">
<span id="_CPPv312TaskHandle_t"></span><span id="_CPPv212TaskHandle_t"></span><span id="TaskHandle_t"></span><span class="target" id="task_8h_1ae95f44d4cfeb4a599c6cc258d241cb6b"></span><em class="property">typedef </em>void *<code class="descname">TaskHandle_t</code><a class="headerlink" href="#_CPPv412TaskHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>task. h</p>
<p>Type by which tasks are referenced. For example, a call to xTaskCreate returns (via a pointer parameter) an TaskHandle_t variable that can then be used as a parameter to vTaskDelete to delete the task. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv418TaskHookFunction_t">
<span id="_CPPv318TaskHookFunction_t"></span><span id="_CPPv218TaskHookFunction_t"></span><span id="TaskHookFunction_t"></span><span class="target" id="task_8h_1af984026250bf8fece2e0068874d4661d"></span><em class="property">typedef </em>BaseType_t (*<code class="descname">TaskHookFunction_t</code>)<span class="sig-paren">(</span>void *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418TaskHookFunction_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Defines the prototype to which the application task hook function must conform. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv412TaskStatus_t">
<span id="_CPPv312TaskStatus_t"></span><span id="_CPPv212TaskStatus_t"></span><span id="TaskStatus_t"></span><span class="target" id="task_8h_1a34f88ef69814fb27d554e666e9868a9c"></span><em class="property">typedef </em><em class="property">struct</em> <a class="reference internal" href="#_CPPv412xTASK_STATUS" title="xTASK_STATUS">xTASK_STATUS</a> <code class="descname">TaskStatus_t</code><a class="headerlink" href="#_CPPv412TaskStatus_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Used with the uxTaskGetSystemState() function to return the state of each task in the system. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv414TaskSnapshot_t">
<span id="_CPPv314TaskSnapshot_t"></span><span id="_CPPv214TaskSnapshot_t"></span><span id="TaskSnapshot_t"></span><span class="target" id="task_8h_1afa89adf9a3394cafc5ec51d62856af0e"></span><em class="property">typedef </em><em class="property">struct</em> <a class="reference internal" href="#_CPPv414xTASK_SNAPSHOT" title="xTASK_SNAPSHOT">xTASK_SNAPSHOT</a> <code class="descname">TaskSnapshot_t</code><a class="headerlink" href="#_CPPv414TaskSnapshot_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Used with the uxTaskGetSnapshotAll() function to save memory snapshot of each task in the system. We need this struct because TCB_t is defined (hidden) in tasks.c. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv427TlsDeleteCallbackFunction_t">
<span id="_CPPv327TlsDeleteCallbackFunction_t"></span><span id="_CPPv227TlsDeleteCallbackFunction_t"></span><span id="TlsDeleteCallbackFunction_t"></span><span class="target" id="task_8h_1aca1c0ef91ef0f8e2610e326e07747a49"></span><em class="property">typedef </em>void (*<code class="descname">TlsDeleteCallbackFunction_t</code>)<span class="sig-paren">(</span>int, void *<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427TlsDeleteCallbackFunction_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Prototype of local storage pointer deletion callback. </p>
</dd></dl>

</div>
<div class="section" id="enumerations">
<h3>Enumerations<a class="headerlink" href="#enumerations" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv410eTaskState">
<span id="_CPPv310eTaskState"></span><span id="_CPPv210eTaskState"></span><span id="eTaskState"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892c"></span><em class="property">enum </em><code class="descname">eTaskState</code><a class="headerlink" href="#_CPPv410eTaskState" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Task states returned by eTaskGetState. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv48eRunning">
<span id="_CPPv38eRunning"></span><span id="_CPPv28eRunning"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892ca83318c0d58e6b2bafaefa1be597fb8b6"></span><code class="descname">eRunning</code> = 0<a class="headerlink" href="#_CPPv48eRunning" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A task is querying the state of itself, so must be running. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv46eReady">
<span id="_CPPv36eReady"></span><span id="_CPPv26eReady"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892ca8570b65f331057b2cf92c504f0a2bc83"></span><code class="descname">eReady</code><a class="headerlink" href="#_CPPv46eReady" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The task being queried is in a read or pending ready list. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv48eBlocked">
<span id="_CPPv38eBlocked"></span><span id="_CPPv28eBlocked"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892cad23d72c68f43b6fff4962ad4154766af"></span><code class="descname">eBlocked</code><a class="headerlink" href="#_CPPv48eBlocked" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The task being queried is in the Blocked state. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv410eSuspended">
<span id="_CPPv310eSuspended"></span><span id="_CPPv210eSuspended"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892caf35a900d49fdfc2502eefc68fdb70f72"></span><code class="descname">eSuspended</code><a class="headerlink" href="#_CPPv410eSuspended" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv48eDeleted">
<span id="_CPPv38eDeleted"></span><span id="_CPPv28eDeleted"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892cacef5c6e771d3a07f656e07a13a20ba35"></span><code class="descname">eDeleted</code><a class="headerlink" href="#_CPPv48eDeleted" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The task being queried has been deleted, but its TCB has not yet been freed. </p>
</dd></dl>

</dd></dl>

<dl class="type">
<dt id="_CPPv413eNotifyAction">
<span id="_CPPv313eNotifyAction"></span><span id="_CPPv213eNotifyAction"></span><span id="eNotifyAction"></span><span class="target" id="task_8h_1ae8abc4f7da5b6880467daafbf19cd233"></span><em class="property">enum </em><code class="descname">eNotifyAction</code><a class="headerlink" href="#_CPPv413eNotifyAction" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Actions that can be performed when vTaskNotify() is called. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv49eNoAction">
<span id="_CPPv39eNoAction"></span><span id="_CPPv29eNoAction"></span><span class="target" id="task_8h_1ae8abc4f7da5b6880467daafbf19cd233abac2b17ab15444724b6f35d47cd0a64a"></span><code class="descname">eNoAction</code> = 0<a class="headerlink" href="#_CPPv49eNoAction" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Notify the task without updating its notify value. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv48eSetBits">
<span id="_CPPv38eSetBits"></span><span id="_CPPv28eSetBits"></span><span class="target" id="task_8h_1ae8abc4f7da5b6880467daafbf19cd233ab7b1af2eeee53ae78eeff37c1cb6f79b"></span><code class="descname">eSetBits</code><a class="headerlink" href="#_CPPv48eSetBits" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set bits in the task’s notification value. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv410eIncrement">
<span id="_CPPv310eIncrement"></span><span id="_CPPv210eIncrement"></span><span class="target" id="task_8h_1ae8abc4f7da5b6880467daafbf19cd233a04fb0e98d2400e4cd28f1593bc868822"></span><code class="descname">eIncrement</code><a class="headerlink" href="#_CPPv410eIncrement" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Increment the task’s notification value. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv422eSetValueWithOverwrite">
<span id="_CPPv322eSetValueWithOverwrite"></span><span id="_CPPv222eSetValueWithOverwrite"></span><span class="target" id="task_8h_1ae8abc4f7da5b6880467daafbf19cd233ab61fc296ef909186b5824c823b33e130"></span><code class="descname">eSetValueWithOverwrite</code><a class="headerlink" href="#_CPPv422eSetValueWithOverwrite" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the task’s notification value to a specific value even if the previous value has not yet been read by the task. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv425eSetValueWithoutOverwrite">
<span id="_CPPv325eSetValueWithoutOverwrite"></span><span id="_CPPv225eSetValueWithoutOverwrite"></span><span class="target" id="task_8h_1ae8abc4f7da5b6880467daafbf19cd233acc4dd3fe71b62c751187a2c4c515abac"></span><code class="descname">eSetValueWithoutOverwrite</code><a class="headerlink" href="#_CPPv425eSetValueWithoutOverwrite" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the task’s notification value if the previous value has been read by the task. </p>
</dd></dl>

</dd></dl>

<dl class="type">
<dt id="_CPPv416eSleepModeStatus">
<span id="_CPPv316eSleepModeStatus"></span><span id="_CPPv216eSleepModeStatus"></span><span id="eSleepModeStatus"></span><span class="target" id="task_8h_1afd168a210ae0f2fb0fca242860a8178e"></span><em class="property">enum </em><code class="descname">eSleepModeStatus</code><a class="headerlink" href="#_CPPv416eSleepModeStatus" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Possible return values for eTaskConfirmSleepModeStatus(). </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv411eAbortSleep">
<span id="_CPPv311eAbortSleep"></span><span id="_CPPv211eAbortSleep"></span><span class="target" id="task_8h_1afd168a210ae0f2fb0fca242860a8178eaba7b1a394c63faa14a85dbb191f1c6f9"></span><code class="descname">eAbortSleep</code> = 0<a class="headerlink" href="#_CPPv411eAbortSleep" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv414eStandardSleep">
<span id="_CPPv314eStandardSleep"></span><span id="_CPPv214eStandardSleep"></span><span class="target" id="task_8h_1afd168a210ae0f2fb0fca242860a8178ea2c539add8104402c6336bc33a660d1d1"></span><code class="descname">eStandardSleep</code><a class="headerlink" href="#_CPPv414eStandardSleep" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enter a sleep mode that will not last any longer than the expected idle time. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv422eNoTasksWaitingTimeout">
<span id="_CPPv322eNoTasksWaitingTimeout"></span><span id="_CPPv222eNoTasksWaitingTimeout"></span><span class="target" id="task_8h_1afd168a210ae0f2fb0fca242860a8178ea004c4d9f1a2619193750d0e2f18f6046"></span><code class="descname">eNoTasksWaitingTimeout</code><a class="headerlink" href="#_CPPv422eNoTasksWaitingTimeout" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. </p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="queue-api">
<h2>Queue API<a class="headerlink" href="#queue-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Header File<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/freertos/include/freertos/queue.h">freertos/include/freertos/queue.h</a></li>
</ul>
</div>
<div class="section" id="id2">
<h3>Functions<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv424xQueueGenericSendFromISR13QueueHandle_tPCKvPC10BaseType_tK10BaseType_t">
<span id="_CPPv324xQueueGenericSendFromISR13QueueHandle_tPCKvPC10BaseType_tK10BaseType_t"></span><span id="_CPPv224xQueueGenericSendFromISR13QueueHandle_tPCKvPC10BaseType_tK10BaseType_t"></span><span id="xQueueGenericSendFromISR__QueueHandle_t.voidCPC.BaseType_tPC.BaseType_tC"></span><span class="target" id="queue_8h_1a263711eb0124112e828a18fd4b8ab29d"></span>BaseType_t <code class="descname">xQueueGenericSendFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t">QueueHandle_t</a> <em>xQueue</em>, <em class="property">const</em> void *<em class="property">const</em> <em>pvItemToQueue</em>, BaseType_t *<em class="property">const</em> <em>pxHigherPriorityTaskWoken</em>, <em class="property">const</em> BaseType_t <em>xCopyPosition</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424xQueueGenericSendFromISR13QueueHandle_tPCKvPC10BaseType_tK10BaseType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>It is preferred that the macros xQueueSendFromISR(), xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place of calling this function directly. xQueueGiveFromISR() is an equivalent for use by semaphores that don’t actually copy any data.</p>
<p>Post an item on a queue. It is safe to use this function from within an interrupt service routine.</p>
<p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p>
<p><p>Example usage for buffered IO (where the ISR can obtain more than one value per call): </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vBufferISR</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">cIn</span><span class="p">;</span>
<span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWokenByPost</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">We</span> <span class="n">have</span> <span class="ow">not</span> <span class="n">woken</span> <span class="n">a</span> <span class="n">task</span> <span class="n">at</span> <span class="n">the</span> <span class="n">start</span> <span class="n">of</span> <span class="n">the</span> <span class="n">ISR</span><span class="o">.</span>
   <span class="n">xHigherPriorityTaskWokenByPost</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">Loop</span> <span class="n">until</span> <span class="n">the</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="n">empty</span><span class="o">.</span>
   <span class="n">do</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">Obtain</span> <span class="n">a</span> <span class="n">byte</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">buffer</span><span class="o">.</span>
       <span class="n">cIn</span> <span class="o">=</span> <span class="n">portINPUT_BYTE</span><span class="p">(</span> <span class="n">RX_REGISTER_ADDRESS</span> <span class="p">);</span>

       <span class="o">//</span> <span class="n">Post</span> <span class="n">each</span> <span class="n">byte</span><span class="o">.</span>
       <span class="n">xQueueGenericSendFromISR</span><span class="p">(</span> <span class="n">xRxQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cIn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWokenByPost</span><span class="p">,</span> <span class="n">queueSEND_TO_BACK</span> <span class="p">);</span>

   <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="n">portINPUT_BYTE</span><span class="p">(</span> <span class="n">BUFFER_COUNT</span> <span class="p">)</span> <span class="p">);</span>

   <span class="o">//</span> <span class="n">Now</span> <span class="n">the</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="n">empty</span> <span class="n">we</span> <span class="n">can</span> <span class="n">switch</span> <span class="n">context</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>  <span class="n">Note</span> <span class="n">that</span> <span class="n">the</span>
   <span class="o">//</span> <span class="n">name</span> <span class="n">of</span> <span class="n">the</span> <span class="k">yield</span> <span class="n">function</span> <span class="n">required</span> <span class="ow">is</span> <span class="n">port</span> <span class="n">specific</span><span class="o">.</span>
   <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWokenByPost</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="n">taskYIELD_YIELD_FROM_ISR</span><span class="p">();</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The handle to the queue on which the item is to be posted.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>: A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>: xQueueGenericSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueGenericSendFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</li>
<li><code class="docutils literal notranslate"><span class="pre">xCopyPosition</span></code>: Can take the value queueSEND_TO_BACK to place the item at the back of the queue, or queueSEND_TO_FRONT to place the item at the front of the queue (for high priority messages).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417xQueueGiveFromISR13QueueHandle_tPC10BaseType_t">
<span id="_CPPv317xQueueGiveFromISR13QueueHandle_tPC10BaseType_t"></span><span id="_CPPv217xQueueGiveFromISR13QueueHandle_tPC10BaseType_t"></span><span id="xQueueGiveFromISR__QueueHandle_t.BaseType_tPC"></span><span class="target" id="queue_8h_1ad14ae1174c2772cffc9e0c2c45dc55a6"></span>BaseType_t <code class="descname">xQueueGiveFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t">QueueHandle_t</a> <em>xQueue</em>, BaseType_t *<em class="property">const</em> <em>pxHigherPriorityTaskWoken</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417xQueueGiveFromISR13QueueHandle_tPC10BaseType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv425xQueueIsQueueEmptyFromISRK13QueueHandle_t">
<span id="_CPPv325xQueueIsQueueEmptyFromISRK13QueueHandle_t"></span><span id="_CPPv225xQueueIsQueueEmptyFromISRK13QueueHandle_t"></span><span id="xQueueIsQueueEmptyFromISR__QueueHandle_tC"></span><span class="target" id="queue_8h_1aa11139c58f4eecaa0c50078f2976d010"></span>BaseType_t <code class="descname">xQueueIsQueueEmptyFromISR</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t">QueueHandle_t</a> <em>xQueue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425xQueueIsQueueEmptyFromISRK13QueueHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Utilities to query queues that are safe to use from an ISR. These utilities should be used only from witin an ISR, or within a critical section. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424xQueueIsQueueFullFromISRK13QueueHandle_t">
<span id="_CPPv324xQueueIsQueueFullFromISRK13QueueHandle_t"></span><span id="_CPPv224xQueueIsQueueFullFromISRK13QueueHandle_t"></span><span id="xQueueIsQueueFullFromISR__QueueHandle_tC"></span><span class="target" id="queue_8h_1a81319b3aa562733957c5a12a088516d3"></span>BaseType_t <code class="descname">xQueueIsQueueFullFromISR</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t">QueueHandle_t</a> <em>xQueue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424xQueueIsQueueFullFromISRK13QueueHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv429uxQueueMessagesWaitingFromISRK13QueueHandle_t">
<span id="_CPPv329uxQueueMessagesWaitingFromISRK13QueueHandle_t"></span><span id="_CPPv229uxQueueMessagesWaitingFromISRK13QueueHandle_t"></span><span id="uxQueueMessagesWaitingFromISR__QueueHandle_tC"></span><span class="target" id="queue_8h_1a3e89b6189166f9544f283435e2732f9a"></span>UBaseType_t <code class="descname">uxQueueMessagesWaitingFromISR</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t">QueueHandle_t</a> <em>xQueue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429uxQueueMessagesWaitingFromISRK13QueueHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv417xQueueGenericSend13QueueHandle_tPCKv10TickType_tK10BaseType_t">
<span id="_CPPv317xQueueGenericSend13QueueHandle_tPCKv10TickType_tK10BaseType_t"></span><span id="_CPPv217xQueueGenericSend13QueueHandle_tPCKv10TickType_tK10BaseType_t"></span><span id="xQueueGenericSend__QueueHandle_t.voidCPC.TickType_t.BaseType_tC"></span><span class="target" id="queue_8h_1a7ce86d1026e0c3055a523935bf53c0b3"></span>BaseType_t <code class="descname">xQueueGenericSend</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t">QueueHandle_t</a> <em>xQueue</em>, <em class="property">const</em> void *<em class="property">const</em> <em>pvItemToQueue</em>, TickType_t <em>xTicksToWait</em>, <em class="property">const</em> BaseType_t <em>xCopyPosition</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417xQueueGenericSend13QueueHandle_tPCKv10TickType_tK10BaseType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>It is preferred that the macros xQueueSend(), xQueueSendToFront() and xQueueSendToBack() are used in place of calling this function directly.</p>
<p>Post an item on a queue. The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See xQueueSendFromISR () for an alternative which may be used in an ISR.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">AMessage</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">ucMessageID</span><span class="p">;</span>
<span class="n">char</span> <span class="n">ucData</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>
<span class="p">}</span> <span class="n">xMessage</span><span class="p">;</span>

<span class="n">uint32_t</span> <span class="n">ulVar</span> <span class="o">=</span> <span class="mi">10</span><span class="n">UL</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">QueueHandle_t</span> <span class="n">xQueue1</span><span class="p">,</span> <span class="n">xQueue2</span><span class="p">;</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">uint32_t</span> <span class="n">values</span><span class="o">.</span>
<span class="n">xQueue1</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">uint32_t</span> <span class="p">)</span> <span class="p">);</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">AMessage</span> <span class="n">structures</span><span class="o">.</span>
<span class="o">//</span> <span class="n">These</span> <span class="n">should</span> <span class="n">be</span> <span class="n">passed</span> <span class="n">by</span> <span class="n">pointer</span> <span class="k">as</span> <span class="n">they</span> <span class="n">contain</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">of</span> <span class="n">data</span><span class="o">.</span>
<span class="n">xQueue2</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>

<span class="o">//</span> <span class="o">...</span>

<span class="k">if</span><span class="p">(</span> <span class="n">xQueue1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Send</span> <span class="n">an</span> <span class="n">uint32_t</span><span class="o">.</span>  <span class="n">Wait</span> <span class="k">for</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="k">for</span> <span class="n">space</span> <span class="n">to</span> <span class="n">become</span>
    <span class="o">//</span> <span class="n">available</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xQueueGenericSend</span><span class="p">(</span> <span class="n">xQueue1</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">ulVar</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span><span class="p">,</span> <span class="n">queueSEND_TO_BACK</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">post</span> <span class="n">the</span> <span class="n">message</span><span class="p">,</span> <span class="n">even</span> <span class="n">after</span> <span class="mi">10</span> <span class="n">ticks</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span><span class="p">(</span> <span class="n">xQueue2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Send</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="nb">object</span><span class="o">.</span>  <span class="n">Don</span><span class="s1">&#39;t block if the</span>
    <span class="o">//</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">full</span><span class="o">.</span>
    <span class="n">pxMessage</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">xMessage</span><span class="p">;</span>
    <span class="n">xQueueGenericSend</span><span class="p">(</span> <span class="n">xQueue2</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">0</span><span class="p">,</span> <span class="n">queueSEND_TO_BACK</span> <span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The handle to the queue on which the item is to be posted.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>: A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required.</li>
<li><code class="docutils literal notranslate"><span class="pre">xCopyPosition</span></code>: Can take the value queueSEND_TO_BACK to place the item at the back of the queue, or queueSEND_TO_FRONT to place the item at the front of the queue (for high priority messages).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417xQueuePeekFromISR13QueueHandle_tPCv">
<span id="_CPPv317xQueuePeekFromISR13QueueHandle_tPCv"></span><span id="_CPPv217xQueuePeekFromISR13QueueHandle_tPCv"></span><span id="xQueuePeekFromISR__QueueHandle_t.voidPC"></span><span class="target" id="queue_8h_1ac402adf98be1fb8ca0345f30dc11a9dc"></span>BaseType_t <code class="descname">xQueuePeekFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t">QueueHandle_t</a> <em>xQueue</em>, void *<em class="property">const</em> <em>pvBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417xQueuePeekFromISR13QueueHandle_tPCv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A version of xQueuePeek() that can be called from an interrupt service routine (ISR).</p>
<p>Receive an item from a queue without removing the item from the queue. The item is received by copy so a buffer of adequate size must be provided. The number of bytes copied into the buffer was defined when the queue was created.</p>
<p>Successfully received items remain on the queue so will be returned again by the next call, or a call to xQueueReceive().</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The handle to the queue from which the item is to be received.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvBuffer</span></code>: Pointer to the buffer into which the received item will be copied.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420xQueueGenericReceive13QueueHandle_tPCv10TickType_tK10BaseType_t">
<span id="_CPPv320xQueueGenericReceive13QueueHandle_tPCv10TickType_tK10BaseType_t"></span><span id="_CPPv220xQueueGenericReceive13QueueHandle_tPCv10TickType_tK10BaseType_t"></span><span id="xQueueGenericReceive__QueueHandle_t.voidPC.TickType_t.BaseType_tC"></span><span class="target" id="queue_8h_1a6a0c9135edf180d270ac0ffb17ec21b4"></span>BaseType_t <code class="descname">xQueueGenericReceive</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t">QueueHandle_t</a> <em>xQueue</em>, void *<em class="property">const</em> <em>pvBuffer</em>, TickType_t <em>xTicksToWait</em>, <em class="property">const</em> BaseType_t <em>xJustPeek</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420xQueueGenericReceive13QueueHandle_tPCv10TickType_tK10BaseType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>It is preferred that the macro xQueueReceive() be used rather than calling this function directly.</p>
<p>Receive an item from a queue. The item is received by copy so a buffer of adequate size must be provided. The number of bytes copied into the buffer was defined when the queue was created.</p>
<p>This function must not be used in an interrupt service routine. See xQueueReceiveFromISR for an alternative that can.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">AMessage</span>
<span class="p">{</span>
   <span class="n">char</span> <span class="n">ucMessageID</span><span class="p">;</span>
   <span class="n">char</span> <span class="n">ucData</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>
<span class="p">}</span> <span class="n">xMessage</span><span class="p">;</span>

<span class="n">QueueHandle_t</span> <span class="n">xQueue</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Task</span> <span class="n">to</span> <span class="n">create</span> <span class="n">a</span> <span class="n">queue</span> <span class="ow">and</span> <span class="n">post</span> <span class="n">a</span> <span class="n">value</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">AMessage</span> <span class="n">structures</span><span class="o">.</span>
   <span class="o">//</span> <span class="n">These</span> <span class="n">should</span> <span class="n">be</span> <span class="n">passed</span> <span class="n">by</span> <span class="n">pointer</span> <span class="k">as</span> <span class="n">they</span> <span class="n">contain</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">of</span> <span class="n">data</span><span class="o">.</span>
   <span class="n">xQueue</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>
   <span class="k">if</span><span class="p">(</span> <span class="n">xQueue</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">create</span> <span class="n">the</span> <span class="n">queue</span><span class="o">.</span>
   <span class="p">}</span>

   <span class="o">//</span> <span class="o">...</span>

   <span class="o">//</span> <span class="n">Send</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="nb">object</span><span class="o">.</span>  <span class="n">Don</span><span class="s1">&#39;t block if the</span>
   <span class="o">//</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">full</span><span class="o">.</span>
   <span class="n">pxMessage</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">xMessage</span><span class="p">;</span>
   <span class="n">xQueueSend</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">0</span> <span class="p">);</span>

   <span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">Task</span> <span class="n">to</span> <span class="n">receive</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">queue</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vADifferentTask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxRxedMessage</span><span class="p">;</span>

   <span class="k">if</span><span class="p">(</span> <span class="n">xQueue</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">Receive</span> <span class="n">a</span> <span class="n">message</span> <span class="n">on</span> <span class="n">the</span> <span class="n">created</span> <span class="n">queue</span><span class="o">.</span>  <span class="n">Block</span> <span class="k">for</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="k">if</span> <span class="n">a</span>
       <span class="o">//</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">immediately</span> <span class="n">available</span><span class="o">.</span>
       <span class="k">if</span><span class="p">(</span> <span class="n">xQueueGenericReceive</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span> <span class="n">pxRxedMessage</span> <span class="p">),</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">{</span>
           <span class="o">//</span> <span class="n">pcRxedMessage</span> <span class="n">now</span> <span class="n">points</span> <span class="n">to</span> <span class="n">the</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="n">variable</span> <span class="n">posted</span>
           <span class="o">//</span> <span class="n">by</span> <span class="n">vATask</span><span class="o">.</span>
       <span class="p">}</span>
   <span class="p">}</span>

   <span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The handle to the queue from which the item is to be received.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvBuffer</span></code>: Pointer to the buffer into which the received item will be copied.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: The maximum amount of time the task should block waiting for an item to receive should the queue be empty at the time of the call. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required. xQueueGenericReceive() will return immediately if the queue is empty and xTicksToWait is 0.</li>
<li><code class="docutils literal notranslate"><span class="pre">xJustPeek</span></code>: When set to true, the item received from the queue is not actually removed from the queue - meaning a subsequent call to xQueueReceive() will return the same item. When set to false, the item being received from the queue is also removed from the queue.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422uxQueueMessagesWaitingK13QueueHandle_t">
<span id="_CPPv322uxQueueMessagesWaitingK13QueueHandle_t"></span><span id="_CPPv222uxQueueMessagesWaitingK13QueueHandle_t"></span><span id="uxQueueMessagesWaiting__QueueHandle_tC"></span><span class="target" id="queue_8h_1add7ee0701ba35904d190811b9e5a4eda"></span>UBaseType_t <code class="descname">uxQueueMessagesWaiting</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t">QueueHandle_t</a> <em>xQueue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422uxQueueMessagesWaitingK13QueueHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the number of messages stored in a queue.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The number of messages available in the queue. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: A handle to the queue being queried.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422uxQueueSpacesAvailableK13QueueHandle_t">
<span id="_CPPv322uxQueueSpacesAvailableK13QueueHandle_t"></span><span id="_CPPv222uxQueueSpacesAvailableK13QueueHandle_t"></span><span id="uxQueueSpacesAvailable__QueueHandle_tC"></span><span class="target" id="queue_8h_1aae75791e91707c1e0bb31d761921531c"></span>UBaseType_t <code class="descname">uxQueueSpacesAvailable</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t">QueueHandle_t</a> <em>xQueue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422uxQueueSpacesAvailableK13QueueHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the number of free spaces available in a queue. This is equal to the number of items that can be sent to the queue before the queue becomes full if no items are removed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The number of spaces available in the queue. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: A handle to the queue being queried.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412vQueueDelete13QueueHandle_t">
<span id="_CPPv312vQueueDelete13QueueHandle_t"></span><span id="_CPPv212vQueueDelete13QueueHandle_t"></span><span id="vQueueDelete__QueueHandle_t"></span><span class="target" id="queue_8h_1a707cbcfe3aed6b877b6aa6d9d75a3f22"></span>void <code class="descname">vQueueDelete</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t">QueueHandle_t</a> <em>xQueue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412vQueueDelete13QueueHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Delete a queue - freeing all the memory allocated for storing of items placed on the queue.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: A handle to the queue to be deleted. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420xQueueReceiveFromISR13QueueHandle_tPCvPC10BaseType_t">
<span id="_CPPv320xQueueReceiveFromISR13QueueHandle_tPCvPC10BaseType_t"></span><span id="_CPPv220xQueueReceiveFromISR13QueueHandle_tPCvPC10BaseType_t"></span><span id="xQueueReceiveFromISR__QueueHandle_t.voidPC.BaseType_tPC"></span><span class="target" id="queue_8h_1acdf528f5c91131ae2f31c669cfd65758"></span>BaseType_t <code class="descname">xQueueReceiveFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t">QueueHandle_t</a> <em>xQueue</em>, void *<em class="property">const</em> <em>pvBuffer</em>, BaseType_t *<em class="property">const</em> <em>pxHigherPriorityTaskWoken</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420xQueueReceiveFromISR13QueueHandle_tPCvPC10BaseType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Receive an item from a queue. It is safe to use this function from within an interrupt service routine.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QueueHandle_t</span> <span class="n">xQueue</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Function</span> <span class="n">to</span> <span class="n">create</span> <span class="n">a</span> <span class="n">queue</span> <span class="ow">and</span> <span class="n">post</span> <span class="n">some</span> <span class="n">values</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vAFunction</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">cValueToPost</span><span class="p">;</span>
<span class="n">const</span> <span class="n">TickType_t</span> <span class="n">xTicksToWait</span> <span class="o">=</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span><span class="mh">0xff</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">characters</span><span class="o">.</span>
   <span class="n">xQueue</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">char</span> <span class="p">)</span> <span class="p">);</span>
   <span class="k">if</span><span class="p">(</span> <span class="n">xQueue</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">create</span> <span class="n">the</span> <span class="n">queue</span><span class="o">.</span>
   <span class="p">}</span>

   <span class="o">//</span> <span class="o">...</span>

   <span class="o">//</span> <span class="n">Post</span> <span class="n">some</span> <span class="n">characters</span> <span class="n">that</span> <span class="n">will</span> <span class="n">be</span> <span class="n">used</span> <span class="n">within</span> <span class="n">an</span> <span class="n">ISR</span><span class="o">.</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">queue</span>
   <span class="o">//</span> <span class="ow">is</span> <span class="n">full</span> <span class="n">then</span> <span class="n">this</span> <span class="n">task</span> <span class="n">will</span> <span class="n">block</span> <span class="k">for</span> <span class="n">xTicksToWait</span> <span class="n">ticks</span><span class="o">.</span>
   <span class="n">cValueToPost</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span><span class="p">;</span>
   <span class="n">xQueueSend</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">cValueToPost</span><span class="p">,</span> <span class="n">xTicksToWait</span> <span class="p">);</span>
   <span class="n">cValueToPost</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span><span class="p">;</span>
   <span class="n">xQueueSend</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">cValueToPost</span><span class="p">,</span> <span class="n">xTicksToWait</span> <span class="p">);</span>

   <span class="o">//</span> <span class="o">...</span> <span class="n">keep</span> <span class="n">posting</span> <span class="n">characters</span> <span class="o">...</span> <span class="n">this</span> <span class="n">task</span> <span class="n">may</span> <span class="n">block</span> <span class="n">when</span> <span class="n">the</span> <span class="n">queue</span>
   <span class="o">//</span> <span class="n">becomes</span> <span class="n">full</span><span class="o">.</span>

   <span class="n">cValueToPost</span> <span class="o">=</span> <span class="s1">&#39;c&#39;</span><span class="p">;</span>
   <span class="n">xQueueSend</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">cValueToPost</span><span class="p">,</span> <span class="n">xTicksToWait</span> <span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">ISR</span> <span class="n">that</span> <span class="n">outputs</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">characters</span> <span class="n">received</span> <span class="n">on</span> <span class="n">the</span> <span class="n">queue</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vISR_Routine</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span> <span class="n">xTaskWokenByReceive</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>
<span class="n">char</span> <span class="n">cRxedChar</span><span class="p">;</span>

   <span class="k">while</span><span class="p">(</span> <span class="n">xQueueReceiveFromISR</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">cRxedChar</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xTaskWokenByReceive</span><span class="p">)</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">A</span> <span class="n">character</span> <span class="n">was</span> <span class="n">received</span><span class="o">.</span>  <span class="n">Output</span> <span class="n">the</span> <span class="n">character</span> <span class="n">now</span><span class="o">.</span>
       <span class="n">vOutputCharacter</span><span class="p">(</span> <span class="n">cRxedChar</span> <span class="p">);</span>

       <span class="o">//</span> <span class="n">If</span> <span class="n">removing</span> <span class="n">the</span> <span class="n">character</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">queue</span> <span class="n">woke</span> <span class="n">the</span> <span class="n">task</span> <span class="n">that</span> <span class="n">was</span>
       <span class="o">//</span> <span class="n">posting</span> <span class="n">onto</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">cTaskWokenByReceive</span> <span class="n">will</span> <span class="n">have</span> <span class="n">been</span> <span class="nb">set</span> <span class="n">to</span>
       <span class="o">//</span> <span class="n">pdTRUE</span><span class="o">.</span>  <span class="n">No</span> <span class="n">matter</span> <span class="n">how</span> <span class="n">many</span> <span class="n">times</span> <span class="n">this</span> <span class="n">loop</span> <span class="n">iterates</span> <span class="n">only</span> <span class="n">one</span>
       <span class="o">//</span> <span class="n">task</span> <span class="n">will</span> <span class="n">be</span> <span class="n">woken</span><span class="o">.</span>
   <span class="p">}</span>

   <span class="k">if</span><span class="p">(</span> <span class="n">cTaskWokenByPost</span> <span class="o">!=</span> <span class="p">(</span> <span class="n">char</span> <span class="p">)</span> <span class="n">pdFALSE</span><span class="p">;</span>
   <span class="p">{</span>
       <span class="n">taskYIELD</span> <span class="p">();</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The handle to the queue from which the item is to be received.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvBuffer</span></code>: Pointer to the buffer into which the received item will be copied.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>: A task may be blocked waiting for space to become available on the queue. If xQueueReceiveFromISR causes such a task to unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will remain unchanged.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419vQueueAddToRegistry13QueueHandle_tPKc">
<span id="_CPPv319vQueueAddToRegistry13QueueHandle_tPKc"></span><span id="_CPPv219vQueueAddToRegistry13QueueHandle_tPKc"></span><span id="vQueueAddToRegistry__QueueHandle_t.cCP"></span><span class="target" id="queue_8h_1a5279f7129bc36be6ec3eb6fa043e8e40"></span>void <code class="descname">vQueueAddToRegistry</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t">QueueHandle_t</a> <em>xQueue</em>, <em class="property">const</em> char *<em>pcName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419vQueueAddToRegistry13QueueHandle_tPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The registry is provided as a means for kernel aware debuggers to locate queues, semaphores and mutexes. Call vQueueAddToRegistry() add a queue, semaphore or mutex handle to the registry if you want the handle to be available to a kernel aware debugger. If you are not using a kernel aware debugger then this function can be ignored.</p>
<p>configQUEUE_REGISTRY_SIZE defines the maximum number of handles the registry can hold. configQUEUE_REGISTRY_SIZE must be greater than 0 within FreeRTOSConfig.h for the registry to be available. Its value does not effect the number of queues, semaphores and mutexes that can be created - just the number that the registry can hold.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The handle of the queue being added to the registry. This is the handle returned by a call to xQueueCreate(). Semaphore and mutex handles can also be passed in here.</li>
<li><code class="docutils literal notranslate"><span class="pre">pcName</span></code>: The name to be associated with the handle. This is the name that the kernel aware debugger will display. The queue registry only stores a pointer to the string - so the string must be persistent (global or preferably in ROM/Flash), not on the stack. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv421vQueueUnregisterQueue13QueueHandle_t">
<span id="_CPPv321vQueueUnregisterQueue13QueueHandle_t"></span><span id="_CPPv221vQueueUnregisterQueue13QueueHandle_t"></span><span id="vQueueUnregisterQueue__QueueHandle_t"></span><span class="target" id="queue_8h_1a193c170b0241e93d364c1f588c9a1f0c"></span>void <code class="descname">vQueueUnregisterQueue</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t">QueueHandle_t</a> <em>xQueue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421vQueueUnregisterQueue13QueueHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The registry is provided as a means for kernel aware debuggers to locate queues, semaphores and mutexes. Call vQueueAddToRegistry() add a queue, semaphore or mutex handle to the registry if you want the handle to be available to a kernel aware debugger, and vQueueUnregisterQueue() to remove the queue, semaphore or mutex from the register. If you are not using a kernel aware debugger then this function can be ignored.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The handle of the queue being removed from the registry. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414pcQueueGetName13QueueHandle_t">
<span id="_CPPv314pcQueueGetName13QueueHandle_t"></span><span id="_CPPv214pcQueueGetName13QueueHandle_t"></span><span id="pcQueueGetName__QueueHandle_t"></span><span class="target" id="queue_8h_1ad47e5fd126c81a5849aa945d3b1a26e2"></span><em class="property">const</em> char *<code class="descname">pcQueueGetName</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t">QueueHandle_t</a> <em>xQueue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414pcQueueGetName13QueueHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><p>The queue registry is provided as a means for kernel aware debuggers to locate queues, semaphores and mutexes. Call pcQueueGetName() to look up and return the name of a queue in the queue registry from the queue’s handle.</p>
<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function has been back ported from FreeRTOS v9.0.0</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If the queue is in the registry then a pointer to the name of the queue is returned. If the queue is not in the registry then NULL is returned. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The handle of the queue the name of which will be returned. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419xQueueGenericCreateK11UBaseType_tK11UBaseType_tK7uint8_t">
<span id="_CPPv319xQueueGenericCreateK11UBaseType_tK11UBaseType_tK7uint8_t"></span><span id="_CPPv219xQueueGenericCreateK11UBaseType_tK11UBaseType_tK7uint8_t"></span><span id="xQueueGenericCreate__UBaseType_tC.UBaseType_tC.uint8_tC"></span><span class="target" id="queue_8h_1a74fb40ea6a869143597ca91ce90c99c2"></span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t">QueueHandle_t</a> <code class="descname">xQueueGenericCreate</code><span class="sig-paren">(</span><em class="property">const</em> UBaseType_t <em>uxQueueLength</em>, <em class="property">const</em> UBaseType_t <em>uxItemSize</em>, <em class="property">const</em> uint8_t <em>ucQueueType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419xQueueGenericCreateK11UBaseType_tK11UBaseType_tK7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Generic version of the function used to creaet a queue using dynamic memory allocation. This is called by other functions and macros that create other RTOS objects that use the queue structure as their base. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425xQueueGenericCreateStaticK11UBaseType_tK11UBaseType_tP7uint8_tP13StaticQueue_tK7uint8_t">
<span id="_CPPv325xQueueGenericCreateStaticK11UBaseType_tK11UBaseType_tP7uint8_tP13StaticQueue_tK7uint8_t"></span><span id="_CPPv225xQueueGenericCreateStaticK11UBaseType_tK11UBaseType_tP7uint8_tP13StaticQueue_tK7uint8_t"></span><span id="xQueueGenericCreateStatic__UBaseType_tC.UBaseType_tC.uint8_tP.StaticQueue_tP.uint8_tC"></span><span class="target" id="queue_8h_1a5b2efe04da1dd893134938188aebc8e1"></span><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t">QueueHandle_t</a> <code class="descname">xQueueGenericCreateStatic</code><span class="sig-paren">(</span><em class="property">const</em> UBaseType_t <em>uxQueueLength</em>, <em class="property">const</em> UBaseType_t <em>uxItemSize</em>, uint8_t *<em>pucQueueStorage</em>, StaticQueue_t *<em>pxStaticQueue</em>, <em class="property">const</em> uint8_t <em>ucQueueType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425xQueueGenericCreateStaticK11UBaseType_tK11UBaseType_tP7uint8_tP13StaticQueue_tK7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Generic version of the function used to creaet a queue using dynamic memory allocation. This is called by other functions and macros that create other RTOS objects that use the queue structure as their base. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415xQueueCreateSetK11UBaseType_t">
<span id="_CPPv315xQueueCreateSetK11UBaseType_t"></span><span id="_CPPv215xQueueCreateSetK11UBaseType_t"></span><span id="xQueueCreateSet__UBaseType_tC"></span><span class="target" id="queue_8h_1ad4208ad97f737af942a13e64b45e83e8"></span><a class="reference internal" href="#_CPPv416QueueSetHandle_t" title="QueueSetHandle_t">QueueSetHandle_t</a> <code class="descname">xQueueCreateSet</code><span class="sig-paren">(</span><em class="property">const</em> UBaseType_t <em>uxEventQueueLength</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415xQueueCreateSetK11UBaseType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Queue sets provide a mechanism to allow a task to block (pend) on a read operation from multiple queues or semaphores simultaneously.</p>
<p>See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this function.</p>
<p>A queue set must be explicitly created using a call to xQueueCreateSet() before it can be used. Once created, standard FreeRTOS queues and semaphores can be added to the set using calls to xQueueAddToSet(). xQueueSelectFromSet() is then used to determine which, if any, of the queues or semaphores contained in the set is in a state where a queue read or semaphore take operation would be successful.</p>
<p>Note 1: See the documentation on <a class="reference external" href="http://wwwfreertos.org/RTOS-queue-sets.html">http://wwwFreeRTOS.org/RTOS-queue-sets.html</a> for reasons why queue sets are very rarely needed in practice as there are simpler methods of blocking on multiple objects.</p>
<p>Note 2: Blocking on a queue set that contains a mutex will not cause the mutex holder to inherit the priority of the blocked task.</p>
<p>Note 3: An additional 4 bytes of RAM is required for each space in a every queue added to a queue set. Therefore counting semaphores that have a high maximum count value should not be added to a queue set.</p>
<p>Note 4: A receive (in the case of a queue) or take (in the case of a semaphore) operation must not be performed on a member of a queue set unless a call to xQueueSelectFromSet() has first returned a handle to that set member.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If the queue set is created successfully then a handle to the created queue set is returned. Otherwise NULL is returned. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">uxEventQueueLength</span></code>: Queue sets store events that occur on the queues and semaphores contained in the set. uxEventQueueLength specifies the maximum number of events that can be queued at once. To be absolutely certain that events are not lost uxEventQueueLength should be set to the total sum of the length of the queues added to the set, where binary semaphores and mutexes have a length of 1, and counting semaphores have a length set by their maximum count value. Examples:<ul>
<li>If a queue set is to hold a queue of length 5, another queue of length 12, and a binary semaphore, then uxEventQueueLength should be set to (5 + 12 + 1), or 18.</li>
<li>If a queue set is to hold three binary semaphores then uxEventQueueLength should be set to (1 + 1 + 1 ), or 3.</li>
<li>If a queue set is to hold a counting semaphore that has a maximum count of 5, and a counting semaphore that has a maximum count of 3, then uxEventQueueLength should be set to (5 + 3), or 8.</li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414xQueueAddToSet22QueueSetMemberHandle_t16QueueSetHandle_t">
<span id="_CPPv314xQueueAddToSet22QueueSetMemberHandle_t16QueueSetHandle_t"></span><span id="_CPPv214xQueueAddToSet22QueueSetMemberHandle_t16QueueSetHandle_t"></span><span id="xQueueAddToSet__QueueSetMemberHandle_t.QueueSetHandle_t"></span><span class="target" id="queue_8h_1ae07b563e6bbe42a977f7c46853aa11eb"></span>BaseType_t <code class="descname">xQueueAddToSet</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv422QueueSetMemberHandle_t" title="QueueSetMemberHandle_t">QueueSetMemberHandle_t</a> <em>xQueueOrSemaphore</em>, <a class="reference internal" href="#_CPPv416QueueSetHandle_t" title="QueueSetHandle_t">QueueSetHandle_t</a> <em>xQueueSet</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414xQueueAddToSet22QueueSetMemberHandle_t16QueueSetHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Adds a queue or semaphore to a queue set that was previously created by a call to xQueueCreateSet().</p>
<p>See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this function.</p>
<p>Note 1: A receive (in the case of a queue) or take (in the case of a semaphore) operation must not be performed on a member of a queue set unless a call to xQueueSelectFromSet() has first returned a handle to that set member.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If the queue or semaphore was successfully added to the queue set then pdPASS is returned. If the queue could not be successfully added to the queue set because it is already a member of a different queue set then pdFAIL is returned. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueueOrSemaphore</span></code>: The handle of the queue or semaphore being added to the queue set (cast to an QueueSetMemberHandle_t type).</li>
<li><code class="docutils literal notranslate"><span class="pre">xQueueSet</span></code>: The handle of the queue set to which the queue or semaphore is being added.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419xQueueRemoveFromSet22QueueSetMemberHandle_t16QueueSetHandle_t">
<span id="_CPPv319xQueueRemoveFromSet22QueueSetMemberHandle_t16QueueSetHandle_t"></span><span id="_CPPv219xQueueRemoveFromSet22QueueSetMemberHandle_t16QueueSetHandle_t"></span><span id="xQueueRemoveFromSet__QueueSetMemberHandle_t.QueueSetHandle_t"></span><span class="target" id="queue_8h_1ab16fdd17b9b6d74a82c8366f47cda162"></span>BaseType_t <code class="descname">xQueueRemoveFromSet</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv422QueueSetMemberHandle_t" title="QueueSetMemberHandle_t">QueueSetMemberHandle_t</a> <em>xQueueOrSemaphore</em>, <a class="reference internal" href="#_CPPv416QueueSetHandle_t" title="QueueSetHandle_t">QueueSetHandle_t</a> <em>xQueueSet</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419xQueueRemoveFromSet22QueueSetMemberHandle_t16QueueSetHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Removes a queue or semaphore from a queue set. A queue or semaphore can only be removed from a set if the queue or semaphore is empty.</p>
<p>See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this function.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If the queue or semaphore was successfully removed from the queue set then pdPASS is returned. If the queue was not in the queue set, or the queue (or semaphore) was not empty, then pdFAIL is returned. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueueOrSemaphore</span></code>: The handle of the queue or semaphore being removed from the queue set (cast to an QueueSetMemberHandle_t type).</li>
<li><code class="docutils literal notranslate"><span class="pre">xQueueSet</span></code>: The handle of the queue set in which the queue or semaphore is included.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419xQueueSelectFromSet16QueueSetHandle_tK10TickType_t">
<span id="_CPPv319xQueueSelectFromSet16QueueSetHandle_tK10TickType_t"></span><span id="_CPPv219xQueueSelectFromSet16QueueSetHandle_tK10TickType_t"></span><span id="xQueueSelectFromSet__QueueSetHandle_t.TickType_tC"></span><span class="target" id="queue_8h_1a71f56e6277ed4e419c707c8d0c785065"></span><a class="reference internal" href="#_CPPv422QueueSetMemberHandle_t" title="QueueSetMemberHandle_t">QueueSetMemberHandle_t</a> <code class="descname">xQueueSelectFromSet</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416QueueSetHandle_t" title="QueueSetHandle_t">QueueSetHandle_t</a> <em>xQueueSet</em>, <em class="property">const</em> TickType_t <em>xTicksToWait</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419xQueueSelectFromSet16QueueSetHandle_tK10TickType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>xQueueSelectFromSet() selects from the members of a queue set a queue or semaphore that either contains data (in the case of a queue) or is available to take (in the case of a semaphore). xQueueSelectFromSet() effectively allows a task to block (pend) on a read operation on all the queues and semaphores in a queue set simultaneously.</p>
<p>See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this function.</p>
<p>Note 1: See the documentation on <a class="reference external" href="http://wwwfreertos.org/RTOS-queue-sets.html">http://wwwFreeRTOS.org/RTOS-queue-sets.html</a> for reasons why queue sets are very rarely needed in practice as there are simpler methods of blocking on multiple objects.</p>
<p>Note 2: Blocking on a queue set that contains a mutex will not cause the mutex holder to inherit the priority of the blocked task.</p>
<p>Note 3: A receive (in the case of a queue) or take (in the case of a semaphore) operation must not be performed on a member of a queue set unless a call to xQueueSelectFromSet() has first returned a handle to that set member.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>xQueueSelectFromSet() will return the handle of a queue (cast to a QueueSetMemberHandle_t type) contained in the queue set that contains data, or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained in the queue set that is available, or NULL if no such queue or semaphore exists before before the specified block time expires. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueueSet</span></code>: The queue set on which the task will (potentially) block.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: The maximum time, in ticks, that the calling task will remain in the Blocked state (with other tasks executing) to wait for a member of the queue set to be ready for a successful queue read or semaphore take operation.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv426xQueueSelectFromSetFromISR16QueueSetHandle_t">
<span id="_CPPv326xQueueSelectFromSetFromISR16QueueSetHandle_t"></span><span id="_CPPv226xQueueSelectFromSetFromISR16QueueSetHandle_t"></span><span id="xQueueSelectFromSetFromISR__QueueSetHandle_t"></span><span class="target" id="queue_8h_1ac58b34fd733cf460cddab1abb9a899b3"></span><a class="reference internal" href="#_CPPv422QueueSetMemberHandle_t" title="QueueSetMemberHandle_t">QueueSetMemberHandle_t</a> <code class="descname">xQueueSelectFromSetFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416QueueSetHandle_t" title="QueueSetHandle_t">QueueSetHandle_t</a> <em>xQueueSet</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426xQueueSelectFromSetFromISR16QueueSetHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A version of xQueueSelectFromSet() that can be used from an ISR. </p>
</dd></dl>

</div>
<div class="section" id="id3">
<h3>Macros<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.xQueueCreate">
<span class="target" id="queue_8h_1aeb858b824bd74a934ea7ebb81af2a6bb"></span><code class="descname">xQueueCreate</code><span class="sig-paren">(</span>uxQueueLength, uxItemSize<span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueCreate" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new queue instance. This allocates the storage required by the new queue and returns a handle for the queue.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">AMessage</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">ucMessageID</span><span class="p">;</span>
<span class="n">char</span> <span class="n">ucData</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>
<span class="p">};</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">QueueHandle_t</span> <span class="n">xQueue1</span><span class="p">,</span> <span class="n">xQueue2</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">uint32_t</span> <span class="n">values</span><span class="o">.</span>
<span class="n">xQueue1</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">uint32_t</span> <span class="p">)</span> <span class="p">);</span>
<span class="k">if</span><span class="p">(</span> <span class="n">xQueue1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Queue</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">created</span> <span class="ow">and</span> <span class="n">must</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">AMessage</span> <span class="n">structures</span><span class="o">.</span>
<span class="o">//</span> <span class="n">These</span> <span class="n">should</span> <span class="n">be</span> <span class="n">passed</span> <span class="n">by</span> <span class="n">pointer</span> <span class="k">as</span> <span class="n">they</span> <span class="n">contain</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">of</span> <span class="n">data</span><span class="o">.</span>
<span class="n">xQueue2</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>
<span class="k">if</span><span class="p">(</span> <span class="n">xQueue2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Queue</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">created</span> <span class="ow">and</span> <span class="n">must</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
<span class="p">}</span>

<span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If the queue is successfully create then a handle to the newly created queue is returned. If the queue cannot be created then 0 is returned.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">uxQueueLength</span></code>: The maximum number of items that the queue can contain.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxItemSize</span></code>: The number of bytes each item in the queue will require. Items are queued by copy, not by reference, so this is the number of bytes that will be copied for each posted item. Each item on the queue must be the same size.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xQueueCreateStatic">
<span class="target" id="queue_8h_1a867bd68852e9eea7206d364a7e165e57"></span><code class="descname">xQueueCreateStatic</code><span class="sig-paren">(</span>uxQueueLength, uxItemSize, pucQueueStorage, pxQueueBuffer<span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueCreateStatic" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new queue instance, and returns a handle by which the new queue can be referenced.</p>
<p>Internally, within the FreeRTOS implementation, queues use two blocks of memory. The first block is used to hold the queue’s data structures. The second block is used to hold items placed into the queue. If a queue is created using xQueueCreate() then both blocks of memory are automatically dynamically allocated inside the xQueueCreate() function. (see <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). If a queue is created using xQueueCreateStatic() then the application writer must provide the memory that will get used by the queue. xQueueCreateStatic() therefore allows a queue to be created without using any dynamic memory allocation.</p>
<p><a class="reference external" href="http://www.freertos.org/Embedded-RTOS-Queues.html">http://www.FreeRTOS.org/Embedded-RTOS-Queues.html</a></p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">AMessage</span>
<span class="p">{</span>
 <span class="n">char</span> <span class="n">ucMessageID</span><span class="p">;</span>
 <span class="n">char</span> <span class="n">ucData</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>
<span class="p">};</span>

<span class="c1">#define QUEUE_LENGTH 10</span>
<span class="c1">#define ITEM_SIZE sizeof( uint32_t )</span>

<span class="o">//</span> <span class="n">xQueueBuffer</span> <span class="n">will</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">structure</span><span class="o">.</span>
<span class="n">StaticQueue_t</span> <span class="n">xQueueBuffer</span><span class="p">;</span>

<span class="o">//</span> <span class="n">ucQueueStorage</span> <span class="n">will</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">items</span> <span class="n">posted</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span><span class="o">.</span>  <span class="n">Must</span> <span class="n">be</span> <span class="n">at</span> <span class="n">least</span>
<span class="o">//</span> <span class="p">[(</span><span class="n">queue</span> <span class="n">length</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span> <span class="n">queue</span> <span class="n">item</span> <span class="n">size</span><span class="p">)]</span> <span class="nb">bytes</span> <span class="n">long</span><span class="o">.</span>
<span class="n">uint8_t</span> <span class="n">ucQueueStorage</span><span class="p">[</span> <span class="n">QUEUE_LENGTH</span> <span class="o">*</span> <span class="n">ITEM_SIZE</span> <span class="p">];</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
 <span class="n">QueueHandle_t</span> <span class="n">xQueue1</span><span class="p">;</span>

 <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">uint32_t</span> <span class="n">values</span><span class="o">.</span>
 <span class="n">xQueue1</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="n">QUEUE_LENGTH</span><span class="p">,</span> <span class="o">//</span> <span class="n">The</span> <span class="n">number</span> <span class="n">of</span> <span class="n">items</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">can</span> <span class="n">hold</span><span class="o">.</span>
                         <span class="n">ITEM_SIZE</span>     <span class="o">//</span> <span class="n">The</span> <span class="n">size</span> <span class="n">of</span> <span class="n">each</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">queue</span>
                         <span class="o">&amp;</span><span class="p">(</span> <span class="n">ucQueueStorage</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">),</span> <span class="o">//</span> <span class="n">The</span> <span class="n">buffer</span> <span class="n">that</span> <span class="n">will</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">items</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">queue</span><span class="o">.</span>
                         <span class="o">&amp;</span><span class="n">xQueueBuffer</span> <span class="p">);</span> <span class="o">//</span> <span class="n">The</span> <span class="n">buffer</span> <span class="n">that</span> <span class="n">will</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">structure</span><span class="o">.</span>

 <span class="o">//</span> <span class="n">The</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">guaranteed</span> <span class="n">to</span> <span class="n">be</span> <span class="n">created</span> <span class="n">successfully</span> <span class="k">as</span> <span class="n">no</span> <span class="n">dynamic</span> <span class="n">memory</span>
 <span class="o">//</span> <span class="n">allocation</span> <span class="ow">is</span> <span class="n">used</span><span class="o">.</span>  <span class="n">Therefore</span> <span class="n">xQueue1</span> <span class="ow">is</span> <span class="n">now</span> <span class="n">a</span> <span class="n">handle</span> <span class="n">to</span> <span class="n">a</span> <span class="n">valid</span> <span class="n">queue</span><span class="o">.</span>

 <span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If the queue is created then a handle to the created queue is returned. If pxQueueBuffer is NULL then NULL is returned.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">uxQueueLength</span></code>: The maximum number of items that the queue can contain.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxItemSize</span></code>: The number of bytes each item in the queue will require. Items are queued by copy, not by reference, so this is the number of bytes that will be copied for each posted item. Each item on the queue must be the same size.</li>
<li><code class="docutils literal notranslate"><span class="pre">pucQueueStorage</span></code>: If uxItemSize is not zero then pucQueueStorageBuffer must point to a uint8_t array that is at least large enough to hold the maximum number of items that can be in the queue at any one time - which is ( uxQueueLength * uxItemsSize ) bytes. If uxItemSize is zero then pucQueueStorageBuffer can be NULL.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxQueueBuffer</span></code>: Must point to a variable of type StaticQueue_t, which will be used to hold the queue’s data structure.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xQueueSendToFront">
<span class="target" id="queue_8h_1aa612fcc2b1ceee0200f34b942e300b41"></span><code class="descname">xQueueSendToFront</code><span class="sig-paren">(</span>xQueue, pvItemToQueue, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueSendToFront" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a macro that calls xQueueGenericSend().</p>
<p>Post an item to the front of a queue. The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See xQueueSendFromISR () for an alternative which may be used in an ISR.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">AMessage</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">ucMessageID</span><span class="p">;</span>
<span class="n">char</span> <span class="n">ucData</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>
<span class="p">}</span> <span class="n">xMessage</span><span class="p">;</span>

<span class="n">uint32_t</span> <span class="n">ulVar</span> <span class="o">=</span> <span class="mi">10</span><span class="n">UL</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">QueueHandle_t</span> <span class="n">xQueue1</span><span class="p">,</span> <span class="n">xQueue2</span><span class="p">;</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">uint32_t</span> <span class="n">values</span><span class="o">.</span>
<span class="n">xQueue1</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">uint32_t</span> <span class="p">)</span> <span class="p">);</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">AMessage</span> <span class="n">structures</span><span class="o">.</span>
<span class="o">//</span> <span class="n">These</span> <span class="n">should</span> <span class="n">be</span> <span class="n">passed</span> <span class="n">by</span> <span class="n">pointer</span> <span class="k">as</span> <span class="n">they</span> <span class="n">contain</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">of</span> <span class="n">data</span><span class="o">.</span>
<span class="n">xQueue2</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>

<span class="o">//</span> <span class="o">...</span>

<span class="k">if</span><span class="p">(</span> <span class="n">xQueue1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Send</span> <span class="n">an</span> <span class="n">uint32_t</span><span class="o">.</span>  <span class="n">Wait</span> <span class="k">for</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="k">for</span> <span class="n">space</span> <span class="n">to</span> <span class="n">become</span>
    <span class="o">//</span> <span class="n">available</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xQueueSendToFront</span><span class="p">(</span> <span class="n">xQueue1</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">ulVar</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">post</span> <span class="n">the</span> <span class="n">message</span><span class="p">,</span> <span class="n">even</span> <span class="n">after</span> <span class="mi">10</span> <span class="n">ticks</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span><span class="p">(</span> <span class="n">xQueue2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Send</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="nb">object</span><span class="o">.</span>  <span class="n">Don</span><span class="s1">&#39;t block if the</span>
    <span class="o">//</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">full</span><span class="o">.</span>
    <span class="n">pxMessage</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">xMessage</span><span class="p">;</span>
    <span class="n">xQueueSendToFront</span><span class="p">(</span> <span class="n">xQueue2</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">0</span> <span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The handle to the queue on which the item is to be posted.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>: A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xQueueSendToBack">
<span class="target" id="queue_8h_1a81d24a2c1199d58efb76fbee15853112"></span><code class="descname">xQueueSendToBack</code><span class="sig-paren">(</span>xQueue, pvItemToQueue, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueSendToBack" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a macro that calls xQueueGenericSend().</p>
<p>Post an item to the back of a queue. The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See xQueueSendFromISR () for an alternative which may be used in an ISR.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">AMessage</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">ucMessageID</span><span class="p">;</span>
<span class="n">char</span> <span class="n">ucData</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>
<span class="p">}</span> <span class="n">xMessage</span><span class="p">;</span>

<span class="n">uint32_t</span> <span class="n">ulVar</span> <span class="o">=</span> <span class="mi">10</span><span class="n">UL</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">QueueHandle_t</span> <span class="n">xQueue1</span><span class="p">,</span> <span class="n">xQueue2</span><span class="p">;</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">uint32_t</span> <span class="n">values</span><span class="o">.</span>
<span class="n">xQueue1</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">uint32_t</span> <span class="p">)</span> <span class="p">);</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">AMessage</span> <span class="n">structures</span><span class="o">.</span>
<span class="o">//</span> <span class="n">These</span> <span class="n">should</span> <span class="n">be</span> <span class="n">passed</span> <span class="n">by</span> <span class="n">pointer</span> <span class="k">as</span> <span class="n">they</span> <span class="n">contain</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">of</span> <span class="n">data</span><span class="o">.</span>
<span class="n">xQueue2</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>

<span class="o">//</span> <span class="o">...</span>

<span class="k">if</span><span class="p">(</span> <span class="n">xQueue1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Send</span> <span class="n">an</span> <span class="n">uint32_t</span><span class="o">.</span>  <span class="n">Wait</span> <span class="k">for</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="k">for</span> <span class="n">space</span> <span class="n">to</span> <span class="n">become</span>
    <span class="o">//</span> <span class="n">available</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xQueueSendToBack</span><span class="p">(</span> <span class="n">xQueue1</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">ulVar</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">post</span> <span class="n">the</span> <span class="n">message</span><span class="p">,</span> <span class="n">even</span> <span class="n">after</span> <span class="mi">10</span> <span class="n">ticks</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span><span class="p">(</span> <span class="n">xQueue2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Send</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="nb">object</span><span class="o">.</span>  <span class="n">Don</span><span class="s1">&#39;t block if the</span>
    <span class="o">//</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">full</span><span class="o">.</span>
    <span class="n">pxMessage</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">xMessage</span><span class="p">;</span>
    <span class="n">xQueueSendToBack</span><span class="p">(</span> <span class="n">xQueue2</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">0</span> <span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The handle to the queue on which the item is to be posted.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>: A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xQueueSend">
<span class="target" id="queue_8h_1af7eb49d3249351176992950d9185abe9"></span><code class="descname">xQueueSend</code><span class="sig-paren">(</span>xQueue, pvItemToQueue, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueSend" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a macro that calls xQueueGenericSend(). It is included for backward compatibility with versions of FreeRTOS.org that did not include the xQueueSendToFront() and xQueueSendToBack() macros. It is equivalent to xQueueSendToBack().</p>
<p>Post an item on a queue. The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See xQueueSendFromISR () for an alternative which may be used in an ISR.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">AMessage</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">ucMessageID</span><span class="p">;</span>
<span class="n">char</span> <span class="n">ucData</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>
<span class="p">}</span> <span class="n">xMessage</span><span class="p">;</span>

<span class="n">uint32_t</span> <span class="n">ulVar</span> <span class="o">=</span> <span class="mi">10</span><span class="n">UL</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">QueueHandle_t</span> <span class="n">xQueue1</span><span class="p">,</span> <span class="n">xQueue2</span><span class="p">;</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">uint32_t</span> <span class="n">values</span><span class="o">.</span>
<span class="n">xQueue1</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">uint32_t</span> <span class="p">)</span> <span class="p">);</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">AMessage</span> <span class="n">structures</span><span class="o">.</span>
<span class="o">//</span> <span class="n">These</span> <span class="n">should</span> <span class="n">be</span> <span class="n">passed</span> <span class="n">by</span> <span class="n">pointer</span> <span class="k">as</span> <span class="n">they</span> <span class="n">contain</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">of</span> <span class="n">data</span><span class="o">.</span>
<span class="n">xQueue2</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>

<span class="o">//</span> <span class="o">...</span>

<span class="k">if</span><span class="p">(</span> <span class="n">xQueue1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Send</span> <span class="n">an</span> <span class="n">uint32_t</span><span class="o">.</span>  <span class="n">Wait</span> <span class="k">for</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="k">for</span> <span class="n">space</span> <span class="n">to</span> <span class="n">become</span>
    <span class="o">//</span> <span class="n">available</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xQueueSend</span><span class="p">(</span> <span class="n">xQueue1</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">ulVar</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">post</span> <span class="n">the</span> <span class="n">message</span><span class="p">,</span> <span class="n">even</span> <span class="n">after</span> <span class="mi">10</span> <span class="n">ticks</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span><span class="p">(</span> <span class="n">xQueue2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Send</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="nb">object</span><span class="o">.</span>  <span class="n">Don</span><span class="s1">&#39;t block if the</span>
    <span class="o">//</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">full</span><span class="o">.</span>
    <span class="n">pxMessage</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">xMessage</span><span class="p">;</span>
    <span class="n">xQueueSend</span><span class="p">(</span> <span class="n">xQueue2</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">0</span> <span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The handle to the queue on which the item is to be posted.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>: A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xQueueOverwrite">
<span class="target" id="queue_8h_1a8e9ced123b5a0e37a36d3bbdb2e56b4e"></span><code class="descname">xQueueOverwrite</code><span class="sig-paren">(</span>xQueue, pvItemToQueue<span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueOverwrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Only for use with queues that have a length of one - so the queue is either empty or full.</p>
<p>Post an item on a queue. If the queue is already full then overwrite the value held in the queue. The item is queued by copy, not by reference.</p>
<p>This function must not be called from an interrupt service routine. See xQueueOverwriteFromISR () for an alternative which may be used in an ISR.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> void vFunction( void *pvParameters )
 {
 QueueHandle_t xQueue;
 uint32_t ulVarToSend, ulValReceived;

 // Create a queue to hold one uint32_t value.  It is strongly
 // recommended *not* to use xQueueOverwrite() on queues that can
 // contain more than one value, and doing so will trigger an assertion
 // if configASSERT() is defined.
 xQueue = xQueueCreate( 1, sizeof( uint32_t ) );

 // Write the value 10 to the queue using xQueueOverwrite().
 ulVarToSend = 10;
 xQueueOverwrite( xQueue, &amp;ulVarToSend );

 // Peeking the queue should now return 10, but leave the value 10 in
 // the queue.  A block time of zero is used as it is known that the
 // queue holds a value.
 ulValReceived = 0;
 xQueuePeek( xQueue, &amp;ulValReceived, 0 );

 if( ulValReceived != 10 )
 {
     // Error unless the item was removed by a different task.
 }

 // The queue is still full.  Use xQueueOverwrite() to overwrite the
 // value held in the queue with 100.
 ulVarToSend = 100;
 xQueueOverwrite( xQueue, &amp;ulVarToSend );

 // This time read from the queue, leaving the queue empty once more.
 // A block time of 0 is used again.
 xQueueReceive( xQueue, &amp;ulValReceived, 0 );

 // The value read should be the last value written, even though the
 // queue was already full when the value was written.
 if( ulValReceived != 100 )
 {
     // Error!
 }

 // ...
}
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>xQueueOverwrite() is a macro that calls xQueueGenericSend(), and therefore has the same return values as xQueueSendToFront(). However, pdPASS is the only value that can be returned because xQueueOverwrite() will write to the queue even when the queue is already full.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The handle of the queue to which the data is being sent.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>: A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xQueuePeek">
<span class="target" id="queue_8h_1a2df70733bb875477cd9614c5b3446257"></span><code class="descname">xQueuePeek</code><span class="sig-paren">(</span>xQueue, pvBuffer, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="#c.xQueuePeek" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a macro that calls the xQueueGenericReceive() function.</p>
<p>Receive an item from a queue without removing the item from the queue. The item is received by copy so a buffer of adequate size must be provided. The number of bytes copied into the buffer was defined when the queue was created.</p>
<p>Successfully received items remain on the queue so will be returned again by the next call, or a call to xQueueReceive().</p>
<p>This macro must not be used in an interrupt service routine. See xQueuePeekFromISR() for an alternative that can be called from an interrupt service routine.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">AMessage</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">ucMessageID</span><span class="p">;</span>
<span class="n">char</span> <span class="n">ucData</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>
<span class="p">}</span> <span class="n">xMessage</span><span class="p">;</span>

<span class="n">QueueHandle_t</span> <span class="n">xQueue</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Task</span> <span class="n">to</span> <span class="n">create</span> <span class="n">a</span> <span class="n">queue</span> <span class="ow">and</span> <span class="n">post</span> <span class="n">a</span> <span class="n">value</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">AMessage</span> <span class="n">structures</span><span class="o">.</span>
<span class="o">//</span> <span class="n">These</span> <span class="n">should</span> <span class="n">be</span> <span class="n">passed</span> <span class="n">by</span> <span class="n">pointer</span> <span class="k">as</span> <span class="n">they</span> <span class="n">contain</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">of</span> <span class="n">data</span><span class="o">.</span>
<span class="n">xQueue</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>
<span class="k">if</span><span class="p">(</span> <span class="n">xQueue</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">create</span> <span class="n">the</span> <span class="n">queue</span><span class="o">.</span>
<span class="p">}</span>

<span class="o">//</span> <span class="o">...</span>

<span class="o">//</span> <span class="n">Send</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="nb">object</span><span class="o">.</span>  <span class="n">Don</span><span class="s1">&#39;t block if the</span>
<span class="o">//</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">full</span><span class="o">.</span>
<span class="n">pxMessage</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">xMessage</span><span class="p">;</span>
<span class="n">xQueueSend</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">0</span> <span class="p">);</span>

<span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">Task</span> <span class="n">to</span> <span class="n">peek</span> <span class="n">the</span> <span class="n">data</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">queue</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vADifferentTask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxRxedMessage</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span> <span class="n">xQueue</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Peek</span> <span class="n">a</span> <span class="n">message</span> <span class="n">on</span> <span class="n">the</span> <span class="n">created</span> <span class="n">queue</span><span class="o">.</span>  <span class="n">Block</span> <span class="k">for</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="k">if</span> <span class="n">a</span>
    <span class="o">//</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">immediately</span> <span class="n">available</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xQueuePeek</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span> <span class="n">pxRxedMessage</span> <span class="p">),</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">pcRxedMessage</span> <span class="n">now</span> <span class="n">points</span> <span class="n">to</span> <span class="n">the</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="n">variable</span> <span class="n">posted</span>
        <span class="o">//</span> <span class="n">by</span> <span class="n">vATask</span><span class="p">,</span> <span class="n">but</span> <span class="n">the</span> <span class="n">item</span> <span class="n">still</span> <span class="n">remains</span> <span class="n">on</span> <span class="n">the</span> <span class="n">queue</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The handle to the queue from which the item is to be received.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvBuffer</span></code>: Pointer to the buffer into which the received item will be copied.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: The maximum amount of time the task should block waiting for an item to receive should the queue be empty at the time of the call. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required. xQueuePeek() will return immediately if xTicksToWait is 0 and the queue is empty.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xQueueReceive">
<span class="target" id="queue_8h_1af1549eac0e7f05694a59a0b967c80be3"></span><code class="descname">xQueueReceive</code><span class="sig-paren">(</span>xQueue, pvBuffer, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueReceive" title="Permalink to this definition">¶</a></dt>
<dd><p>queue. h </p>
<p>This is a macro that calls the xQueueGenericReceive() function.</p>
<p>Receive an item from a queue. The item is received by copy so a buffer of adequate size must be provided. The number of bytes copied into the buffer was defined when the queue was created.</p>
<p>Successfully received items are removed from the queue.</p>
<p>This function must not be used in an interrupt service routine. See xQueueReceiveFromISR for an alternative that can.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">AMessage</span>
<span class="p">{</span>
 <span class="n">char</span> <span class="n">ucMessageID</span><span class="p">;</span>
 <span class="n">char</span> <span class="n">ucData</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>
<span class="p">}</span> <span class="n">xMessage</span><span class="p">;</span>

<span class="n">QueueHandle_t</span> <span class="n">xQueue</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Task</span> <span class="n">to</span> <span class="n">create</span> <span class="n">a</span> <span class="n">queue</span> <span class="ow">and</span> <span class="n">post</span> <span class="n">a</span> <span class="n">value</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

 <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">AMessage</span> <span class="n">structures</span><span class="o">.</span>
 <span class="o">//</span> <span class="n">These</span> <span class="n">should</span> <span class="n">be</span> <span class="n">passed</span> <span class="n">by</span> <span class="n">pointer</span> <span class="k">as</span> <span class="n">they</span> <span class="n">contain</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">of</span> <span class="n">data</span><span class="o">.</span>
 <span class="n">xQueue</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>
 <span class="k">if</span><span class="p">(</span> <span class="n">xQueue</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
 <span class="p">{</span>
     <span class="o">//</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">create</span> <span class="n">the</span> <span class="n">queue</span><span class="o">.</span>
 <span class="p">}</span>

 <span class="o">//</span> <span class="o">...</span>

 <span class="o">//</span> <span class="n">Send</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="nb">object</span><span class="o">.</span>  <span class="n">Don</span><span class="s1">&#39;t block if the</span>
 <span class="o">//</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">full</span><span class="o">.</span>
 <span class="n">pxMessage</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">xMessage</span><span class="p">;</span>
 <span class="n">xQueueSend</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">0</span> <span class="p">);</span>

 <span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">Task</span> <span class="n">to</span> <span class="n">receive</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">queue</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vADifferentTask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxRxedMessage</span><span class="p">;</span>

 <span class="k">if</span><span class="p">(</span> <span class="n">xQueue</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
 <span class="p">{</span>
     <span class="o">//</span> <span class="n">Receive</span> <span class="n">a</span> <span class="n">message</span> <span class="n">on</span> <span class="n">the</span> <span class="n">created</span> <span class="n">queue</span><span class="o">.</span>  <span class="n">Block</span> <span class="k">for</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="k">if</span> <span class="n">a</span>
     <span class="o">//</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">immediately</span> <span class="n">available</span><span class="o">.</span>
     <span class="k">if</span><span class="p">(</span> <span class="n">xQueueReceive</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span> <span class="n">pxRxedMessage</span> <span class="p">),</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">)</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">pcRxedMessage</span> <span class="n">now</span> <span class="n">points</span> <span class="n">to</span> <span class="n">the</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="n">variable</span> <span class="n">posted</span>
         <span class="o">//</span> <span class="n">by</span> <span class="n">vATask</span><span class="o">.</span>
     <span class="p">}</span>
 <span class="p">}</span>

 <span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The handle to the queue from which the item is to be received.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvBuffer</span></code>: Pointer to the buffer into which the received item will be copied.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: The maximum amount of time the task should block waiting for an item to receive should the queue be empty at the time of the call. xQueueReceive() will return immediately if xTicksToWait is zero and the queue is empty. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xQueueSendToFrontFromISR">
<span class="target" id="queue_8h_1af03b83396462affe9e28302660e7b9c6"></span><code class="descname">xQueueSendToFrontFromISR</code><span class="sig-paren">(</span>xQueue, pvItemToQueue, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueSendToFrontFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a macro that calls xQueueGenericSendFromISR().</p>
<p>Post an item to the front of a queue. It is safe to use this macro from within an interrupt service routine.</p>
<p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p>
<p><p>Example usage for buffered IO (where the ISR can obtain more than one value per call): </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vBufferISR</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">cIn</span><span class="p">;</span>
<span class="n">BaseType_t</span> <span class="n">xHigherPrioritTaskWoken</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">We</span> <span class="n">have</span> <span class="ow">not</span> <span class="n">woken</span> <span class="n">a</span> <span class="n">task</span> <span class="n">at</span> <span class="n">the</span> <span class="n">start</span> <span class="n">of</span> <span class="n">the</span> <span class="n">ISR</span><span class="o">.</span>
   <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">Loop</span> <span class="n">until</span> <span class="n">the</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="n">empty</span><span class="o">.</span>
   <span class="n">do</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">Obtain</span> <span class="n">a</span> <span class="n">byte</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">buffer</span><span class="o">.</span>
       <span class="n">cIn</span> <span class="o">=</span> <span class="n">portINPUT_BYTE</span><span class="p">(</span> <span class="n">RX_REGISTER_ADDRESS</span> <span class="p">);</span>

       <span class="o">//</span> <span class="n">Post</span> <span class="n">the</span> <span class="n">byte</span><span class="o">.</span>
       <span class="n">xQueueSendToFrontFromISR</span><span class="p">(</span> <span class="n">xRxQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cIn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">);</span>

   <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="n">portINPUT_BYTE</span><span class="p">(</span> <span class="n">BUFFER_COUNT</span> <span class="p">)</span> <span class="p">);</span>

   <span class="o">//</span> <span class="n">Now</span> <span class="n">the</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="n">empty</span> <span class="n">we</span> <span class="n">can</span> <span class="n">switch</span> <span class="n">context</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>
   <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="n">portYIELD_FROM_ISR</span> <span class="p">();</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The handle to the queue on which the item is to be posted.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>: A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>: xQueueSendToFrontFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendToFromFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xQueueSendToBackFromISR">
<span class="target" id="queue_8h_1a51e9f73417b11441a181cdc4f33a68e9"></span><code class="descname">xQueueSendToBackFromISR</code><span class="sig-paren">(</span>xQueue, pvItemToQueue, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueSendToBackFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a macro that calls xQueueGenericSendFromISR().</p>
<p>Post an item to the back of a queue. It is safe to use this macro from within an interrupt service routine.</p>
<p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p>
<p><p>Example usage for buffered IO (where the ISR can obtain more than one value per call): </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vBufferISR</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">cIn</span><span class="p">;</span>
<span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWoken</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">We</span> <span class="n">have</span> <span class="ow">not</span> <span class="n">woken</span> <span class="n">a</span> <span class="n">task</span> <span class="n">at</span> <span class="n">the</span> <span class="n">start</span> <span class="n">of</span> <span class="n">the</span> <span class="n">ISR</span><span class="o">.</span>
   <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">Loop</span> <span class="n">until</span> <span class="n">the</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="n">empty</span><span class="o">.</span>
   <span class="n">do</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">Obtain</span> <span class="n">a</span> <span class="n">byte</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">buffer</span><span class="o">.</span>
       <span class="n">cIn</span> <span class="o">=</span> <span class="n">portINPUT_BYTE</span><span class="p">(</span> <span class="n">RX_REGISTER_ADDRESS</span> <span class="p">);</span>

       <span class="o">//</span> <span class="n">Post</span> <span class="n">the</span> <span class="n">byte</span><span class="o">.</span>
       <span class="n">xQueueSendToBackFromISR</span><span class="p">(</span> <span class="n">xRxQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cIn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">);</span>

   <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="n">portINPUT_BYTE</span><span class="p">(</span> <span class="n">BUFFER_COUNT</span> <span class="p">)</span> <span class="p">);</span>

   <span class="o">//</span> <span class="n">Now</span> <span class="n">the</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="n">empty</span> <span class="n">we</span> <span class="n">can</span> <span class="n">switch</span> <span class="n">context</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>
   <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="n">portYIELD_FROM_ISR</span> <span class="p">();</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The handle to the queue on which the item is to be posted.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>: A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>: xQueueSendToBackFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendToBackFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xQueueOverwriteFromISR">
<span class="target" id="queue_8h_1abdcd6a86ef82034d002193e79cfd3ce8"></span><code class="descname">xQueueOverwriteFromISR</code><span class="sig-paren">(</span>xQueue, pvItemToQueue, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueOverwriteFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>A version of xQueueOverwrite() that can be used in an interrupt service routine (ISR).</p>
<p>Only for use with queues that can hold a single item - so the queue is either empty or full.</p>
<p>Post an item on a queue. If the queue is already full then overwrite the value held in the queue. The item is queued by copy, not by reference.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="n">QueueHandle_t</span> <span class="n">xQueue</span><span class="p">;</span>

 <span class="n">void</span> <span class="n">vFunction</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
 <span class="p">{</span>
    <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">one</span> <span class="n">uint32_t</span> <span class="n">value</span><span class="o">.</span>  <span class="n">It</span> <span class="ow">is</span> <span class="n">strongly</span>
    <span class="o">//</span> <span class="n">recommended</span> <span class="o">*</span><span class="ow">not</span><span class="o">*</span> <span class="n">to</span> <span class="n">use</span> <span class="n">xQueueOverwriteFromISR</span><span class="p">()</span> <span class="n">on</span> <span class="n">queues</span> <span class="n">that</span> <span class="n">can</span>
    <span class="o">//</span> <span class="n">contain</span> <span class="n">more</span> <span class="n">than</span> <span class="n">one</span> <span class="n">value</span><span class="p">,</span> <span class="ow">and</span> <span class="n">doing</span> <span class="n">so</span> <span class="n">will</span> <span class="n">trigger</span> <span class="n">an</span> <span class="n">assertion</span>
    <span class="o">//</span> <span class="k">if</span> <span class="n">configASSERT</span><span class="p">()</span> <span class="ow">is</span> <span class="n">defined</span><span class="o">.</span>
    <span class="n">xQueue</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">uint32_t</span> <span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">vAnInterruptHandler</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="o">//</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">must</span> <span class="n">be</span> <span class="nb">set</span> <span class="n">to</span> <span class="n">pdFALSE</span> <span class="n">before</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">used</span><span class="o">.</span>
<span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>
<span class="n">uint32_t</span> <span class="n">ulVarToSend</span><span class="p">,</span> <span class="n">ulValReceived</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Write</span> <span class="n">the</span> <span class="n">value</span> <span class="mi">10</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">using</span> <span class="n">xQueueOverwriteFromISR</span><span class="p">()</span><span class="o">.</span>
    <span class="n">ulVarToSend</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">xQueueOverwriteFromISR</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ulVarToSend</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">);</span>

    <span class="o">//</span> <span class="n">The</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">full</span><span class="p">,</span> <span class="n">but</span> <span class="n">calling</span> <span class="n">xQueueOverwriteFromISR</span><span class="p">()</span> <span class="n">again</span> <span class="n">will</span> <span class="n">still</span>
    <span class="o">//</span> <span class="k">pass</span> <span class="n">because</span> <span class="n">the</span> <span class="n">value</span> <span class="n">held</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">will</span> <span class="n">be</span> <span class="n">overwritten</span> <span class="k">with</span> <span class="n">the</span>
    <span class="o">//</span> <span class="n">new</span> <span class="n">value</span><span class="o">.</span>
    <span class="n">ulVarToSend</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">xQueueOverwriteFromISR</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ulVarToSend</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">);</span>

    <span class="o">//</span> <span class="n">Reading</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">queue</span> <span class="n">will</span> <span class="n">now</span> <span class="k">return</span> <span class="mf">100.</span>

    <span class="o">//</span> <span class="o">...</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPrioritytaskWoken</span> <span class="o">==</span> <span class="n">pdTRUE</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Writing</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">caused</span> <span class="n">a</span> <span class="n">task</span> <span class="n">to</span> <span class="n">unblock</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">unblocked</span> <span class="n">task</span>
        <span class="o">//</span> <span class="n">has</span> <span class="n">a</span> <span class="n">priority</span> <span class="n">higher</span> <span class="n">than</span> <span class="ow">or</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">the</span> <span class="n">priority</span> <span class="n">of</span> <span class="n">the</span> <span class="n">currently</span>
        <span class="o">//</span> <span class="n">executing</span> <span class="n">task</span> <span class="p">(</span><span class="n">the</span> <span class="n">task</span> <span class="n">this</span> <span class="n">interrupt</span> <span class="n">interrupted</span><span class="p">)</span><span class="o">.</span>  <span class="n">Perform</span> <span class="n">a</span> <span class="n">context</span>
        <span class="o">//</span> <span class="n">switch</span> <span class="n">so</span> <span class="n">this</span> <span class="n">interrupt</span> <span class="n">returns</span> <span class="n">directly</span> <span class="n">to</span> <span class="n">the</span> <span class="n">unblocked</span> <span class="n">task</span><span class="o">.</span>
        <span class="n">portYIELD_FROM_ISR</span><span class="p">();</span> <span class="o">//</span> <span class="ow">or</span> <span class="n">portEND_SWITCHING_ISR</span><span class="p">()</span> <span class="n">depending</span> <span class="n">on</span> <span class="n">the</span> <span class="n">port</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>xQueueOverwriteFromISR() is a macro that calls xQueueGenericSendFromISR(), and therefore has the same return values as xQueueSendToFrontFromISR(). However, pdPASS is the only value that can be returned because xQueueOverwriteFromISR() will write to the queue even when the queue is already full.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The handle to the queue on which the item is to be posted.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>: A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>: xQueueOverwriteFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueOverwriteFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xQueueSendFromISR">
<span class="target" id="queue_8h_1a21d5919ed26c21d121df4a4debeb643c"></span><code class="descname">xQueueSendFromISR</code><span class="sig-paren">(</span>xQueue, pvItemToQueue, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueSendFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a macro that calls xQueueGenericSendFromISR(). It is included for backward compatibility with versions of FreeRTOS.org that did not include the xQueueSendToBackFromISR() and xQueueSendToFrontFromISR() macros.</p>
<p>Post an item to the back of a queue. It is safe to use this function from within an interrupt service routine.</p>
<p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p>
<p><p>Example usage for buffered IO (where the ISR can obtain more than one value per call): </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vBufferISR</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">cIn</span><span class="p">;</span>
<span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWoken</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">We</span> <span class="n">have</span> <span class="ow">not</span> <span class="n">woken</span> <span class="n">a</span> <span class="n">task</span> <span class="n">at</span> <span class="n">the</span> <span class="n">start</span> <span class="n">of</span> <span class="n">the</span> <span class="n">ISR</span><span class="o">.</span>
   <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">Loop</span> <span class="n">until</span> <span class="n">the</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="n">empty</span><span class="o">.</span>
   <span class="n">do</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">Obtain</span> <span class="n">a</span> <span class="n">byte</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">buffer</span><span class="o">.</span>
       <span class="n">cIn</span> <span class="o">=</span> <span class="n">portINPUT_BYTE</span><span class="p">(</span> <span class="n">RX_REGISTER_ADDRESS</span> <span class="p">);</span>

       <span class="o">//</span> <span class="n">Post</span> <span class="n">the</span> <span class="n">byte</span><span class="o">.</span>
       <span class="n">xQueueSendFromISR</span><span class="p">(</span> <span class="n">xRxQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cIn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">);</span>

   <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="n">portINPUT_BYTE</span><span class="p">(</span> <span class="n">BUFFER_COUNT</span> <span class="p">)</span> <span class="p">);</span>

   <span class="o">//</span> <span class="n">Now</span> <span class="n">the</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="n">empty</span> <span class="n">we</span> <span class="n">can</span> <span class="n">switch</span> <span class="n">context</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>
   <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">Actual</span> <span class="n">macro</span> <span class="n">used</span> <span class="n">here</span> <span class="ow">is</span> <span class="n">port</span> <span class="n">specific</span><span class="o">.</span>
       <span class="n">portYIELD_FROM_ISR</span> <span class="p">();</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The handle to the queue on which the item is to be posted.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>: A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>: xQueueSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xQueueReset">
<span class="target" id="queue_8h_1a94df8d8bc938424151f8196db2f1177b"></span><code class="descname">xQueueReset</code><span class="sig-paren">(</span>xQueue<span class="sig-paren">)</span><a class="headerlink" href="#c.xQueueReset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset a queue back to its original empty state. pdPASS is returned if the queue is successfully reset. pdFAIL is returned if the queue could not be reset because there are tasks blocked on the queue waiting to either receive from the queue or send to the queue.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>always returns pdPASS </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: The queue to reset </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="id4">
<h3>Type Definitions<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv413QueueHandle_t">
<span id="_CPPv313QueueHandle_t"></span><span id="_CPPv213QueueHandle_t"></span><span id="QueueHandle_t"></span><span class="target" id="queue_8h_1aaf19d499892a4ce1409326ece00f5264"></span><em class="property">typedef </em>void *<code class="descname">QueueHandle_t</code><a class="headerlink" href="#_CPPv413QueueHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type by which queues are referenced. For example, a call to xQueueCreate() returns an QueueHandle_t variable that can then be used as a parameter to xQueueSend(), xQueueReceive(), etc. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv416QueueSetHandle_t">
<span id="_CPPv316QueueSetHandle_t"></span><span id="_CPPv216QueueSetHandle_t"></span><span id="QueueSetHandle_t"></span><span class="target" id="queue_8h_1a32a86d604e1706d72a5a4c62d8262f56"></span><em class="property">typedef </em>void *<code class="descname">QueueSetHandle_t</code><a class="headerlink" href="#_CPPv416QueueSetHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type by which queue sets are referenced. For example, a call to xQueueCreateSet() returns an xQueueSet variable that can then be used as a parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv422QueueSetMemberHandle_t">
<span id="_CPPv322QueueSetMemberHandle_t"></span><span id="_CPPv222QueueSetMemberHandle_t"></span><span id="QueueSetMemberHandle_t"></span><span class="target" id="queue_8h_1a6c19a940d8fe07d338928ecea68b1776"></span><em class="property">typedef </em>void *<code class="descname">QueueSetMemberHandle_t</code><a class="headerlink" href="#_CPPv422QueueSetMemberHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Queue sets can contain both queues and semaphores, so the QueueSetMemberHandle_t is defined as a type to be used where a parameter or return value can be either an QueueHandle_t or an SemaphoreHandle_t. </p>
</dd></dl>

</div>
</div>
<div class="section" id="semaphore-api">
<h2>Semaphore API<a class="headerlink" href="#semaphore-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id5">
<h3>Header File<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/freertos/include/freertos/semphr.h">freertos/include/freertos/semphr.h</a></li>
</ul>
</div>
<div class="section" id="id6">
<h3>Macros<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.semBINARY_SEMAPHORE_QUEUE_LENGTH">
<span class="target" id="semphr_8h_1a73cfd14cf25a13f8dd4dc1d74b7fc04a"></span><code class="descname">semBINARY_SEMAPHORE_QUEUE_LENGTH</code><a class="headerlink" href="#c.semBINARY_SEMAPHORE_QUEUE_LENGTH" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.semSEMAPHORE_QUEUE_ITEM_LENGTH">
<span class="target" id="semphr_8h_1a93bd07e28aed3084bdafa1f4e99700b2"></span><code class="descname">semSEMAPHORE_QUEUE_ITEM_LENGTH</code><a class="headerlink" href="#c.semSEMAPHORE_QUEUE_ITEM_LENGTH" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.semGIVE_BLOCK_TIME">
<span class="target" id="semphr_8h_1a124bb5bd7805baa06fbd3239840d6803"></span><code class="descname">semGIVE_BLOCK_TIME</code><a class="headerlink" href="#c.semGIVE_BLOCK_TIME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.xSemaphoreCreateBinary">
<span class="target" id="semphr_8h_1acba963695e4f159d9bfa2394cae5badc"></span><code class="descname">xSemaphoreCreateBinary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreCreateBinary" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new binary semaphore instance, and returns a handle by which the new semaphore can be referenced.</p>
<p>In many usage scenarios it is faster and more memory efficient to use a direct to task notification in place of a binary semaphore! <a class="reference external" href="http://www.freertos.org/RTOS-task-notifications.html">http://www.freertos.org/RTOS-task-notifications.html</a></p>
<p>Internally, within the FreeRTOS implementation, binary semaphores use a block of memory, in which the semaphore structure is stored. If a binary semaphore is created using xSemaphoreCreateBinary() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateBinary() function. (see <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). If a binary semaphore is created using xSemaphoreCreateBinaryStatic() then the application writer must provide the memory. xSemaphoreCreateBinaryStatic() therefore allows a binary semaphore to be created without using any dynamic memory allocation.</p>
<p>The old vSemaphoreCreateBinary() macro is now deprecated in favour of this xSemaphoreCreateBinary() function. Note that binary semaphores created using the vSemaphoreCreateBinary() macro are created in a state such that the first call to ‘take’ the semaphore would pass, whereas binary semaphores created using xSemaphoreCreateBinary() are created in a state such that the the semaphore must first be ‘given’ before it can be ‘taken’.</p>
<p>Function that creates a semaphore by using the existing queue mechanism. The queue length is 1 as this is a binary semaphore. The data size is 0 as nothing is actually stored - all that is important is whether the queue is empty or full (the binary semaphore is available or not).</p>
<p>This type of semaphore can be used for pure synchronisation between tasks or between an interrupt and a task. The semaphore need not be given back once obtained, so one task/interrupt can continuously ‘give’ the semaphore while another continuously ‘takes’ the semaphore. For this reason this type of semaphore does not use a priority inheritance mechanism. For an alternative that does use priority inheritance see xSemaphoreCreateMutex().</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">Semaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span> <span class="n">before</span> <span class="n">a</span> <span class="n">call</span> <span class="n">to</span> <span class="n">vSemaphoreCreateBinary</span> <span class="p">()</span><span class="o">.</span>
   <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">macro</span> <span class="n">so</span> <span class="k">pass</span> <span class="n">the</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">directly</span><span class="o">.</span>
   <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">xSemaphoreCreateBinary</span><span class="p">();</span>

   <span class="k">if</span><span class="p">(</span> <span class="n">xSemaphore</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">The</span> <span class="n">semaphore</span> <span class="n">was</span> <span class="n">created</span> <span class="n">successfully</span><span class="o">.</span>
       <span class="o">//</span> <span class="n">The</span> <span class="n">semaphore</span> <span class="n">can</span> <span class="n">now</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Handle to the created semaphore.</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xSemaphoreCreateBinaryStatic">
<span class="target" id="semphr_8h_1a1a8fb8e7922ce5ced3b36f0c963393f1"></span><code class="descname">xSemaphoreCreateBinaryStatic</code><span class="sig-paren">(</span>pxStaticSemaphore<span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreCreateBinaryStatic" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new binary semaphore instance, and returns a handle by which the new semaphore can be referenced.</p>
<p>NOTE: In many usage scenarios it is faster and more memory efficient to use a direct to task notification in place of a binary semaphore! <a class="reference external" href="http://www.freertos.org/RTOS-task-notifications.html">http://www.freertos.org/RTOS-task-notifications.html</a></p>
<p>Internally, within the FreeRTOS implementation, binary semaphores use a block of memory, in which the semaphore structure is stored. If a binary semaphore is created using xSemaphoreCreateBinary() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateBinary() function. (see <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). If a binary semaphore is created using xSemaphoreCreateBinaryStatic() then the application writer must provide the memory. xSemaphoreCreateBinaryStatic() therefore allows a binary semaphore to be created without using any dynamic memory allocation.</p>
<p>This type of semaphore can be used for pure synchronisation between tasks or between an interrupt and a task. The semaphore need not be given back once obtained, so one task/interrupt can continuously ‘give’ the semaphore while another continuously ‘takes’ the semaphore. For this reason this type of semaphore does not use a priority inheritance mechanism. For an alternative that does use priority inheritance see xSemaphoreCreateMutex().</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
<span class="n">StaticSemaphore_t</span> <span class="n">xSemaphoreBuffer</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">Semaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span> <span class="n">before</span> <span class="n">a</span> <span class="n">call</span> <span class="n">to</span> <span class="n">xSemaphoreCreateBinary</span><span class="p">()</span><span class="o">.</span>
   <span class="o">//</span> <span class="n">The</span> <span class="n">semaphore</span><span class="s1">&#39;s data structures will be placed in the xSemaphoreBuffer</span>
   <span class="o">//</span> <span class="n">variable</span><span class="p">,</span> <span class="n">the</span> <span class="n">address</span> <span class="n">of</span> <span class="n">which</span> <span class="ow">is</span> <span class="n">passed</span> <span class="n">into</span> <span class="n">the</span> <span class="n">function</span><span class="o">.</span>  <span class="n">The</span>
   <span class="o">//</span> <span class="n">function</span><span class="s1">&#39;s parameter is not NULL, so the function will not attempt any</span>
   <span class="o">//</span> <span class="n">dynamic</span> <span class="n">memory</span> <span class="n">allocation</span><span class="p">,</span> <span class="ow">and</span> <span class="n">therefore</span> <span class="n">the</span> <span class="n">function</span> <span class="n">will</span> <span class="ow">not</span> <span class="k">return</span>
   <span class="o">//</span> <span class="k">return</span> <span class="n">NULL</span><span class="o">.</span>
   <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">xSemaphoreCreateBinary</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">xSemaphoreBuffer</span> <span class="p">);</span>

   <span class="o">//</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span> <span class="n">goes</span> <span class="n">here</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If the semaphore is created then a handle to the created semaphore is returned. If pxSemaphoreBuffer is NULL then NULL is returned.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pxStaticSemaphore</span></code>: Must point to a variable of type StaticSemaphore_t, which will then be used to hold the semaphore’s data structure, removing the need for the memory to be allocated dynamically.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xSemaphoreTake">
<span class="target" id="semphr_8h_1af116e436d2a5ae5bd72dbade2b5ea930"></span><code class="descname">xSemaphoreTake</code><span class="sig-paren">(</span>xSemaphore, xBlockTime<span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreTake" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Macro</em> to obtain a semaphore. The semaphore must have previously been created with a call to vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting().</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

<span class="o">//</span> <span class="n">A</span> <span class="n">task</span> <span class="n">that</span> <span class="n">creates</span> <span class="n">a</span> <span class="n">semaphore</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">semaphore</span> <span class="n">to</span> <span class="n">guard</span> <span class="n">a</span> <span class="n">shared</span> <span class="n">resource</span><span class="o">.</span>
   <span class="n">vSemaphoreCreateBinary</span><span class="p">(</span> <span class="n">xSemaphore</span> <span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">A</span> <span class="n">task</span> <span class="n">that</span> <span class="n">uses</span> <span class="n">the</span> <span class="n">semaphore</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vAnotherTask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="o">...</span> <span class="n">Do</span> <span class="n">other</span> <span class="n">things</span><span class="o">.</span>

   <span class="k">if</span><span class="p">(</span> <span class="n">xSemaphore</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">See</span> <span class="k">if</span> <span class="n">we</span> <span class="n">can</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">semaphore</span><span class="o">.</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">semaphore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">available</span>
       <span class="o">//</span> <span class="n">wait</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="n">to</span> <span class="n">see</span> <span class="k">if</span> <span class="n">it</span> <span class="n">becomes</span> <span class="n">free</span><span class="o">.</span>
       <span class="k">if</span><span class="p">(</span> <span class="n">xSemaphoreTake</span><span class="p">(</span> <span class="n">xSemaphore</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">)</span> <span class="o">==</span> <span class="n">pdTRUE</span> <span class="p">)</span>
       <span class="p">{</span>
           <span class="o">//</span> <span class="n">We</span> <span class="n">were</span> <span class="n">able</span> <span class="n">to</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">semaphore</span> <span class="ow">and</span> <span class="n">can</span> <span class="n">now</span> <span class="n">access</span> <span class="n">the</span>
           <span class="o">//</span> <span class="n">shared</span> <span class="n">resource</span><span class="o">.</span>

           <span class="o">//</span> <span class="o">...</span>

           <span class="o">//</span> <span class="n">We</span> <span class="n">have</span> <span class="n">finished</span> <span class="n">accessing</span> <span class="n">the</span> <span class="n">shared</span> <span class="n">resource</span><span class="o">.</span>  <span class="n">Release</span> <span class="n">the</span>
           <span class="o">//</span> <span class="n">semaphore</span><span class="o">.</span>
           <span class="n">xSemaphoreGive</span><span class="p">(</span> <span class="n">xSemaphore</span> <span class="p">);</span>
       <span class="p">}</span>
       <span class="k">else</span>
       <span class="p">{</span>
           <span class="o">//</span> <span class="n">We</span> <span class="n">could</span> <span class="ow">not</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">semaphore</span> <span class="ow">and</span> <span class="n">can</span> <span class="n">therefore</span> <span class="ow">not</span> <span class="n">access</span>
           <span class="o">//</span> <span class="n">the</span> <span class="n">shared</span> <span class="n">resource</span> <span class="n">safely</span><span class="o">.</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if the semaphore was obtained. pdFALSE if xBlockTime expired without the semaphore becoming available.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xSemaphore</span></code>: A handle to the semaphore being taken - obtained when the semaphore was created.</li>
<li><code class="docutils literal notranslate"><span class="pre">xBlockTime</span></code>: The time in ticks to wait for the semaphore to become available. The macro portTICK_PERIOD_MS can be used to convert this to a real time. A block time of zero can be used to poll the semaphore. A block time of portMAX_DELAY can be used to block indefinitely (provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xSemaphoreTakeRecursive">
<span class="target" id="semphr_8h_1ad395f4bba51eea6af3397d72bc079e4d"></span><code class="descname">xSemaphoreTakeRecursive</code><span class="sig-paren">(</span>xMutex, xBlockTime<span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreTakeRecursive" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Macro</em> to recursively obtain, or ‘take’, a mutex type semaphore. The mutex must have previously been created using a call to xSemaphoreCreateRecursiveMutex();</p>
<p>configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this macro to be available.</p>
<p>This macro must not be used on mutexes created using xSemaphoreCreateMutex().</p>
<p>A mutex used recursively can be ‘taken’ repeatedly by the owner. The mutex doesn’t become available again until the owner has called xSemaphoreGiveRecursive() for each successful ‘take’ request. For example, if a task successfully ‘takes’ the same mutex 5 times then the mutex will not be available to any other task until it has also ‘given’ the mutex back exactly five times.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xMutex</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

<span class="o">//</span> <span class="n">A</span> <span class="n">task</span> <span class="n">that</span> <span class="n">creates</span> <span class="n">a</span> <span class="n">mutex</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">mutex</span> <span class="n">to</span> <span class="n">guard</span> <span class="n">a</span> <span class="n">shared</span> <span class="n">resource</span><span class="o">.</span>
   <span class="n">xMutex</span> <span class="o">=</span> <span class="n">xSemaphoreCreateRecursiveMutex</span><span class="p">();</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">A</span> <span class="n">task</span> <span class="n">that</span> <span class="n">uses</span> <span class="n">the</span> <span class="n">mutex</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vAnotherTask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="o">...</span> <span class="n">Do</span> <span class="n">other</span> <span class="n">things</span><span class="o">.</span>

   <span class="k">if</span><span class="p">(</span> <span class="n">xMutex</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">See</span> <span class="k">if</span> <span class="n">we</span> <span class="n">can</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">mutex</span><span class="o">.</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">mutex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">available</span>
       <span class="o">//</span> <span class="n">wait</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="n">to</span> <span class="n">see</span> <span class="k">if</span> <span class="n">it</span> <span class="n">becomes</span> <span class="n">free</span><span class="o">.</span>
       <span class="k">if</span><span class="p">(</span> <span class="n">xSemaphoreTakeRecursive</span><span class="p">(</span> <span class="n">xSemaphore</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">)</span> <span class="o">==</span> <span class="n">pdTRUE</span> <span class="p">)</span>
       <span class="p">{</span>
           <span class="o">//</span> <span class="n">We</span> <span class="n">were</span> <span class="n">able</span> <span class="n">to</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">mutex</span> <span class="ow">and</span> <span class="n">can</span> <span class="n">now</span> <span class="n">access</span> <span class="n">the</span>
           <span class="o">//</span> <span class="n">shared</span> <span class="n">resource</span><span class="o">.</span>

           <span class="o">//</span> <span class="o">...</span>
           <span class="o">//</span> <span class="n">For</span> <span class="n">some</span> <span class="n">reason</span> <span class="n">due</span> <span class="n">to</span> <span class="n">the</span> <span class="n">nature</span> <span class="n">of</span> <span class="n">the</span> <span class="n">code</span> <span class="n">further</span> <span class="n">calls</span> <span class="n">to</span>
           <span class="o">//</span> <span class="n">xSemaphoreTakeRecursive</span><span class="p">()</span> <span class="n">are</span> <span class="n">made</span> <span class="n">on</span> <span class="n">the</span> <span class="n">same</span> <span class="n">mutex</span><span class="o">.</span>  <span class="n">In</span> <span class="n">real</span>
           <span class="o">//</span> <span class="n">code</span> <span class="n">these</span> <span class="n">would</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">just</span> <span class="n">sequential</span> <span class="n">calls</span> <span class="k">as</span> <span class="n">this</span> <span class="n">would</span> <span class="n">make</span>
           <span class="o">//</span> <span class="n">no</span> <span class="n">sense</span><span class="o">.</span>  <span class="n">Instead</span> <span class="n">the</span> <span class="n">calls</span> <span class="n">are</span> <span class="n">likely</span> <span class="n">to</span> <span class="n">be</span> <span class="n">buried</span> <span class="n">inside</span>
           <span class="o">//</span> <span class="n">a</span> <span class="n">more</span> <span class="nb">complex</span> <span class="n">call</span> <span class="n">structure</span><span class="o">.</span>
           <span class="n">xSemaphoreTakeRecursive</span><span class="p">(</span> <span class="n">xMutex</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">);</span>
           <span class="n">xSemaphoreTakeRecursive</span><span class="p">(</span> <span class="n">xMutex</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">);</span>

           <span class="o">//</span> <span class="n">The</span> <span class="n">mutex</span> <span class="n">has</span> <span class="n">now</span> <span class="n">been</span> <span class="s1">&#39;taken&#39;</span> <span class="n">three</span> <span class="n">times</span><span class="p">,</span> <span class="n">so</span> <span class="n">will</span> <span class="ow">not</span> <span class="n">be</span>
           <span class="o">//</span> <span class="n">available</span> <span class="n">to</span> <span class="n">another</span> <span class="n">task</span> <span class="n">until</span> <span class="n">it</span> <span class="n">has</span> <span class="n">also</span> <span class="n">been</span> <span class="n">given</span> <span class="n">back</span>
           <span class="o">//</span> <span class="n">three</span> <span class="n">times</span><span class="o">.</span>  <span class="n">Again</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">unlikely</span> <span class="n">that</span> <span class="n">real</span> <span class="n">code</span> <span class="n">would</span> <span class="n">have</span>
           <span class="o">//</span> <span class="n">these</span> <span class="n">calls</span> <span class="n">sequentially</span><span class="p">,</span> <span class="n">but</span> <span class="n">instead</span> <span class="n">buried</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">more</span> <span class="nb">complex</span>
           <span class="o">//</span> <span class="n">call</span> <span class="n">structure</span><span class="o">.</span>  <span class="n">This</span> <span class="ow">is</span> <span class="n">just</span> <span class="k">for</span> <span class="n">illustrative</span> <span class="n">purposes</span><span class="o">.</span>
           <span class="n">xSemaphoreGiveRecursive</span><span class="p">(</span> <span class="n">xMutex</span> <span class="p">);</span>
           <span class="n">xSemaphoreGiveRecursive</span><span class="p">(</span> <span class="n">xMutex</span> <span class="p">);</span>
           <span class="n">xSemaphoreGiveRecursive</span><span class="p">(</span> <span class="n">xMutex</span> <span class="p">);</span>

           <span class="o">//</span> <span class="n">Now</span> <span class="n">the</span> <span class="n">mutex</span> <span class="n">can</span> <span class="n">be</span> <span class="n">taken</span> <span class="n">by</span> <span class="n">other</span> <span class="n">tasks</span><span class="o">.</span>
       <span class="p">}</span>
       <span class="k">else</span>
       <span class="p">{</span>
           <span class="o">//</span> <span class="n">We</span> <span class="n">could</span> <span class="ow">not</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">mutex</span> <span class="ow">and</span> <span class="n">can</span> <span class="n">therefore</span> <span class="ow">not</span> <span class="n">access</span>
           <span class="o">//</span> <span class="n">the</span> <span class="n">shared</span> <span class="n">resource</span> <span class="n">safely</span><span class="o">.</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if the semaphore was obtained. pdFALSE if xBlockTime expired without the semaphore becoming available.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xMutex</span></code>: A handle to the mutex being obtained. This is the handle returned by xSemaphoreCreateRecursiveMutex();</li>
<li><code class="docutils literal notranslate"><span class="pre">xBlockTime</span></code>: The time in ticks to wait for the semaphore to become available. The macro portTICK_PERIOD_MS can be used to convert this to a real time. A block time of zero can be used to poll the semaphore. If the task already owns the semaphore then xSemaphoreTakeRecursive() will return immediately no matter what the value of xBlockTime.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xSemaphoreGive">
<span class="target" id="semphr_8h_1aae55761cabfa9bf85c8f4430f78c0953"></span><code class="descname">xSemaphoreGive</code><span class="sig-paren">(</span>xSemaphore<span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreGive" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Macro</em> to release a semaphore. The semaphore must have previously been created with a call to vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting(). and obtained using sSemaphoreTake().</p>
<p>This macro must not be used from an ISR. See xSemaphoreGiveFromISR () for an alternative which can be used from an ISR.</p>
<p>This macro must also not be used on semaphores created using xSemaphoreCreateRecursiveMutex().</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SemaphoreHandle_t xSemaphore = NULL;

void vATask( void * pvParameters )
{
   // Create the semaphore to guard a shared resource.
   vSemaphoreCreateBinary( xSemaphore );

   if( xSemaphore != NULL )
   {
       if( xSemaphoreGive( xSemaphore ) != pdTRUE )
       {
           // We would expect this call to fail because we cannot give
           // a semaphore without first &quot;taking&quot; it!
       }

       // Obtain the semaphore - don&#39;t block if the semaphore is not
       // immediately available.
       if( xSemaphoreTake( xSemaphore, ( TickType_t ) 0 ) )
       {
           // We now have the semaphore and can access the shared resource.

           // ...

           // We have finished accessing the shared resource so can free the
           // semaphore.
           if( xSemaphoreGive( xSemaphore ) != pdTRUE )
           {
               // We would not expect this call to fail because we must have
               // obtained the semaphore to get here.
           }
       }
   }
}
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if the semaphore was released. pdFALSE if an error occurred. Semaphores are implemented using queues. An error can occur if there is no space on the queue to post a message - indicating that the semaphore was not first obtained correctly.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xSemaphore</span></code>: A handle to the semaphore being released. This is the handle returned when the semaphore was created.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xSemaphoreGiveRecursive">
<span class="target" id="semphr_8h_1a398d66b17856c22dd49d39aaac42f105"></span><code class="descname">xSemaphoreGiveRecursive</code><span class="sig-paren">(</span>xMutex<span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreGiveRecursive" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Macro</em> to recursively release, or ‘give’, a mutex type semaphore. The mutex must have previously been created using a call to xSemaphoreCreateRecursiveMutex();</p>
<p>configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this macro to be available.</p>
<p>This macro must not be used on mutexes created using xSemaphoreCreateMutex().</p>
<p>A mutex used recursively can be ‘taken’ repeatedly by the owner. The mutex doesn’t become available again until the owner has called xSemaphoreGiveRecursive() for each successful ‘take’ request. For example, if a task successfully ‘takes’ the same mutex 5 times then the mutex will not be available to any other task until it has also ‘given’ the mutex back exactly five times.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xMutex</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

<span class="o">//</span> <span class="n">A</span> <span class="n">task</span> <span class="n">that</span> <span class="n">creates</span> <span class="n">a</span> <span class="n">mutex</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">mutex</span> <span class="n">to</span> <span class="n">guard</span> <span class="n">a</span> <span class="n">shared</span> <span class="n">resource</span><span class="o">.</span>
   <span class="n">xMutex</span> <span class="o">=</span> <span class="n">xSemaphoreCreateRecursiveMutex</span><span class="p">();</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">A</span> <span class="n">task</span> <span class="n">that</span> <span class="n">uses</span> <span class="n">the</span> <span class="n">mutex</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vAnotherTask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="o">...</span> <span class="n">Do</span> <span class="n">other</span> <span class="n">things</span><span class="o">.</span>

   <span class="k">if</span><span class="p">(</span> <span class="n">xMutex</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">See</span> <span class="k">if</span> <span class="n">we</span> <span class="n">can</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">mutex</span><span class="o">.</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">mutex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">available</span>
       <span class="o">//</span> <span class="n">wait</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="n">to</span> <span class="n">see</span> <span class="k">if</span> <span class="n">it</span> <span class="n">becomes</span> <span class="n">free</span><span class="o">.</span>
       <span class="k">if</span><span class="p">(</span> <span class="n">xSemaphoreTakeRecursive</span><span class="p">(</span> <span class="n">xMutex</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">)</span> <span class="o">==</span> <span class="n">pdTRUE</span> <span class="p">)</span>
       <span class="p">{</span>
           <span class="o">//</span> <span class="n">We</span> <span class="n">were</span> <span class="n">able</span> <span class="n">to</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">mutex</span> <span class="ow">and</span> <span class="n">can</span> <span class="n">now</span> <span class="n">access</span> <span class="n">the</span>
           <span class="o">//</span> <span class="n">shared</span> <span class="n">resource</span><span class="o">.</span>

           <span class="o">//</span> <span class="o">...</span>
           <span class="o">//</span> <span class="n">For</span> <span class="n">some</span> <span class="n">reason</span> <span class="n">due</span> <span class="n">to</span> <span class="n">the</span> <span class="n">nature</span> <span class="n">of</span> <span class="n">the</span> <span class="n">code</span> <span class="n">further</span> <span class="n">calls</span> <span class="n">to</span>
           <span class="o">//</span> <span class="n">xSemaphoreTakeRecursive</span><span class="p">()</span> <span class="n">are</span> <span class="n">made</span> <span class="n">on</span> <span class="n">the</span> <span class="n">same</span> <span class="n">mutex</span><span class="o">.</span>  <span class="n">In</span> <span class="n">real</span>
           <span class="o">//</span> <span class="n">code</span> <span class="n">these</span> <span class="n">would</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">just</span> <span class="n">sequential</span> <span class="n">calls</span> <span class="k">as</span> <span class="n">this</span> <span class="n">would</span> <span class="n">make</span>
           <span class="o">//</span> <span class="n">no</span> <span class="n">sense</span><span class="o">.</span>  <span class="n">Instead</span> <span class="n">the</span> <span class="n">calls</span> <span class="n">are</span> <span class="n">likely</span> <span class="n">to</span> <span class="n">be</span> <span class="n">buried</span> <span class="n">inside</span>
           <span class="o">//</span> <span class="n">a</span> <span class="n">more</span> <span class="nb">complex</span> <span class="n">call</span> <span class="n">structure</span><span class="o">.</span>
           <span class="n">xSemaphoreTakeRecursive</span><span class="p">(</span> <span class="n">xMutex</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">);</span>
           <span class="n">xSemaphoreTakeRecursive</span><span class="p">(</span> <span class="n">xMutex</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">);</span>

           <span class="o">//</span> <span class="n">The</span> <span class="n">mutex</span> <span class="n">has</span> <span class="n">now</span> <span class="n">been</span> <span class="s1">&#39;taken&#39;</span> <span class="n">three</span> <span class="n">times</span><span class="p">,</span> <span class="n">so</span> <span class="n">will</span> <span class="ow">not</span> <span class="n">be</span>
           <span class="o">//</span> <span class="n">available</span> <span class="n">to</span> <span class="n">another</span> <span class="n">task</span> <span class="n">until</span> <span class="n">it</span> <span class="n">has</span> <span class="n">also</span> <span class="n">been</span> <span class="n">given</span> <span class="n">back</span>
           <span class="o">//</span> <span class="n">three</span> <span class="n">times</span><span class="o">.</span>  <span class="n">Again</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">unlikely</span> <span class="n">that</span> <span class="n">real</span> <span class="n">code</span> <span class="n">would</span> <span class="n">have</span>
           <span class="o">//</span> <span class="n">these</span> <span class="n">calls</span> <span class="n">sequentially</span><span class="p">,</span> <span class="n">it</span> <span class="n">would</span> <span class="n">be</span> <span class="n">more</span> <span class="n">likely</span> <span class="n">that</span> <span class="n">the</span> <span class="n">calls</span>
           <span class="o">//</span> <span class="n">to</span> <span class="n">xSemaphoreGiveRecursive</span><span class="p">()</span> <span class="n">would</span> <span class="n">be</span> <span class="n">called</span> <span class="k">as</span> <span class="n">a</span> <span class="n">call</span> <span class="n">stack</span>
           <span class="o">//</span> <span class="n">unwound</span><span class="o">.</span>  <span class="n">This</span> <span class="ow">is</span> <span class="n">just</span> <span class="k">for</span> <span class="n">demonstrative</span> <span class="n">purposes</span><span class="o">.</span>
           <span class="n">xSemaphoreGiveRecursive</span><span class="p">(</span> <span class="n">xMutex</span> <span class="p">);</span>
           <span class="n">xSemaphoreGiveRecursive</span><span class="p">(</span> <span class="n">xMutex</span> <span class="p">);</span>
           <span class="n">xSemaphoreGiveRecursive</span><span class="p">(</span> <span class="n">xMutex</span> <span class="p">);</span>

           <span class="o">//</span> <span class="n">Now</span> <span class="n">the</span> <span class="n">mutex</span> <span class="n">can</span> <span class="n">be</span> <span class="n">taken</span> <span class="n">by</span> <span class="n">other</span> <span class="n">tasks</span><span class="o">.</span>
       <span class="p">}</span>
       <span class="k">else</span>
       <span class="p">{</span>
           <span class="o">//</span> <span class="n">We</span> <span class="n">could</span> <span class="ow">not</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">mutex</span> <span class="ow">and</span> <span class="n">can</span> <span class="n">therefore</span> <span class="ow">not</span> <span class="n">access</span>
           <span class="o">//</span> <span class="n">the</span> <span class="n">shared</span> <span class="n">resource</span> <span class="n">safely</span><span class="o">.</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if the semaphore was given.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xMutex</span></code>: A handle to the mutex being released, or ‘given’. This is the handle returned by xSemaphoreCreateMutex();</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xSemaphoreGiveFromISR">
<span class="target" id="semphr_8h_1a68aa43df8b2a0dbe17d05fad74670ef0"></span><code class="descname">xSemaphoreGiveFromISR</code><span class="sig-paren">(</span>xSemaphore, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreGiveFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Macro</em> to release a semaphore. The semaphore must have previously been created with a call to vSemaphoreCreateBinary() or xSemaphoreCreateCounting().</p>
<p>Mutex type semaphores (those created using a call to xSemaphoreCreateMutex()) must not be used with this macro.</p>
<p>This macro can be used from an ISR.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\#define LONG_TIME 0xffff
\#define TICKS_TO_WAIT 10
SemaphoreHandle_t xSemaphore = NULL;

// Repetitive task.
void vATask( void * pvParameters )
{
   for( ;; )
   {
       // We want this task to run every 10 ticks of a timer.  The semaphore
       // was created before this task was started.

       // Block waiting for the semaphore to become available.
       if( xSemaphoreTake( xSemaphore, LONG_TIME ) == pdTRUE )
       {
           // It is time to execute.

           // ...

           // We have finished our task.  Return to the top of the loop where
           // we will block on the semaphore until it is time to execute
           // again.  Note when using the semaphore for synchronisation with an
           // ISR in this manner there is no need to &#39;give&#39; the semaphore back.
       }
   }
}

// Timer ISR
void vTimerISR( void * pvParameters )
{
static uint8_t ucLocalTickCount = 0;
static BaseType_t xHigherPriorityTaskWoken;

   // A timer tick has occurred.

   // ... Do other time functions.

   // Is it time for vATask () to run?
   xHigherPriorityTaskWoken = pdFALSE;
   ucLocalTickCount++;
   if( ucLocalTickCount &gt;= TICKS_TO_WAIT )
   {
       // Unblock the task by releasing the semaphore.
       xSemaphoreGiveFromISR( xSemaphore, &amp;xHigherPriorityTaskWoken );

       // Reset the count so we release the semaphore again in 10 ticks time.
       ucLocalTickCount = 0;
   }

   if( xHigherPriorityTaskWoken != pdFALSE )
   {
       // We can force a context switch here.  Context switching from an
       // ISR uses port specific syntax.  Check the demo task for your port
       // to find the syntax required.
   }
}
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if the semaphore was successfully given, otherwise errQUEUE_FULL.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xSemaphore</span></code>: A handle to the semaphore being released. This is the handle returned when the semaphore was created.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>: xSemaphoreGiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if giving the semaphore caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xSemaphoreGiveFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xSemaphoreTakeFromISR">
<span class="target" id="semphr_8h_1a076419b58e072655686939016e7ca3c5"></span><code class="descname">xSemaphoreTakeFromISR</code><span class="sig-paren">(</span>xSemaphore, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreTakeFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Macro</em> to take a semaphore from an ISR. The semaphore must have previously been created with a call to vSemaphoreCreateBinary() or xSemaphoreCreateCounting().</p>
<p>Mutex type semaphores (those created using a call to xSemaphoreCreateMutex()) must not be used with this macro.</p>
<p>This macro can be used from an ISR, however taking a semaphore from an ISR is not a common operation. It is likely to only be useful when taking a counting semaphore when an interrupt is obtaining an object from a resource pool (when the semaphore count indicates the number of resources available).</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdTRUE if the semaphore was successfully taken, otherwise pdFALSE </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xSemaphore</span></code>: A handle to the semaphore being taken. This is the handle returned when the semaphore was created.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>: xSemaphoreTakeFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if taking the semaphore caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xSemaphoreTakeFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xSemaphoreCreateMutex">
<span class="target" id="semphr_8h_1aa6a00aa9b91a9e5b3ebe4ae1c3f115c6"></span><code class="descname">xSemaphoreCreateMutex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreCreateMutex" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Macro</em> that implements a mutex semaphore by using the existing queue mechanism.</p>
<p>Internally, within the FreeRTOS implementation, mutex semaphores use a block of memory, in which the mutex structure is stored. If a mutex is created using xSemaphoreCreateMutex() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateMutex() function. (see <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). If a mutex is created using xSemaphoreCreateMutexStatic() then the application writer must provided the memory. xSemaphoreCreateMutexStatic() therefore allows a mutex to be created without using any dynamic memory allocation.</p>
<p>Mutexes created using this function can be accessed using the xSemaphoreTake() and xSemaphoreGive() macros. The xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros must not be used.</p>
<p>This type of semaphore uses a priority inheritance mechanism so a task ‘taking’ a semaphore MUST ALWAYS ‘give’ the semaphore back once the semaphore it is no longer required.</p>
<p>Mutex type semaphores cannot be used from within interrupt service routines.</p>
<p>See vSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always ‘gives’ the semaphore and another always ‘takes’ the semaphore) and from within interrupt service routines.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">Semaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span> <span class="n">before</span> <span class="n">a</span> <span class="n">call</span> <span class="n">to</span> <span class="n">xSemaphoreCreateMutex</span><span class="p">()</span><span class="o">.</span>
   <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">macro</span> <span class="n">so</span> <span class="k">pass</span> <span class="n">the</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">directly</span><span class="o">.</span>
   <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">xSemaphoreCreateMutex</span><span class="p">();</span>

   <span class="k">if</span><span class="p">(</span> <span class="n">xSemaphore</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">The</span> <span class="n">semaphore</span> <span class="n">was</span> <span class="n">created</span> <span class="n">successfully</span><span class="o">.</span>
       <span class="o">//</span> <span class="n">The</span> <span class="n">semaphore</span> <span class="n">can</span> <span class="n">now</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If the mutex was successfully created then a handle to the created semaphore is returned. If there was not enough heap to allocate the mutex data structures then NULL is returned.</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xSemaphoreCreateMutexStatic">
<span class="target" id="semphr_8h_1a2f6fea163b7069a27a4a3fd8adfbfadd"></span><code class="descname">xSemaphoreCreateMutexStatic</code><span class="sig-paren">(</span>pxMutexBuffer<span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreCreateMutexStatic" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new mutex type semaphore instance, and returns a handle by which the new mutex can be referenced.</p>
<p>Internally, within the FreeRTOS implementation, mutex semaphores use a block of memory, in which the mutex structure is stored. If a mutex is created using xSemaphoreCreateMutex() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateMutex() function. (see <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). If a mutex is created using xSemaphoreCreateMutexStatic() then the application writer must provided the memory. xSemaphoreCreateMutexStatic() therefore allows a mutex to be created without using any dynamic memory allocation.</p>
<p>Mutexes created using this function can be accessed using the xSemaphoreTake() and xSemaphoreGive() macros. The xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros must not be used.</p>
<p>This type of semaphore uses a priority inheritance mechanism so a task ‘taking’ a semaphore MUST ALWAYS ‘give’ the semaphore back once the semaphore it is no longer required.</p>
<p>Mutex type semaphores cannot be used from within interrupt service routines.</p>
<p>See xSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always ‘gives’ the semaphore and another always ‘takes’ the semaphore) and from within interrupt service routines.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span><span class="p">;</span>
<span class="n">StaticSemaphore_t</span> <span class="n">xMutexBuffer</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">A</span> <span class="n">mutex</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span> <span class="n">before</span> <span class="n">it</span> <span class="n">has</span> <span class="n">been</span> <span class="n">created</span><span class="o">.</span>  <span class="n">xMutexBuffer</span> <span class="ow">is</span>
   <span class="o">//</span> <span class="n">into</span> <span class="n">xSemaphoreCreateMutexStatic</span><span class="p">()</span> <span class="n">so</span> <span class="n">no</span> <span class="n">dynamic</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="ow">is</span>
   <span class="o">//</span> <span class="n">attempted</span><span class="o">.</span>
   <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">xSemaphoreCreateMutexStatic</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">xMutexBuffer</span> <span class="p">);</span>

   <span class="o">//</span> <span class="n">As</span> <span class="n">no</span> <span class="n">dynamic</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="n">was</span> <span class="n">performed</span><span class="p">,</span> <span class="n">xSemaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">NULL</span><span class="p">,</span>
   <span class="o">//</span> <span class="n">so</span> <span class="n">there</span> <span class="ow">is</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">check</span> <span class="n">it</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If the mutex was successfully created then a handle to the created mutex is returned. If pxMutexBuffer was NULL then NULL is returned.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pxMutexBuffer</span></code>: Must point to a variable of type StaticSemaphore_t, which will be used to hold the mutex’s data structure, removing the need for the memory to be allocated dynamically.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xSemaphoreCreateRecursiveMutex">
<span class="target" id="semphr_8h_1a1bbc843be5a41ea83d2693b2189fc0f8"></span><code class="descname">xSemaphoreCreateRecursiveMutex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreCreateRecursiveMutex" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new recursive mutex type semaphore instance, and returns a handle by which the new recursive mutex can be referenced.</p>
<p>Internally, within the FreeRTOS implementation, recursive mutexs use a block of memory, in which the mutex structure is stored. If a recursive mutex is created using xSemaphoreCreateRecursiveMutex() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateRecursiveMutex() function. (see <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). If a recursive mutex is created using xSemaphoreCreateRecursiveMutexStatic() then the application writer must provide the memory that will get used by the mutex. xSemaphoreCreateRecursiveMutexStatic() therefore allows a recursive mutex to be created without using any dynamic memory allocation.</p>
<p>Mutexes created using this macro can be accessed using the xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros. The xSemaphoreTake() and xSemaphoreGive() macros must not be used.</p>
<p>A mutex used recursively can be ‘taken’ repeatedly by the owner. The mutex doesn’t become available again until the owner has called xSemaphoreGiveRecursive() for each successful ‘take’ request. For example, if a task successfully ‘takes’ the same mutex 5 times then the mutex will not be available to any other task until it has also ‘given’ the mutex back exactly five times.</p>
<p>This type of semaphore uses a priority inheritance mechanism so a task ‘taking’ a semaphore MUST ALWAYS ‘give’ the semaphore back once the semaphore it is no longer required.</p>
<p>Mutex type semaphores cannot be used from within interrupt service routines.</p>
<p>See vSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always ‘gives’ the semaphore and another always ‘takes’ the semaphore) and from within interrupt service routines.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">Semaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span> <span class="n">before</span> <span class="n">a</span> <span class="n">call</span> <span class="n">to</span> <span class="n">xSemaphoreCreateMutex</span><span class="p">()</span><span class="o">.</span>
   <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">macro</span> <span class="n">so</span> <span class="k">pass</span> <span class="n">the</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">directly</span><span class="o">.</span>
   <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">xSemaphoreCreateRecursiveMutex</span><span class="p">();</span>

   <span class="k">if</span><span class="p">(</span> <span class="n">xSemaphore</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">The</span> <span class="n">semaphore</span> <span class="n">was</span> <span class="n">created</span> <span class="n">successfully</span><span class="o">.</span>
       <span class="o">//</span> <span class="n">The</span> <span class="n">semaphore</span> <span class="n">can</span> <span class="n">now</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>xSemaphore Handle to the created mutex semaphore. Should be of type SemaphoreHandle_t.</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xSemaphoreCreateRecursiveMutexStatic">
<span class="target" id="semphr_8h_1a6fda8db26863762a083770f060d1285b"></span><code class="descname">xSemaphoreCreateRecursiveMutexStatic</code><span class="sig-paren">(</span>pxStaticSemaphore<span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreCreateRecursiveMutexStatic" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new recursive mutex type semaphore instance, and returns a handle by which the new recursive mutex can be referenced.</p>
<p>Internally, within the FreeRTOS implementation, recursive mutexs use a block of memory, in which the mutex structure is stored. If a recursive mutex is created using xSemaphoreCreateRecursiveMutex() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateRecursiveMutex() function. (see <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). If a recursive mutex is created using xSemaphoreCreateRecursiveMutexStatic() then the application writer must provide the memory that will get used by the mutex. xSemaphoreCreateRecursiveMutexStatic() therefore allows a recursive mutex to be created without using any dynamic memory allocation.</p>
<p>Mutexes created using this macro can be accessed using the xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros. The xSemaphoreTake() and xSemaphoreGive() macros must not be used.</p>
<p>A mutex used recursively can be ‘taken’ repeatedly by the owner. The mutex doesn’t become available again until the owner has called xSemaphoreGiveRecursive() for each successful ‘take’ request. For example, if a task successfully ‘takes’ the same mutex 5 times then the mutex will not be available to any other task until it has also ‘given’ the mutex back exactly five times.</p>
<p>This type of semaphore uses a priority inheritance mechanism so a task ‘taking’ a semaphore MUST ALWAYS ‘give’ the semaphore back once the semaphore it is no longer required.</p>
<p>Mutex type semaphores cannot be used from within interrupt service routines.</p>
<p>See xSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always ‘gives’ the semaphore and another always ‘takes’ the semaphore) and from within interrupt service routines.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span><span class="p">;</span>
<span class="n">StaticSemaphore_t</span> <span class="n">xMutexBuffer</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">A</span> <span class="n">recursive</span> <span class="n">semaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span> <span class="n">before</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">created</span><span class="o">.</span>  <span class="n">Here</span> <span class="n">a</span>
   <span class="o">//</span> <span class="n">recursive</span> <span class="n">mutex</span> <span class="ow">is</span> <span class="n">created</span> <span class="n">using</span> <span class="n">xSemaphoreCreateRecursiveMutexStatic</span><span class="p">()</span><span class="o">.</span>
   <span class="o">//</span> <span class="n">The</span> <span class="n">address</span> <span class="n">of</span> <span class="n">xMutexBuffer</span> <span class="ow">is</span> <span class="n">passed</span> <span class="n">into</span> <span class="n">the</span> <span class="n">function</span><span class="p">,</span> <span class="ow">and</span> <span class="n">will</span> <span class="n">hold</span>
   <span class="o">//</span> <span class="n">the</span> <span class="n">mutexes</span> <span class="n">data</span> <span class="n">structures</span> <span class="o">-</span> <span class="n">so</span> <span class="n">no</span> <span class="n">dynamic</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="n">will</span> <span class="n">be</span>
   <span class="o">//</span> <span class="n">attempted</span><span class="o">.</span>
   <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">xSemaphoreCreateRecursiveMutexStatic</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">xMutexBuffer</span> <span class="p">);</span>

   <span class="o">//</span> <span class="n">As</span> <span class="n">no</span> <span class="n">dynamic</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="n">was</span> <span class="n">performed</span><span class="p">,</span> <span class="n">xSemaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">NULL</span><span class="p">,</span>
   <span class="o">//</span> <span class="n">so</span> <span class="n">there</span> <span class="ow">is</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">check</span> <span class="n">it</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If the recursive mutex was successfully created then a handle to the created recursive mutex is returned. If pxMutexBuffer was NULL then NULL is returned.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pxStaticSemaphore</span></code>: Must point to a variable of type StaticSemaphore_t, which will then be used to hold the recursive mutex’s data structure, removing the need for the memory to be allocated dynamically.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xSemaphoreCreateCounting">
<span class="target" id="semphr_8h_1a7764616a918a46115403569a88148ad4"></span><code class="descname">xSemaphoreCreateCounting</code><span class="sig-paren">(</span>uxMaxCount, uxInitialCount<span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreCreateCounting" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new counting semaphore instance, and returns a handle by which the new counting semaphore can be referenced.</p>
<p>In many usage scenarios it is faster and more memory efficient to use a direct to task notification in place of a counting semaphore! <a class="reference external" href="http://www.freertos.org/RTOS-task-notifications.html">http://www.freertos.org/RTOS-task-notifications.html</a></p>
<p>Internally, within the FreeRTOS implementation, counting semaphores use a block of memory, in which the counting semaphore structure is stored. If a counting semaphore is created using xSemaphoreCreateCounting() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateCounting() function. (see <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). If a counting semaphore is created using xSemaphoreCreateCountingStatic() then the application writer can instead optionally provide the memory that will get used by the counting semaphore. xSemaphoreCreateCountingStatic() therefore allows a counting semaphore to be created without using any dynamic memory allocation.</p>
<p>Counting semaphores are typically used for two things:</p>
<p>1) Counting events.</p>
<p>In this usage scenario an event handler will ‘give’ a semaphore each time an event occurs (incrementing the semaphore count value), and a handler task will ‘take’ a semaphore each time it processes an event (decrementing the semaphore count value). The count value is therefore the difference between the number of events that have occurred and the number that have been processed. In this case it is desirable for the initial count value to be zero.</p>
<p>2) Resource management.</p>
<p>In this usage scenario the count value indicates the number of resources available. To obtain control of a resource a task must first obtain a semaphore - decrementing the semaphore count value. When the count value reaches zero there are no free resources. When a task finishes with the resource it ‘gives’ the semaphore back - incrementing the semaphore count value. In this case it is desirable for the initial count value to be equal to the maximum count value, indicating that all resources are free.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">Semaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span> <span class="n">before</span> <span class="n">a</span> <span class="n">call</span> <span class="n">to</span> <span class="n">xSemaphoreCreateCounting</span><span class="p">()</span><span class="o">.</span>
   <span class="o">//</span> <span class="n">The</span> <span class="nb">max</span> <span class="n">value</span> <span class="n">to</span> <span class="n">which</span> <span class="n">the</span> <span class="n">semaphore</span> <span class="n">can</span> <span class="n">count</span> <span class="n">should</span> <span class="n">be</span> <span class="mi">10</span><span class="p">,</span> <span class="ow">and</span> <span class="n">the</span>
   <span class="o">//</span> <span class="n">initial</span> <span class="n">value</span> <span class="n">assigned</span> <span class="n">to</span> <span class="n">the</span> <span class="n">count</span> <span class="n">should</span> <span class="n">be</span> <span class="mf">0.</span>
   <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">xSemaphoreCreateCounting</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

   <span class="k">if</span><span class="p">(</span> <span class="n">xSemaphore</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">The</span> <span class="n">semaphore</span> <span class="n">was</span> <span class="n">created</span> <span class="n">successfully</span><span class="o">.</span>
       <span class="o">//</span> <span class="n">The</span> <span class="n">semaphore</span> <span class="n">can</span> <span class="n">now</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Handle to the created semaphore. Null if the semaphore could not be created.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">uxMaxCount</span></code>: The maximum count value that can be reached. When the semaphore reaches this value it can no longer be ‘given’.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxInitialCount</span></code>: The count value assigned to the semaphore when it is created.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xSemaphoreCreateCountingStatic">
<span class="target" id="semphr_8h_1a955bf5b3c1e256c5ce42c73d577c8438"></span><code class="descname">xSemaphoreCreateCountingStatic</code><span class="sig-paren">(</span>uxMaxCount, uxInitialCount, pxSemaphoreBuffer<span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreCreateCountingStatic" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new counting semaphore instance, and returns a handle by which the new counting semaphore can be referenced.</p>
<p>In many usage scenarios it is faster and more memory efficient to use a direct to task notification in place of a counting semaphore! <a class="reference external" href="http://www.freertos.org/RTOS-task-notifications.html">http://www.freertos.org/RTOS-task-notifications.html</a></p>
<p>Internally, within the FreeRTOS implementation, counting semaphores use a block of memory, in which the counting semaphore structure is stored. If a counting semaphore is created using xSemaphoreCreateCounting() then the required memory is automatically dynamically allocated inside the xSemaphoreCreateCounting() function. (see <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). If a counting semaphore is created using xSemaphoreCreateCountingStatic() then the application writer must provide the memory. xSemaphoreCreateCountingStatic() therefore allows a counting semaphore to be created without using any dynamic memory allocation.</p>
<p>Counting semaphores are typically used for two things:</p>
<p>1) Counting events.</p>
<p>In this usage scenario an event handler will ‘give’ a semaphore each time an event occurs (incrementing the semaphore count value), and a handler task will ‘take’ a semaphore each time it processes an event (decrementing the semaphore count value). The count value is therefore the difference between the number of events that have occurred and the number that have been processed. In this case it is desirable for the initial count value to be zero.</p>
<p>2) Resource management.</p>
<p>In this usage scenario the count value indicates the number of resources available. To obtain control of a resource a task must first obtain a semaphore - decrementing the semaphore count value. When the count value reaches zero there are no free resources. When a task finishes with the resource it ‘gives’ the semaphore back - incrementing the semaphore count value. In this case it is desirable for the initial count value to be equal to the maximum count value, indicating that all resources are free.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span><span class="p">;</span>
<span class="n">StaticSemaphore_t</span> <span class="n">xSemaphoreBuffer</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">Counting</span> <span class="n">semaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span> <span class="n">before</span> <span class="n">they</span> <span class="n">have</span> <span class="n">been</span> <span class="n">created</span><span class="o">.</span>  <span class="n">Create</span>
   <span class="o">//</span> <span class="n">a</span> <span class="n">counting</span> <span class="n">semaphore</span> <span class="n">using</span> <span class="n">xSemaphoreCreateCountingStatic</span><span class="p">()</span><span class="o">.</span>  <span class="n">The</span> <span class="nb">max</span>
   <span class="o">//</span> <span class="n">value</span> <span class="n">to</span> <span class="n">which</span> <span class="n">the</span> <span class="n">semaphore</span> <span class="n">can</span> <span class="n">count</span> <span class="ow">is</span> <span class="mi">10</span><span class="p">,</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">initial</span> <span class="n">value</span>
   <span class="o">//</span> <span class="n">assigned</span> <span class="n">to</span> <span class="n">the</span> <span class="n">count</span> <span class="n">will</span> <span class="n">be</span> <span class="mf">0.</span>  <span class="n">The</span> <span class="n">address</span> <span class="n">of</span> <span class="n">xSemaphoreBuffer</span> <span class="ow">is</span>
   <span class="o">//</span> <span class="n">passed</span> <span class="ow">in</span> <span class="ow">and</span> <span class="n">will</span> <span class="n">be</span> <span class="n">used</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">semaphore</span> <span class="n">structure</span><span class="p">,</span> <span class="n">so</span> <span class="n">no</span> <span class="n">dynamic</span>
   <span class="o">//</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="n">will</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
   <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">xSemaphoreCreateCounting</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xSemaphoreBuffer</span> <span class="p">);</span>

   <span class="o">//</span> <span class="n">No</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="n">was</span> <span class="n">attempted</span> <span class="n">so</span> <span class="n">xSemaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">so</span> <span class="n">there</span>
   <span class="o">//</span> <span class="ow">is</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">check</span> <span class="n">its</span> <span class="n">value</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If the counting semaphore was successfully created then a handle to the created counting semaphore is returned. If pxSemaphoreBuffer was NULL then NULL is returned.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">uxMaxCount</span></code>: The maximum count value that can be reached. When the semaphore reaches this value it can no longer be ‘given’.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxInitialCount</span></code>: The count value assigned to the semaphore when it is created.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxSemaphoreBuffer</span></code>: Must point to a variable of type StaticSemaphore_t, which will then be used to hold the semaphore’s data structure, removing the need for the memory to be allocated dynamically.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.vSemaphoreDelete">
<span class="target" id="semphr_8h_1acd7d0eda0923d7caeeaaee9202c43eab"></span><code class="descname">vSemaphoreDelete</code><span class="sig-paren">(</span>xSemaphore<span class="sig-paren">)</span><a class="headerlink" href="#c.vSemaphoreDelete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a semaphore. This function must be used with care. For example, do not delete a mutex type semaphore if the mutex is held by a task.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xSemaphore</span></code>: A handle to the semaphore to be deleted. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xSemaphoreGetMutexHolder">
<span class="target" id="semphr_8h_1a7403bfbc06fb8449b2334f55d939a4c4"></span><code class="descname">xSemaphoreGetMutexHolder</code><span class="sig-paren">(</span>xSemaphore<span class="sig-paren">)</span><a class="headerlink" href="#c.xSemaphoreGetMutexHolder" title="Permalink to this definition">¶</a></dt>
<dd><p>If xMutex is indeed a mutex type semaphore, return the current mutex holder. If xMutex is not a mutex type semaphore, or the mutex is available (not held by a task), return NULL.</p>
<p>Note: This is a good way of determining if the calling task is the mutex holder, but not a good way of determining the identity of the mutex holder as the holder may change between the function exiting and the returned value being tested. </p>
</dd></dl>

<dl class="macro">
<dt id="c.uxSemaphoreGetCount">
<span class="target" id="semphr_8h_1aa26a3d7cf9b5595a652daeb7f81229f3"></span><code class="descname">uxSemaphoreGetCount</code><span class="sig-paren">(</span>xSemaphore<span class="sig-paren">)</span><a class="headerlink" href="#c.uxSemaphoreGetCount" title="Permalink to this definition">¶</a></dt>
<dd><p>If the semaphore is a counting semaphore then uxSemaphoreGetCount() returns its current count value. If the semaphore is a binary semaphore then uxSemaphoreGetCount() returns 1 if the semaphore is available, and 0 if the semaphore is not available. </p>
</dd></dl>

</div>
<div class="section" id="id7">
<h3>Type Definitions<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv417SemaphoreHandle_t">
<span id="_CPPv317SemaphoreHandle_t"></span><span id="_CPPv217SemaphoreHandle_t"></span><span id="SemaphoreHandle_t"></span><span class="target" id="semphr_8h_1ad88c6df4a04beedeac782918c8a332f5"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv413QueueHandle_t" title="QueueHandle_t">QueueHandle_t</a> <code class="descname">SemaphoreHandle_t</code><a class="headerlink" href="#_CPPv417SemaphoreHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</div>
<div class="section" id="timer-api">
<h2>Timer API<a class="headerlink" href="#timer-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id8">
<h3>Header File<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/freertos/include/freertos/timers.h">freertos/include/freertos/timers.h</a></li>
</ul>
</div>
<div class="section" id="id9">
<h3>Functions<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv412xTimerCreatePCKcK10TickType_tK11UBaseType_tPCv23TimerCallbackFunction_t">
<span id="_CPPv312xTimerCreatePCKcK10TickType_tK11UBaseType_tPCv23TimerCallbackFunction_t"></span><span id="_CPPv212xTimerCreatePCKcK10TickType_tK11UBaseType_tPCv23TimerCallbackFunction_t"></span><span id="xTimerCreate__cCPC.TickType_tC.UBaseType_tC.voidPC.TimerCallbackFunction_t"></span><span class="target" id="timers_8h_1acd5834fe4b94778f6204866277042627"></span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t">TimerHandle_t</a> <code class="descname">xTimerCreate</code><span class="sig-paren">(</span><em class="property">const</em> char *<em class="property">const</em> <em>pcTimerName</em>, <em class="property">const</em> TickType_t <em>xTimerPeriodInTicks</em>, <em class="property">const</em> UBaseType_t <em>uxAutoReload</em>, void *<em class="property">const</em> <em>pvTimerID</em>, <a class="reference internal" href="#_CPPv423TimerCallbackFunction_t" title="TimerCallbackFunction_t">TimerCallbackFunction_t</a> <em>pxCallbackFunction</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412xTimerCreatePCKcK10TickType_tK11UBaseType_tPCv23TimerCallbackFunction_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Creates a new software timer instance, and returns a handle by which the created software timer can be referenced.</p>
<p>Internally, within the FreeRTOS implementation, software timers use a block of memory, in which the timer data structure is stored. If a software timer is created using xTimerCreate() then the required memory is automatically dynamically allocated inside the xTimerCreate() function. (see <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). If a software timer is created using xTimerCreateStatic() then the application writer must provide the memory that will get used by the software timer. xTimerCreateStatic() therefore allows a software timer to be created without using any dynamic memory allocation.</p>
<p>Timers are created in the dormant state. The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the active state.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#define NUM_TIMERS 5

// An array to hold handles to the created timers.
TimerHandle_t xTimers[ NUM_TIMERS ];

// An array to hold a count of the number of times each timer expires.
int32_t lExpireCounters[ NUM_TIMERS ] = { 0 };

// Define a callback function that will be used by multiple timer instances.
// The callback function does nothing but count the number of times the
// associated timer expires, and stop the timer once the timer has expired
// 10 times.
void vTimerCallback( TimerHandle_t pxTimer )
{
int32_t lArrayIndex;
const int32_t xMaxExpiryCountBeforeStopping = 10;

       // Optionally do something if the pxTimer parameter is NULL.
       configASSERT( pxTimer );

    // Which timer expired?
    lArrayIndex = ( int32_t ) pvTimerGetTimerID( pxTimer );

    // Increment the number of times that pxTimer has expired.
    lExpireCounters[ lArrayIndex ] += 1;

    // If the timer has expired 10 times then stop it from running.
    if( lExpireCounters[ lArrayIndex ] == xMaxExpiryCountBeforeStopping )
    {
        // Do not use a block time if calling a timer API function from a
        // timer callback function, as doing so could cause a deadlock!
        xTimerStop( pxTimer, 0 );
    }
}

void main( void )
{
int32_t x;

    // Create then start some timers.  Starting the timers before the scheduler
    // has been started means the timers will start running immediately that
    // the scheduler starts.
    for( x = 0; x &lt; NUM_TIMERS; x++ )
    {
        xTimers[ x ] = xTimerCreate(    &quot;Timer&quot;,       // Just a text name, not used by the kernel.
                                        ( 100 * x ),   // The timer period in ticks.
                                        pdTRUE,        // The timers will auto-reload themselves when they expire.
                                        ( void * ) x,  // Assign each timer a unique id equal to its array index.
                                        vTimerCallback // Each timer calls the same callback when it expires.
                                    );

        if( xTimers[ x ] == NULL )
        {
            // The timer was not created.
        }
        else
        {
            // Start the timer.  No block time is specified, and even if one was
            // it would be ignored because the scheduler has not yet been
            // started.
            if( xTimerStart( xTimers[ x ], 0 ) != pdPASS )
            {
                // The timer could not be set into the Active state.
            }
        }
    }

    // ...
    // Create tasks here.
    // ...

    // Starting the scheduler will start the timers running as they have already
    // been set into the active state.
    vTaskStartScheduler();

    // Should not reach here.
    for( ;; );
}
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If the timer is successfully created then a handle to the newly created timer is returned. If the timer cannot be created (because either there is insufficient FreeRTOS heap remaining to allocate the timer structures, or the timer period was set to 0) then NULL is returned.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pcTimerName</span></code>: A text name that is assigned to the timer. This is done purely to assist debugging. The kernel itself only ever references a timer by its handle, and never by its name.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTimerPeriodInTicks</span></code>: The timer period. The time is defined in tick periods so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xTimerPeriodInTicks should be set to 100. Alternatively, if the timer must expire after 500ms, then xPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxAutoReload</span></code>: If uxAutoReload is set to pdTRUE then the timer will expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter. If uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and enter the dormant state after it expires.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvTimerID</span></code>: An identifier that is assigned to the timer being created. Typically this would be used in the timer callback function to identify which timer expired when the same callback function is assigned to more than one timer.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxCallbackFunction</span></code>: The function to call when the timer expires. Callback functions must have the prototype defined by TimerCallbackFunction_t, which is “void vCallbackFunction( TimerHandle_t xTimer );”.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418xTimerCreateStaticPCKcK10TickType_tK11UBaseType_tPCv23TimerCallbackFunction_tP13StaticTimer_t">
<span id="_CPPv318xTimerCreateStaticPCKcK10TickType_tK11UBaseType_tPCv23TimerCallbackFunction_tP13StaticTimer_t"></span><span id="_CPPv218xTimerCreateStaticPCKcK10TickType_tK11UBaseType_tPCv23TimerCallbackFunction_tP13StaticTimer_t"></span><span id="xTimerCreateStatic__cCPC.TickType_tC.UBaseType_tC.voidPC.TimerCallbackFunction_t.StaticTimer_tP"></span><span class="target" id="timers_8h_1a12002be9234be5958340690faa328e85"></span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t">TimerHandle_t</a> <code class="descname">xTimerCreateStatic</code><span class="sig-paren">(</span><em class="property">const</em> char *<em class="property">const</em> <em>pcTimerName</em>, <em class="property">const</em> TickType_t <em>xTimerPeriodInTicks</em>, <em class="property">const</em> UBaseType_t <em>uxAutoReload</em>, void *<em class="property">const</em> <em>pvTimerID</em>, <a class="reference internal" href="#_CPPv423TimerCallbackFunction_t" title="TimerCallbackFunction_t">TimerCallbackFunction_t</a> <em>pxCallbackFunction</em>, StaticTimer_t *<em>pxTimerBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418xTimerCreateStaticPCKcK10TickType_tK11UBaseType_tPCv23TimerCallbackFunction_tP13StaticTimer_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Creates a new software timer instance, and returns a handle by which the created software timer can be referenced.</p>
<p>Internally, within the FreeRTOS implementation, software timers use a block of memory, in which the timer data structure is stored. If a software timer is created using xTimerCreate() then the required memory is automatically dynamically allocated inside the xTimerCreate() function. (see <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). If a software timer is created using xTimerCreateStatic() then the application writer must provide the memory that will get used by the software timer. xTimerCreateStatic() therefore allows a software timer to be created without using any dynamic memory allocation.</p>
<p>Timers are created in the dormant state. The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the active state.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">The</span> <span class="n">buffer</span> <span class="n">used</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span><span class="s1">&#39;s data structure.</span>
<span class="n">static</span> <span class="n">StaticTimer_t</span> <span class="n">xTimerBuffer</span><span class="p">;</span>

<span class="o">//</span> <span class="n">A</span> <span class="n">variable</span> <span class="n">that</span> <span class="n">will</span> <span class="n">be</span> <span class="n">incremented</span> <span class="n">by</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span><span class="s1">&#39;s callback</span>
<span class="o">//</span> <span class="n">function</span><span class="o">.</span>
<span class="n">UBaseType_t</span> <span class="n">uxVariableToIncrement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="o">//</span> <span class="n">A</span> <span class="n">software</span> <span class="n">timer</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">that</span> <span class="n">increments</span> <span class="n">a</span> <span class="n">variable</span> <span class="n">passed</span> <span class="n">to</span>
<span class="o">//</span> <span class="n">it</span> <span class="n">when</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span> <span class="n">was</span> <span class="n">created</span><span class="o">.</span>  <span class="n">After</span> <span class="n">the</span> <span class="mi">5</span><span class="n">th</span> <span class="n">increment</span> <span class="n">the</span>
<span class="o">//</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">stops</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span><span class="o">.</span>
<span class="n">static</span> <span class="n">void</span> <span class="n">prvTimerCallback</span><span class="p">(</span> <span class="n">TimerHandle_t</span> <span class="n">xExpiredTimer</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">UBaseType_t</span> <span class="o">*</span><span class="n">puxVariableToIncrement</span><span class="p">;</span>
<span class="n">BaseType_t</span> <span class="n">xReturned</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Obtain</span> <span class="n">the</span> <span class="n">address</span> <span class="n">of</span> <span class="n">the</span> <span class="n">variable</span> <span class="n">to</span> <span class="n">increment</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">timer</span> <span class="n">ID</span><span class="o">.</span>
    <span class="n">puxVariableToIncrement</span> <span class="o">=</span> <span class="p">(</span> <span class="n">UBaseType_t</span> <span class="o">*</span> <span class="p">)</span> <span class="n">pvTimerGetTimerID</span><span class="p">(</span> <span class="n">xExpiredTimer</span> <span class="p">);</span>

    <span class="o">//</span> <span class="n">Increment</span> <span class="n">the</span> <span class="n">variable</span> <span class="n">to</span> <span class="n">show</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">callback</span> <span class="n">has</span> <span class="n">executed</span><span class="o">.</span>
    <span class="p">(</span> <span class="o">*</span><span class="n">puxVariableToIncrement</span> <span class="p">)</span><span class="o">++</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">If</span> <span class="n">this</span> <span class="n">callback</span> <span class="n">has</span> <span class="n">executed</span> <span class="n">the</span> <span class="n">required</span> <span class="n">number</span> <span class="n">of</span> <span class="n">times</span><span class="p">,</span> <span class="n">stop</span> <span class="n">the</span>
    <span class="o">//</span> <span class="n">timer</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="o">*</span><span class="n">puxVariableToIncrement</span> <span class="o">==</span> <span class="mi">5</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">called</span> <span class="kn">from</span> <span class="nn">a</span> <span class="n">timer</span> <span class="n">callback</span> <span class="n">so</span> <span class="n">must</span> <span class="ow">not</span> <span class="n">block</span><span class="o">.</span>
        <span class="n">xTimerStop</span><span class="p">(</span> <span class="n">xExpiredTimer</span><span class="p">,</span> <span class="n">staticDONT_BLOCK</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="n">void</span> <span class="n">main</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">software</span> <span class="n">time</span><span class="o">.</span>  <span class="n">xTimerCreateStatic</span><span class="p">()</span> <span class="n">has</span> <span class="n">an</span> <span class="n">extra</span> <span class="n">parameter</span>
    <span class="o">//</span> <span class="n">than</span> <span class="n">the</span> <span class="n">normal</span> <span class="n">xTimerCreate</span><span class="p">()</span> <span class="n">API</span> <span class="n">function</span><span class="o">.</span>  <span class="n">The</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">pointer</span>
    <span class="o">//</span> <span class="n">to</span> <span class="n">the</span> <span class="n">StaticTimer_t</span> <span class="n">structure</span> <span class="n">that</span> <span class="n">will</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span>
    <span class="o">//</span> <span class="n">structure</span><span class="o">.</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="n">passed</span> <span class="k">as</span> <span class="n">NULL</span> <span class="n">then</span> <span class="n">the</span> <span class="n">structure</span> <span class="n">will</span> <span class="n">be</span>
    <span class="o">//</span> <span class="n">allocated</span> <span class="n">dynamically</span><span class="p">,</span> <span class="n">just</span> <span class="k">as</span> <span class="k">if</span> <span class="n">xTimerCreate</span><span class="p">()</span> <span class="n">had</span> <span class="n">been</span> <span class="n">called</span><span class="o">.</span>
    <span class="n">xTimer</span> <span class="o">=</span> <span class="n">xTimerCreateStatic</span><span class="p">(</span> <span class="s2">&quot;T1&quot;</span><span class="p">,</span>             <span class="o">//</span> <span class="n">Text</span> <span class="n">name</span> <span class="k">for</span> <span class="n">the</span> <span class="n">task</span><span class="o">.</span>  <span class="n">Helps</span> <span class="n">debugging</span> <span class="n">only</span><span class="o">.</span>  <span class="n">Not</span> <span class="n">used</span> <span class="n">by</span> <span class="n">FreeRTOS</span><span class="o">.</span>
                                 <span class="n">xTimerPeriod</span><span class="p">,</span>     <span class="o">//</span> <span class="n">The</span> <span class="n">period</span> <span class="n">of</span> <span class="n">the</span> <span class="n">timer</span> <span class="ow">in</span> <span class="n">ticks</span><span class="o">.</span>
                                 <span class="n">pdTRUE</span><span class="p">,</span>           <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">auto</span><span class="o">-</span><span class="n">reload</span> <span class="n">timer</span><span class="o">.</span>
                                 <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">uxVariableToIncrement</span><span class="p">,</span>    <span class="o">//</span> <span class="n">A</span> <span class="n">variable</span> <span class="n">incremented</span> <span class="n">by</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span><span class="s1">&#39;s callback function</span>
                                 <span class="n">prvTimerCallback</span><span class="p">,</span> <span class="o">//</span> <span class="n">The</span> <span class="n">function</span> <span class="n">to</span> <span class="n">execute</span> <span class="n">when</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">expires</span><span class="o">.</span>
                                 <span class="o">&amp;</span><span class="n">xTimerBuffer</span> <span class="p">);</span>  <span class="o">//</span> <span class="n">The</span> <span class="n">buffer</span> <span class="n">that</span> <span class="n">will</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span> <span class="n">structure</span><span class="o">.</span>

    <span class="o">//</span> <span class="n">The</span> <span class="n">scheduler</span> <span class="n">has</span> <span class="ow">not</span> <span class="n">started</span> <span class="n">yet</span> <span class="n">so</span> <span class="n">a</span> <span class="n">block</span> <span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span><span class="o">.</span>
    <span class="n">xReturned</span> <span class="o">=</span> <span class="n">xTimerStart</span><span class="p">(</span> <span class="n">xTimer</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

    <span class="o">//</span> <span class="o">...</span>
    <span class="o">//</span> <span class="n">Create</span> <span class="n">tasks</span> <span class="n">here</span><span class="o">.</span>
    <span class="o">//</span> <span class="o">...</span>

    <span class="o">//</span> <span class="n">Starting</span> <span class="n">the</span> <span class="n">scheduler</span> <span class="n">will</span> <span class="n">start</span> <span class="n">the</span> <span class="n">timers</span> <span class="n">running</span> <span class="k">as</span> <span class="n">they</span> <span class="n">have</span> <span class="n">already</span>
    <span class="o">//</span> <span class="n">been</span> <span class="nb">set</span> <span class="n">into</span> <span class="n">the</span> <span class="n">active</span> <span class="n">state</span><span class="o">.</span>
    <span class="n">vTaskStartScheduler</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">Should</span> <span class="ow">not</span> <span class="n">reach</span> <span class="n">here</span><span class="o">.</span>
    <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If the timer is created then a handle to the created timer is returned. If pxTimerBuffer was NULL then NULL is returned.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pcTimerName</span></code>: A text name that is assigned to the timer. This is done purely to assist debugging. The kernel itself only ever references a timer by its handle, and never by its name.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTimerPeriodInTicks</span></code>: The timer period. The time is defined in tick periods so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xTimerPeriodInTicks should be set to 100. Alternatively, if the timer must expire after 500ms, then xPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxAutoReload</span></code>: If uxAutoReload is set to pdTRUE then the timer will expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter. If uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and enter the dormant state after it expires.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvTimerID</span></code>: An identifier that is assigned to the timer being created. Typically this would be used in the timer callback function to identify which timer expired when the same callback function is assigned to more than one timer.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxCallbackFunction</span></code>: The function to call when the timer expires. Callback functions must have the prototype defined by TimerCallbackFunction_t, which is “void vCallbackFunction( TimerHandle_t xTimer );”.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxTimerBuffer</span></code>: Must point to a variable of type StaticTimer_t, which will be then be used to hold the software timer’s data structures, removing the need for the memory to be allocated dynamically.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417pvTimerGetTimerID13TimerHandle_t">
<span id="_CPPv317pvTimerGetTimerID13TimerHandle_t"></span><span id="_CPPv217pvTimerGetTimerID13TimerHandle_t"></span><span id="pvTimerGetTimerID__TimerHandle_t"></span><span class="target" id="timers_8h_1add681027143e1fdadcb8452a6a19585a"></span>void *<code class="descname">pvTimerGetTimerID</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t">TimerHandle_t</a> <em>xTimer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417pvTimerGetTimerID13TimerHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the ID assigned to the timer.</p>
<p>IDs are assigned to timers using the pvTimerID parameter of the call to xTimerCreated() that was used to create the timer.</p>
<p>If the same callback function is assigned to multiple timers then the timer ID can be used within the callback function to identify which timer actually expired.</p>
<p><p>Example usage:</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The ID assigned to the timer being queried.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: The timer being queried.</li>
</ul>
</dd>
</dl>
</p>
<p>See the xTimerCreate() API function example usage scenario. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416vTimerSetTimerID13TimerHandle_tPv">
<span id="_CPPv316vTimerSetTimerID13TimerHandle_tPv"></span><span id="_CPPv216vTimerSetTimerID13TimerHandle_tPv"></span><span id="vTimerSetTimerID__TimerHandle_t.voidP"></span><span class="target" id="timers_8h_1a1f06045a953481dd7012d4c7762990cb"></span>void <code class="descname">vTimerSetTimerID</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t">TimerHandle_t</a> <em>xTimer</em>, void *<em>pvNewID</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416vTimerSetTimerID13TimerHandle_tPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets the ID assigned to the timer.</p>
<p>IDs are assigned to timers using the pvTimerID parameter of the call to xTimerCreated() that was used to create the timer.</p>
<p>If the same callback function is assigned to multiple timers then the timer ID can be used as time specific (timer local) storage.</p>
<p><p>Example usage:</p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: The timer being updated.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvNewID</span></code>: The ID to assign to the timer.</li>
</ul>
</dd>
</dl>
</p>
<p>See the xTimerCreate() API function example usage scenario. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419xTimerIsTimerActive13TimerHandle_t">
<span id="_CPPv319xTimerIsTimerActive13TimerHandle_t"></span><span id="_CPPv219xTimerIsTimerActive13TimerHandle_t"></span><span id="xTimerIsTimerActive__TimerHandle_t"></span><span class="target" id="timers_8h_1a2cd9b1399fb25203be698f123846dc33"></span>BaseType_t <code class="descname">xTimerIsTimerActive</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t">TimerHandle_t</a> <em>xTimer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419xTimerIsTimerActive13TimerHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Queries a timer to see if it is active or dormant.</p>
<p>A timer will be dormant if: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">)</span> <span class="n">It</span> <span class="n">has</span> <span class="n">been</span> <span class="n">created</span> <span class="n">but</span> <span class="ow">not</span> <span class="n">started</span><span class="p">,</span> <span class="ow">or</span>

<span class="mi">2</span><span class="p">)</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">expired</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span> <span class="n">that</span> <span class="n">has</span> <span class="ow">not</span> <span class="n">been</span> <span class="n">restarted</span><span class="o">.</span>
</pre></div>
</div>
</p>
<p>Timers are created in the dormant state. The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the active state.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">This</span> <span class="n">function</span> <span class="n">assumes</span> <span class="n">xTimer</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vAFunction</span><span class="p">(</span> <span class="n">TimerHandle_t</span> <span class="n">xTimer</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xTimerIsTimerActive</span><span class="p">(</span> <span class="n">xTimer</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdFALSE</span> <span class="p">)</span> <span class="o">//</span> <span class="ow">or</span> <span class="n">more</span> <span class="n">simply</span> <span class="ow">and</span> <span class="n">equivalently</span> <span class="s2">&quot;if( xTimerIsTimerActive( xTimer ) )&quot;</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">xTimer</span> <span class="ow">is</span> <span class="n">active</span><span class="p">,</span> <span class="n">do</span> <span class="n">something</span><span class="o">.</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">xTimer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">active</span><span class="p">,</span> <span class="n">do</span> <span class="n">something</span> <span class="k">else</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdFALSE will be returned if the timer is dormant. A value other than pdFALSE will be returned if the timer is active.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: The timer being queried.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv430xTimerGetTimerDaemonTaskHandlev">
<span id="_CPPv330xTimerGetTimerDaemonTaskHandlev"></span><span id="_CPPv230xTimerGetTimerDaemonTaskHandlev"></span><span id="xTimerGetTimerDaemonTaskHandle__void"></span><span class="target" id="timers_8h_1a1fe9e235a8c27986902b71ebda7385d8"></span><a class="reference internal" href="#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <code class="descname">xTimerGetTimerDaemonTaskHandle</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430xTimerGetTimerDaemonTaskHandlev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>xTimerGetTimerDaemonTaskHandle() is only available if INCLUDE_xTimerGetTimerDaemonTaskHandle is set to 1 in FreeRTOSConfig.h.</p>
<p>Simply returns the handle of the timer service/daemon task. It it not valid to call xTimerGetTimerDaemonTaskHandle() before the scheduler has been started. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415xTimerGetPeriod13TimerHandle_t">
<span id="_CPPv315xTimerGetPeriod13TimerHandle_t"></span><span id="_CPPv215xTimerGetPeriod13TimerHandle_t"></span><span id="xTimerGetPeriod__TimerHandle_t"></span><span class="target" id="timers_8h_1a2735e79e155b2ca2a3809958ebb7431e"></span>TickType_t <code class="descname">xTimerGetPeriod</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t">TimerHandle_t</a> <em>xTimer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415xTimerGetPeriod13TimerHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the period of a timer.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The period of the timer in ticks. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: The handle of the timer being queried.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419xTimerGetExpiryTime13TimerHandle_t">
<span id="_CPPv319xTimerGetExpiryTime13TimerHandle_t"></span><span id="_CPPv219xTimerGetExpiryTime13TimerHandle_t"></span><span id="xTimerGetExpiryTime__TimerHandle_t"></span><span class="target" id="timers_8h_1a06cdc26759c622eeb575070064e26025"></span>TickType_t <code class="descname">xTimerGetExpiryTime</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t">TimerHandle_t</a> <em>xTimer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419xTimerGetExpiryTime13TimerHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the time in ticks at which the timer will expire. If this is less than the current tick count then the expiry time has overflowed from the current time.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If the timer is running then the time in ticks at which the timer will next expire is returned. If the timer is not running then the return value is undefined. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: The handle of the timer being queried.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv429xTimerPendFunctionCallFromISR16PendedFunction_tPv8uint32_tP10BaseType_t">
<span id="_CPPv329xTimerPendFunctionCallFromISR16PendedFunction_tPv8uint32_tP10BaseType_t"></span><span id="_CPPv229xTimerPendFunctionCallFromISR16PendedFunction_tPv8uint32_tP10BaseType_t"></span><span id="xTimerPendFunctionCallFromISR__PendedFunction_t.voidP.uint32_t.BaseType_tP"></span><span class="target" id="timers_8h_1af4444b6b1a4e8d7db156e6aaccdf66fa"></span>BaseType_t <code class="descname">xTimerPendFunctionCallFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416PendedFunction_t" title="PendedFunction_t">PendedFunction_t</a> <em>xFunctionToPend</em>, void *<em>pvParameter1</em>, uint32_t <em>ulParameter2</em>, BaseType_t *<em>pxHigherPriorityTaskWoken</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429xTimerPendFunctionCallFromISR16PendedFunction_tPv8uint32_tP10BaseType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Used from application interrupt service routines to defer the execution of a function to the RTOS daemon task (the timer service task, hence this function is implemented in timers.c and is prefixed with ‘Timer’).</p>
<p>Ideally an interrupt service routine (ISR) is kept as short as possible, but sometimes an ISR either has a lot of processing to do, or needs to perform processing that is not deterministic. In these cases xTimerPendFunctionCallFromISR() can be used to defer processing of a function to the RTOS daemon task.</p>
<p>A mechanism is provided that allows the interrupt to return directly to the task that will subsequently execute the pended callback function. This allows the callback function to execute contiguously in time with the interrupt - just as if the callback had executed in the interrupt itself.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">The</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">that</span> <span class="n">will</span> <span class="n">execute</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">context</span> <span class="n">of</span> <span class="n">the</span> <span class="n">daemon</span> <span class="n">task</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Note</span> <span class="n">callback</span> <span class="n">functions</span> <span class="n">must</span> <span class="nb">all</span> <span class="n">use</span> <span class="n">this</span> <span class="n">same</span> <span class="n">prototype</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vProcessInterface</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameter1</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">ulParameter2</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="n">BaseType_t</span> <span class="n">xInterfaceToService</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">The</span> <span class="n">interface</span> <span class="n">that</span> <span class="n">requires</span> <span class="n">servicing</span> <span class="ow">is</span> <span class="n">passed</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">second</span>
    <span class="o">//</span> <span class="n">parameter</span><span class="o">.</span>  <span class="n">The</span> <span class="n">first</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">case</span><span class="o">.</span>
   <span class="n">xInterfaceToService</span> <span class="o">=</span> <span class="p">(</span> <span class="n">BaseType_t</span> <span class="p">)</span> <span class="n">ulParameter2</span><span class="p">;</span>

   <span class="o">//</span> <span class="o">...</span><span class="n">Perform</span> <span class="n">the</span> <span class="n">processing</span> <span class="n">here</span><span class="o">...</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">An</span> <span class="n">ISR</span> <span class="n">that</span> <span class="n">receives</span> <span class="n">data</span> <span class="n">packets</span> <span class="kn">from</span> <span class="nn">multiple</span> <span class="n">interfaces</span>
<span class="n">void</span> <span class="n">vAnISR</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="n">BaseType_t</span> <span class="n">xInterfaceToService</span><span class="p">,</span> <span class="n">xHigherPriorityTaskWoken</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">Query</span> <span class="n">the</span> <span class="n">hardware</span> <span class="n">to</span> <span class="n">determine</span> <span class="n">which</span> <span class="n">interface</span> <span class="n">needs</span> <span class="n">processing</span><span class="o">.</span>
   <span class="n">xInterfaceToService</span> <span class="o">=</span> <span class="n">prvCheckInterfaces</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">The</span> <span class="n">actual</span> <span class="n">processing</span> <span class="ow">is</span> <span class="n">to</span> <span class="n">be</span> <span class="n">deferred</span> <span class="n">to</span> <span class="n">a</span> <span class="n">task</span><span class="o">.</span>  <span class="n">Request</span> <span class="n">the</span>
    <span class="o">//</span> <span class="n">vProcessInterface</span><span class="p">()</span> <span class="n">callback</span> <span class="n">function</span> <span class="ow">is</span> <span class="n">executed</span><span class="p">,</span> <span class="n">passing</span> <span class="ow">in</span> <span class="n">the</span>
   <span class="o">//</span> <span class="n">number</span> <span class="n">of</span> <span class="n">the</span> <span class="n">interface</span> <span class="n">that</span> <span class="n">needs</span> <span class="n">processing</span><span class="o">.</span>  <span class="n">The</span> <span class="n">interface</span> <span class="n">to</span>
   <span class="o">//</span> <span class="n">service</span> <span class="ow">is</span> <span class="n">passed</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">second</span> <span class="n">parameter</span><span class="o">.</span>  <span class="n">The</span> <span class="n">first</span> <span class="n">parameter</span> <span class="ow">is</span>
   <span class="o">//</span> <span class="ow">not</span> <span class="n">used</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">case</span><span class="o">.</span>
   <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>
   <span class="n">xTimerPendFunctionCallFromISR</span><span class="p">(</span> <span class="n">vProcessInterface</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="p">(</span> <span class="n">uint32_t</span> <span class="p">)</span> <span class="n">xInterfaceToService</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">);</span>

   <span class="o">//</span> <span class="n">If</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="ow">is</span> <span class="n">now</span> <span class="nb">set</span> <span class="n">to</span> <span class="n">pdTRUE</span> <span class="n">then</span> <span class="n">a</span> <span class="n">context</span>
   <span class="o">//</span> <span class="n">switch</span> <span class="n">should</span> <span class="n">be</span> <span class="n">requested</span><span class="o">.</span>  <span class="n">The</span> <span class="n">macro</span> <span class="n">used</span> <span class="ow">is</span> <span class="n">port</span> <span class="n">specific</span> <span class="ow">and</span> <span class="n">will</span>
   <span class="o">//</span> <span class="n">be</span> <span class="n">either</span> <span class="n">portYIELD_FROM_ISR</span><span class="p">()</span> <span class="ow">or</span> <span class="n">portEND_SWITCHING_ISR</span><span class="p">()</span> <span class="o">-</span> <span class="n">refer</span> <span class="n">to</span>
   <span class="o">//</span> <span class="n">the</span> <span class="n">documentation</span> <span class="n">page</span> <span class="k">for</span> <span class="n">the</span> <span class="n">port</span> <span class="n">being</span> <span class="n">used</span><span class="o">.</span>
   <span class="n">portYIELD_FROM_ISR</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="p">);</span>

<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdPASS is returned if the message was successfully sent to the timer daemon task, otherwise pdFALSE is returned.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xFunctionToPend</span></code>: The function to execute from the timer service/ daemon task. The function must conform to the PendedFunction_t prototype.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvParameter1</span></code>: The value of the callback function’s first parameter. The parameter has a void * type to allow it to be used to pass any type. For example, unsigned longs can be cast to a void *, or the void * can be used to point to a structure.</li>
<li><code class="docutils literal notranslate"><span class="pre">ulParameter2</span></code>: The value of the callback function’s second parameter.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>: As mentioned above, calling this function will result in a message being sent to the timer daemon task. If the priority of the timer daemon task (which is set using configTIMER_TASK_PRIORITY in FreeRTOSConfig.h) is higher than the priority of the currently running task (the task the interrupt interrupted) then *pxHigherPriorityTaskWoken will be set to pdTRUE within xTimerPendFunctionCallFromISR(), indicating that a context switch should be requested before the interrupt exits. For that reason *pxHigherPriorityTaskWoken must be initialised to pdFALSE. See the example code below.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422xTimerPendFunctionCall16PendedFunction_tPv8uint32_t10TickType_t">
<span id="_CPPv322xTimerPendFunctionCall16PendedFunction_tPv8uint32_t10TickType_t"></span><span id="_CPPv222xTimerPendFunctionCall16PendedFunction_tPv8uint32_t10TickType_t"></span><span id="xTimerPendFunctionCall__PendedFunction_t.voidP.uint32_t.TickType_t"></span><span class="target" id="timers_8h_1a5df6d08740c1184489440072246a02f2"></span>BaseType_t <code class="descname">xTimerPendFunctionCall</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv416PendedFunction_t" title="PendedFunction_t">PendedFunction_t</a> <em>xFunctionToPend</em>, void *<em>pvParameter1</em>, uint32_t <em>ulParameter2</em>, TickType_t <em>xTicksToWait</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422xTimerPendFunctionCall16PendedFunction_tPv8uint32_t10TickType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Used to defer the execution of a function to the RTOS daemon task (the timer service task, hence this function is implemented in timers.c and is prefixed with ‘Timer’).</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdPASS is returned if the message was successfully sent to the timer daemon task, otherwise pdFALSE is returned. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xFunctionToPend</span></code>: The function to execute from the timer service/ daemon task. The function must conform to the PendedFunction_t prototype.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvParameter1</span></code>: The value of the callback function’s first parameter. The parameter has a void * type to allow it to be used to pass any type. For example, unsigned longs can be cast to a void *, or the void * can be used to point to a structure.</li>
<li><code class="docutils literal notranslate"><span class="pre">ulParameter2</span></code>: The value of the callback function’s second parameter.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: Calling this function will result in a message being sent to the timer daemon task on a queue. xTicksToWait is the amount of time the calling task should remain in the Blocked state (so not using any processing time) for space to become available on the timer queue if the queue is found to be full.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419pcTimerGetTimerName13TimerHandle_t">
<span id="_CPPv319pcTimerGetTimerName13TimerHandle_t"></span><span id="_CPPv219pcTimerGetTimerName13TimerHandle_t"></span><span id="pcTimerGetTimerName__TimerHandle_t"></span><span class="target" id="timers_8h_1ac400899727aade5734a33f3228a6ef9d"></span><em class="property">const</em> char *<code class="descname">pcTimerGetTimerName</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t">TimerHandle_t</a> <em>xTimer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419pcTimerGetTimerName13TimerHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the name that was assigned to a timer when the timer was created.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The name assigned to the timer specified by the xTimer parameter. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: The handle of the timer being queried.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="id10">
<h3>Macros<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR">
<span class="target" id="timers_8h_1aff0b8d2d5d743afef9d52861618139bf"></span><code class="descname">tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR</code><a class="headerlink" href="#c.tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.tmrCOMMAND_EXECUTE_CALLBACK">
<span class="target" id="timers_8h_1aca42f545424488ce7dfd43c0d70ca610"></span><code class="descname">tmrCOMMAND_EXECUTE_CALLBACK</code><a class="headerlink" href="#c.tmrCOMMAND_EXECUTE_CALLBACK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.tmrCOMMAND_START_DONT_TRACE">
<span class="target" id="timers_8h_1adcc4f4391b0850b18596974d7618bdfc"></span><code class="descname">tmrCOMMAND_START_DONT_TRACE</code><a class="headerlink" href="#c.tmrCOMMAND_START_DONT_TRACE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.tmrCOMMAND_START">
<span class="target" id="timers_8h_1afc38af63403775cc4ced3995f920343a"></span><code class="descname">tmrCOMMAND_START</code><a class="headerlink" href="#c.tmrCOMMAND_START" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.tmrCOMMAND_RESET">
<span class="target" id="timers_8h_1a0a63f701c021371d186adca7c590e923"></span><code class="descname">tmrCOMMAND_RESET</code><a class="headerlink" href="#c.tmrCOMMAND_RESET" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.tmrCOMMAND_STOP">
<span class="target" id="timers_8h_1a0cd6f6a41dcd52d2fc06c350f43516c0"></span><code class="descname">tmrCOMMAND_STOP</code><a class="headerlink" href="#c.tmrCOMMAND_STOP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.tmrCOMMAND_CHANGE_PERIOD">
<span class="target" id="timers_8h_1adb27881a1a1118b9cc4d711391c89414"></span><code class="descname">tmrCOMMAND_CHANGE_PERIOD</code><a class="headerlink" href="#c.tmrCOMMAND_CHANGE_PERIOD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.tmrCOMMAND_DELETE">
<span class="target" id="timers_8h_1a5a5586339a9dbc1320153fd96a1c2f33"></span><code class="descname">tmrCOMMAND_DELETE</code><a class="headerlink" href="#c.tmrCOMMAND_DELETE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.tmrFIRST_FROM_ISR_COMMAND">
<span class="target" id="timers_8h_1afab5e13e40f49f678d62925ab8bc44a1"></span><code class="descname">tmrFIRST_FROM_ISR_COMMAND</code><a class="headerlink" href="#c.tmrFIRST_FROM_ISR_COMMAND" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.tmrCOMMAND_START_FROM_ISR">
<span class="target" id="timers_8h_1add053fdcf41607ba790004590c11844f"></span><code class="descname">tmrCOMMAND_START_FROM_ISR</code><a class="headerlink" href="#c.tmrCOMMAND_START_FROM_ISR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.tmrCOMMAND_RESET_FROM_ISR">
<span class="target" id="timers_8h_1a1d69bd5e47301570a4aa149bd868534a"></span><code class="descname">tmrCOMMAND_RESET_FROM_ISR</code><a class="headerlink" href="#c.tmrCOMMAND_RESET_FROM_ISR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.tmrCOMMAND_STOP_FROM_ISR">
<span class="target" id="timers_8h_1acbf988b64a5897a1c030da417cc654de"></span><code class="descname">tmrCOMMAND_STOP_FROM_ISR</code><a class="headerlink" href="#c.tmrCOMMAND_STOP_FROM_ISR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.tmrCOMMAND_CHANGE_PERIOD_FROM_ISR">
<span class="target" id="timers_8h_1ab520106084753fbb137ac275ab3ff20b"></span><code class="descname">tmrCOMMAND_CHANGE_PERIOD_FROM_ISR</code><a class="headerlink" href="#c.tmrCOMMAND_CHANGE_PERIOD_FROM_ISR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.xTimerStart">
<span class="target" id="timers_8h_1a3a9b838f48991e852ce05c986b0eeb8c"></span><code class="descname">xTimerStart</code><span class="sig-paren">(</span>xTimer, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="#c.xTimerStart" title="Permalink to this definition">¶</a></dt>
<dd><p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p>
<p>xTimerStart() starts a timer that was previously created using the xTimerCreate() API function. If the timer had already been started and was already in the active state, then xTimerStart() has equivalent functionality to the xTimerReset() API function.</p>
<p>Starting a timer ensures the timer is in the active state. If the timer is not stopped, deleted, or reset in the mean time, the callback function associated with the timer will get called ‘n’ ticks after xTimerStart() was called, where ‘n’ is the timers defined period.</p>
<p>It is valid to call xTimerStart() before the scheduler has been started, but when this is done the timer will not actually start until the scheduler is started, and the timers expiry time will be relative to when the scheduler is started, not relative to when xTimerStart() was called.</p>
<p>The configUSE_TIMERS configuration constant must be set to 1 for xTimerStart() to be available.</p>
<p><p>Example usage:</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdFAIL will be returned if the start command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerStart() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: The handle of the timer being started/restarted.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the start command to be successfully sent to the timer command queue, should the queue already be full when xTimerStart() was called. xTicksToWait is ignored if xTimerStart() is called before the scheduler is started.</li>
</ul>
</dd>
</dl>
</p>
<p>See the xTimerCreate() API function example usage scenario. </p>
</dd></dl>

<dl class="macro">
<dt id="c.xTimerStop">
<span class="target" id="timers_8h_1a8327c7fc10aee414cb163b445c5269a4"></span><code class="descname">xTimerStop</code><span class="sig-paren">(</span>xTimer, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="#c.xTimerStop" title="Permalink to this definition">¶</a></dt>
<dd><p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p>
<p>xTimerStop() stops a timer that was previously started using either of the The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() or xTimerChangePeriodFromISR() API functions.</p>
<p>Stopping a timer ensures the timer is not in the active state.</p>
<p>The configUSE_TIMERS configuration constant must be set to 1 for xTimerStop() to be available.</p>
<p><p>Example usage:</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdFAIL will be returned if the stop command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: The handle of the timer being stopped.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the stop command to be successfully sent to the timer command queue, should the queue already be full when xTimerStop() was called. xTicksToWait is ignored if xTimerStop() is called before the scheduler is started.</li>
</ul>
</dd>
</dl>
</p>
<p>See the xTimerCreate() API function example usage scenario. </p>
</dd></dl>

<dl class="macro">
<dt id="c.xTimerChangePeriod">
<span class="target" id="timers_8h_1ab12eac1c69a3437b8161ce81ff34b2f4"></span><code class="descname">xTimerChangePeriod</code><span class="sig-paren">(</span>xTimer, xNewPeriod, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="#c.xTimerChangePeriod" title="Permalink to this definition">¶</a></dt>
<dd><p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p>
<p>xTimerChangePeriod() changes the period of a timer that was previously created using the xTimerCreate() API function.</p>
<p>xTimerChangePeriod() can be called to change the period of an active or dormant state timer.</p>
<p>The configUSE_TIMERS configuration constant must be set to 1 for xTimerChangePeriod() to be available.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">This</span> <span class="n">function</span> <span class="n">assumes</span> <span class="n">xTimer</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span><span class="o">.</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">timer</span>
<span class="o">//</span> <span class="n">referenced</span> <span class="n">by</span> <span class="n">xTimer</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">active</span> <span class="n">when</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">called</span><span class="p">,</span> <span class="n">then</span> <span class="n">the</span> <span class="n">timer</span>
<span class="o">//</span> <span class="ow">is</span> <span class="n">deleted</span><span class="o">.</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">referenced</span> <span class="n">by</span> <span class="n">xTimer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">active</span> <span class="n">when</span> <span class="n">it</span> <span class="ow">is</span>
<span class="o">//</span> <span class="n">called</span><span class="p">,</span> <span class="n">then</span> <span class="n">the</span> <span class="n">period</span> <span class="n">of</span> <span class="n">the</span> <span class="n">timer</span> <span class="ow">is</span> <span class="nb">set</span> <span class="n">to</span> <span class="mi">500</span><span class="n">ms</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">timer</span> <span class="ow">is</span>
<span class="o">//</span> <span class="n">started</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vAFunction</span><span class="p">(</span> <span class="n">TimerHandle_t</span> <span class="n">xTimer</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xTimerIsTimerActive</span><span class="p">(</span> <span class="n">xTimer</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdFALSE</span> <span class="p">)</span> <span class="o">//</span> <span class="ow">or</span> <span class="n">more</span> <span class="n">simply</span> <span class="ow">and</span> <span class="n">equivalently</span> <span class="s2">&quot;if( xTimerIsTimerActive( xTimer ) )&quot;</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">xTimer</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">active</span> <span class="o">-</span> <span class="n">delete</span> <span class="n">it</span><span class="o">.</span>
        <span class="n">xTimerDelete</span><span class="p">(</span> <span class="n">xTimer</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">xTimer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">active</span><span class="p">,</span> <span class="n">change</span> <span class="n">its</span> <span class="n">period</span> <span class="n">to</span> <span class="mi">500</span><span class="n">ms</span><span class="o">.</span>  <span class="n">This</span> <span class="n">will</span> <span class="n">also</span>
        <span class="o">//</span> <span class="n">cause</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">to</span> <span class="n">start</span><span class="o">.</span>  <span class="n">Block</span> <span class="k">for</span> <span class="n">a</span> <span class="n">maximum</span> <span class="n">of</span> <span class="mi">100</span> <span class="n">ticks</span> <span class="k">if</span> <span class="n">the</span>
        <span class="o">//</span> <span class="n">change</span> <span class="n">period</span> <span class="n">command</span> <span class="n">cannot</span> <span class="n">immediately</span> <span class="n">be</span> <span class="n">sent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">timer</span>
        <span class="o">//</span> <span class="n">command</span> <span class="n">queue</span><span class="o">.</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">xTimerChangePeriod</span><span class="p">(</span> <span class="n">xTimer</span><span class="p">,</span> <span class="mi">500</span> <span class="o">/</span> <span class="n">portTICK_PERIOD_MS</span><span class="p">,</span> <span class="mi">100</span> <span class="p">)</span> <span class="o">==</span> <span class="n">pdPASS</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">The</span> <span class="n">command</span> <span class="n">was</span> <span class="n">successfully</span> <span class="n">sent</span><span class="o">.</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">The</span> <span class="n">command</span> <span class="n">could</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">sent</span><span class="p">,</span> <span class="n">even</span> <span class="n">after</span> <span class="n">waiting</span> <span class="k">for</span> <span class="mi">100</span> <span class="n">ticks</span>
            <span class="o">//</span> <span class="n">to</span> <span class="k">pass</span><span class="o">.</span>  <span class="n">Take</span> <span class="n">appropriate</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdFAIL will be returned if the change period command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: The handle of the timer that is having its period changed.</li>
<li><code class="docutils literal notranslate"><span class="pre">xNewPeriod</span></code>: The new period for xTimer. Timer periods are specified in tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xNewPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then xNewPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the change period command to be successfully sent to the timer command queue, should the queue already be full when xTimerChangePeriod() was called. xTicksToWait is ignored if xTimerChangePeriod() is called before the scheduler is started.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xTimerDelete">
<span class="target" id="timers_8h_1a8c8e21f05ebe92e15449addc5d269d10"></span><code class="descname">xTimerDelete</code><span class="sig-paren">(</span>xTimer, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="#c.xTimerDelete" title="Permalink to this definition">¶</a></dt>
<dd><p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p>
<p>xTimerDelete() deletes a timer that was previously created using the xTimerCreate() API function.</p>
<p>The configUSE_TIMERS configuration constant must be set to 1 for xTimerDelete() to be available.</p>
<p><p>Example usage:</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdFAIL will be returned if the delete command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: The handle of the timer being deleted.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the delete command to be successfully sent to the timer command queue, should the queue already be full when xTimerDelete() was called. xTicksToWait is ignored if xTimerDelete() is called before the scheduler is started.</li>
</ul>
</dd>
</dl>
</p>
<p>See the xTimerChangePeriod() API function example usage scenario. </p>
</dd></dl>

<dl class="macro">
<dt id="c.xTimerReset">
<span class="target" id="timers_8h_1a8081b4541b752908dc55df2693e53287"></span><code class="descname">xTimerReset</code><span class="sig-paren">(</span>xTimer, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="#c.xTimerReset" title="Permalink to this definition">¶</a></dt>
<dd><p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p>
<p>xTimerReset() re-starts a timer that was previously created using the xTimerCreate() API function. If the timer had already been started and was already in the active state, then xTimerReset() will cause the timer to re-evaluate its expiry time so that it is relative to when xTimerReset() was called. If the timer was in the dormant state then xTimerReset() has equivalent functionality to the xTimerStart() API function.</p>
<p>Resetting a timer ensures the timer is in the active state. If the timer is not stopped, deleted, or reset in the mean time, the callback function associated with the timer will get called ‘n’ ticks after xTimerReset() was called, where ‘n’ is the timers defined period.</p>
<p>It is valid to call xTimerReset() before the scheduler has been started, but when this is done the timer will not actually start until the scheduler is started, and the timers expiry time will be relative to when the scheduler is started, not relative to when xTimerReset() was called.</p>
<p>The configUSE_TIMERS configuration constant must be set to 1 for xTimerReset() to be available.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">When</span> <span class="n">a</span> <span class="n">key</span> <span class="ow">is</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">an</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">switched</span> <span class="n">on</span><span class="o">.</span>  <span class="n">If</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="k">pass</span>
<span class="o">//</span> <span class="n">without</span> <span class="n">a</span> <span class="n">key</span> <span class="n">being</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">then</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">switched</span> <span class="n">off</span><span class="o">.</span>  <span class="n">In</span>
<span class="o">//</span> <span class="n">this</span> <span class="n">case</span><span class="p">,</span> <span class="n">the</span> <span class="n">timer</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="o">.</span>

<span class="n">TimerHandle_t</span> <span class="n">xBacklightTimer</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">assigned</span> <span class="n">to</span> <span class="n">the</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="o">.</span>  <span class="n">In</span> <span class="n">this</span> <span class="n">case</span> <span class="n">the</span>
<span class="o">//</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vBacklightTimerCallback</span><span class="p">(</span> <span class="n">TimerHandle_t</span> <span class="n">pxTimer</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="n">expired</span><span class="p">,</span> <span class="n">therefore</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="n">must</span> <span class="n">have</span> <span class="n">passed</span> <span class="n">since</span> <span class="n">a</span> <span class="n">key</span>
    <span class="o">//</span> <span class="n">was</span> <span class="n">pressed</span><span class="o">.</span>  <span class="n">Switch</span> <span class="n">off</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span><span class="o">.</span>
    <span class="n">vSetBacklightState</span><span class="p">(</span> <span class="n">BACKLIGHT_OFF</span> <span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">key</span> <span class="n">press</span> <span class="n">event</span> <span class="n">handler</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vKeyPressEventHandler</span><span class="p">(</span> <span class="n">char</span> <span class="n">cKey</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Ensure</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">on</span><span class="p">,</span> <span class="n">then</span> <span class="n">reset</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">that</span> <span class="ow">is</span>
    <span class="o">//</span> <span class="n">responsible</span> <span class="k">for</span> <span class="n">turning</span> <span class="n">the</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="n">off</span> <span class="n">after</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="n">of</span>
    <span class="o">//</span> <span class="n">key</span> <span class="n">inactivity</span><span class="o">.</span>  <span class="n">Wait</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="k">for</span> <span class="n">the</span> <span class="n">command</span> <span class="n">to</span> <span class="n">be</span> <span class="n">successfully</span> <span class="n">sent</span>
    <span class="o">//</span> <span class="k">if</span> <span class="n">it</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">sent</span> <span class="n">immediately</span><span class="o">.</span>
    <span class="n">vSetBacklightState</span><span class="p">(</span> <span class="n">BACKLIGHT_ON</span> <span class="p">);</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xTimerReset</span><span class="p">(</span> <span class="n">xBacklightTimer</span><span class="p">,</span> <span class="mi">100</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">The</span> <span class="n">reset</span> <span class="n">command</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">executed</span> <span class="n">successfully</span><span class="o">.</span>  <span class="n">Take</span> <span class="n">appropriate</span>
        <span class="o">//</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">Perform</span> <span class="n">the</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">the</span> <span class="n">key</span> <span class="n">processing</span> <span class="n">here</span><span class="o">.</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">main</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">int32_t</span> <span class="n">x</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Create</span> <span class="n">then</span> <span class="n">start</span> <span class="n">the</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span> <span class="n">that</span> <span class="ow">is</span> <span class="n">responsible</span> <span class="k">for</span> <span class="n">turning</span>
    <span class="o">//</span> <span class="n">the</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="n">off</span> <span class="k">if</span> <span class="n">no</span> <span class="n">keys</span> <span class="n">are</span> <span class="n">pressed</span> <span class="n">within</span> <span class="n">a</span> <span class="mi">5</span> <span class="n">second</span> <span class="n">period</span><span class="o">.</span>
    <span class="n">xBacklightTimer</span> <span class="o">=</span> <span class="n">xTimerCreate</span><span class="p">(</span> <span class="s2">&quot;BacklightTimer&quot;</span><span class="p">,</span>           <span class="o">//</span> <span class="n">Just</span> <span class="n">a</span> <span class="n">text</span> <span class="n">name</span><span class="p">,</span> <span class="ow">not</span> <span class="n">used</span> <span class="n">by</span> <span class="n">the</span> <span class="n">kernel</span><span class="o">.</span>
                                    <span class="p">(</span> <span class="mi">5000</span> <span class="o">/</span> <span class="n">portTICK_PERIOD_MS</span><span class="p">),</span> <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="n">period</span> <span class="ow">in</span> <span class="n">ticks</span><span class="o">.</span>
                                    <span class="n">pdFALSE</span><span class="p">,</span>                    <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="o">.</span>
                                    <span class="mi">0</span><span class="p">,</span>                          <span class="o">//</span> <span class="n">The</span> <span class="nb">id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span> <span class="n">by</span> <span class="n">the</span> <span class="n">callback</span> <span class="n">so</span> <span class="n">can</span> <span class="n">take</span> <span class="nb">any</span> <span class="n">value</span><span class="o">.</span>
                                    <span class="n">vBacklightTimerCallback</span>     <span class="o">//</span> <span class="n">The</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">that</span> <span class="n">switches</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="n">off</span><span class="o">.</span>
                                  <span class="p">);</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">xBacklightTimer</span> <span class="o">==</span> <span class="n">NULL</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">created</span><span class="o">.</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Start</span> <span class="n">the</span> <span class="n">timer</span><span class="o">.</span>  <span class="n">No</span> <span class="n">block</span> <span class="n">time</span> <span class="ow">is</span> <span class="n">specified</span><span class="p">,</span> <span class="ow">and</span> <span class="n">even</span> <span class="k">if</span> <span class="n">one</span> <span class="n">was</span>
        <span class="o">//</span> <span class="n">it</span> <span class="n">would</span> <span class="n">be</span> <span class="n">ignored</span> <span class="n">because</span> <span class="n">the</span> <span class="n">scheduler</span> <span class="n">has</span> <span class="ow">not</span> <span class="n">yet</span> <span class="n">been</span>
        <span class="o">//</span> <span class="n">started</span><span class="o">.</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">xTimerStart</span><span class="p">(</span> <span class="n">xBacklightTimer</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="n">could</span> <span class="ow">not</span> <span class="n">be</span> <span class="nb">set</span> <span class="n">into</span> <span class="n">the</span> <span class="n">Active</span> <span class="n">state</span><span class="o">.</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="o">...</span>
    <span class="o">//</span> <span class="n">Create</span> <span class="n">tasks</span> <span class="n">here</span><span class="o">.</span>
    <span class="o">//</span> <span class="o">...</span>

    <span class="o">//</span> <span class="n">Starting</span> <span class="n">the</span> <span class="n">scheduler</span> <span class="n">will</span> <span class="n">start</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">running</span> <span class="k">as</span> <span class="n">it</span> <span class="n">has</span> <span class="n">already</span>
    <span class="o">//</span> <span class="n">been</span> <span class="nb">set</span> <span class="n">into</span> <span class="n">the</span> <span class="n">active</span> <span class="n">state</span><span class="o">.</span>
    <span class="n">xTaskStartScheduler</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">Should</span> <span class="ow">not</span> <span class="n">reach</span> <span class="n">here</span><span class="o">.</span>
    <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdFAIL will be returned if the reset command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerStart() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: The handle of the timer being reset/started/restarted.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the reset command to be successfully sent to the timer command queue, should the queue already be full when xTimerReset() was called. xTicksToWait is ignored if xTimerReset() is called before the scheduler is started.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xTimerStartFromISR">
<span class="target" id="timers_8h_1adab5809f9679e44a343b8dbb8fb7c67f"></span><code class="descname">xTimerStartFromISR</code><span class="sig-paren">(</span>xTimer, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="#c.xTimerStartFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>A version of xTimerStart() that can be called from an interrupt service routine.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">This</span> <span class="n">scenario</span> <span class="n">assumes</span> <span class="n">xBacklightTimer</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span><span class="o">.</span>  <span class="n">When</span> <span class="n">a</span>
<span class="o">//</span> <span class="n">key</span> <span class="ow">is</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">an</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">switched</span> <span class="n">on</span><span class="o">.</span>  <span class="n">If</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="k">pass</span>
<span class="o">//</span> <span class="n">without</span> <span class="n">a</span> <span class="n">key</span> <span class="n">being</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">then</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">switched</span> <span class="n">off</span><span class="o">.</span>  <span class="n">In</span>
<span class="o">//</span> <span class="n">this</span> <span class="n">case</span><span class="p">,</span> <span class="n">the</span> <span class="n">timer</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="p">,</span> <span class="ow">and</span> <span class="n">unlike</span> <span class="n">the</span> <span class="n">example</span> <span class="n">given</span> <span class="k">for</span>
<span class="o">//</span> <span class="n">the</span> <span class="n">xTimerReset</span><span class="p">()</span> <span class="n">function</span><span class="p">,</span> <span class="n">the</span> <span class="n">key</span> <span class="n">press</span> <span class="n">event</span> <span class="n">handler</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">interrupt</span>
<span class="o">//</span> <span class="n">service</span> <span class="n">routine</span><span class="o">.</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">assigned</span> <span class="n">to</span> <span class="n">the</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="o">.</span>  <span class="n">In</span> <span class="n">this</span> <span class="n">case</span> <span class="n">the</span>
<span class="o">//</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vBacklightTimerCallback</span><span class="p">(</span> <span class="n">TimerHandle_t</span> <span class="n">pxTimer</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="n">expired</span><span class="p">,</span> <span class="n">therefore</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="n">must</span> <span class="n">have</span> <span class="n">passed</span> <span class="n">since</span> <span class="n">a</span> <span class="n">key</span>
    <span class="o">//</span> <span class="n">was</span> <span class="n">pressed</span><span class="o">.</span>  <span class="n">Switch</span> <span class="n">off</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span><span class="o">.</span>
    <span class="n">vSetBacklightState</span><span class="p">(</span> <span class="n">BACKLIGHT_OFF</span> <span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">key</span> <span class="n">press</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vKeyPressEventInterruptHandler</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Ensure</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">on</span><span class="p">,</span> <span class="n">then</span> <span class="n">restart</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">that</span> <span class="ow">is</span>
    <span class="o">//</span> <span class="n">responsible</span> <span class="k">for</span> <span class="n">turning</span> <span class="n">the</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="n">off</span> <span class="n">after</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="n">of</span>
    <span class="o">//</span> <span class="n">key</span> <span class="n">inactivity</span><span class="o">.</span>  <span class="n">This</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span> <span class="n">so</span> <span class="n">can</span> <span class="n">only</span>
    <span class="o">//</span> <span class="n">call</span> <span class="n">FreeRTOS</span> <span class="n">API</span> <span class="n">functions</span> <span class="n">that</span> <span class="n">end</span> <span class="ow">in</span> <span class="s2">&quot;FromISR&quot;</span><span class="o">.</span>
    <span class="n">vSetBacklightState</span><span class="p">(</span> <span class="n">BACKLIGHT_ON</span> <span class="p">);</span>

    <span class="o">//</span> <span class="n">xTimerStartFromISR</span><span class="p">()</span> <span class="ow">or</span> <span class="n">xTimerResetFromISR</span><span class="p">()</span> <span class="n">could</span> <span class="n">be</span> <span class="n">called</span> <span class="n">here</span>
    <span class="o">//</span> <span class="k">as</span> <span class="n">both</span> <span class="n">cause</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">to</span> <span class="n">re</span><span class="o">-</span><span class="n">calculate</span> <span class="n">its</span> <span class="n">expiry</span> <span class="n">time</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">was</span> <span class="n">initialised</span> <span class="n">to</span> <span class="n">pdFALSE</span> <span class="n">when</span> <span class="n">it</span> <span class="n">was</span>
    <span class="o">//</span> <span class="n">declared</span> <span class="p">(</span><span class="ow">in</span> <span class="n">this</span> <span class="n">function</span><span class="p">)</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xTimerStartFromISR</span><span class="p">(</span> <span class="n">xBacklightTimer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">The</span> <span class="n">start</span> <span class="n">command</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">executed</span> <span class="n">successfully</span><span class="o">.</span>  <span class="n">Take</span> <span class="n">appropriate</span>
        <span class="o">//</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">Perform</span> <span class="n">the</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">the</span> <span class="n">key</span> <span class="n">processing</span> <span class="n">here</span><span class="o">.</span>

    <span class="o">//</span> <span class="n">If</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">equals</span> <span class="n">pdTRUE</span><span class="p">,</span> <span class="n">then</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
    <span class="o">//</span> <span class="n">should</span> <span class="n">be</span> <span class="n">performed</span><span class="o">.</span>  <span class="n">The</span> <span class="n">syntax</span> <span class="n">required</span> <span class="n">to</span> <span class="n">perform</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
    <span class="o">//</span> <span class="kn">from</span> <span class="nn">inside</span> <span class="n">an</span> <span class="n">ISR</span> <span class="n">varies</span> <span class="kn">from</span> <span class="nn">port</span> <span class="n">to</span> <span class="n">port</span><span class="p">,</span> <span class="ow">and</span> <span class="kn">from</span> <span class="nn">compiler</span> <span class="n">to</span>
    <span class="o">//</span> <span class="n">compiler</span><span class="o">.</span>  <span class="n">Inspect</span> <span class="n">the</span> <span class="n">demos</span> <span class="k">for</span> <span class="n">the</span> <span class="n">port</span> <span class="n">you</span> <span class="n">are</span> <span class="n">using</span> <span class="n">to</span> <span class="n">find</span> <span class="n">the</span>
    <span class="o">//</span> <span class="n">actual</span> <span class="n">syntax</span> <span class="n">required</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">!=</span> <span class="n">pdFALSE</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Call</span> <span class="n">the</span> <span class="n">interrupt</span> <span class="n">safe</span> <span class="k">yield</span> <span class="n">function</span> <span class="n">here</span> <span class="p">(</span><span class="n">actual</span> <span class="n">function</span>
        <span class="o">//</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FreeRTOS</span> <span class="n">port</span> <span class="n">being</span> <span class="n">used</span><span class="p">)</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdFAIL will be returned if the start command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerStartFromISR() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: The handle of the timer being started/restarted.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>: The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerStartFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling xTimerStartFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerStartFromISR() function. If xTimerStartFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt exits.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xTimerStopFromISR">
<span class="target" id="timers_8h_1aef0f53e7ecfaa881621da83d61072db7"></span><code class="descname">xTimerStopFromISR</code><span class="sig-paren">(</span>xTimer, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="#c.xTimerStopFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>A version of xTimerStop() that can be called from an interrupt service routine.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">This</span> <span class="n">scenario</span> <span class="n">assumes</span> <span class="n">xTimer</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span> <span class="ow">and</span> <span class="n">started</span><span class="o">.</span>  <span class="n">When</span>
<span class="o">//</span> <span class="n">an</span> <span class="n">interrupt</span> <span class="n">occurs</span><span class="p">,</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">should</span> <span class="n">be</span> <span class="n">simply</span> <span class="n">stopped</span><span class="o">.</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span> <span class="n">that</span> <span class="n">stops</span> <span class="n">the</span> <span class="n">timer</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vAnExampleInterruptServiceRoutine</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">The</span> <span class="n">interrupt</span> <span class="n">has</span> <span class="n">occurred</span> <span class="o">-</span> <span class="n">simply</span> <span class="n">stop</span> <span class="n">the</span> <span class="n">timer</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">was</span> <span class="nb">set</span> <span class="n">to</span> <span class="n">pdFALSE</span> <span class="n">where</span> <span class="n">it</span> <span class="n">was</span> <span class="n">defined</span>
    <span class="o">//</span> <span class="p">(</span><span class="n">within</span> <span class="n">this</span> <span class="n">function</span><span class="p">)</span><span class="o">.</span>  <span class="n">As</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span><span class="p">,</span> <span class="n">only</span>
    <span class="o">//</span> <span class="n">FreeRTOS</span> <span class="n">API</span> <span class="n">functions</span> <span class="n">that</span> <span class="n">end</span> <span class="ow">in</span> <span class="s2">&quot;FromISR&quot;</span> <span class="n">can</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xTimerStopFromISR</span><span class="p">(</span> <span class="n">xTimer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">The</span> <span class="n">stop</span> <span class="n">command</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">executed</span> <span class="n">successfully</span><span class="o">.</span>  <span class="n">Take</span> <span class="n">appropriate</span>
        <span class="o">//</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">If</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">equals</span> <span class="n">pdTRUE</span><span class="p">,</span> <span class="n">then</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
    <span class="o">//</span> <span class="n">should</span> <span class="n">be</span> <span class="n">performed</span><span class="o">.</span>  <span class="n">The</span> <span class="n">syntax</span> <span class="n">required</span> <span class="n">to</span> <span class="n">perform</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
    <span class="o">//</span> <span class="kn">from</span> <span class="nn">inside</span> <span class="n">an</span> <span class="n">ISR</span> <span class="n">varies</span> <span class="kn">from</span> <span class="nn">port</span> <span class="n">to</span> <span class="n">port</span><span class="p">,</span> <span class="ow">and</span> <span class="kn">from</span> <span class="nn">compiler</span> <span class="n">to</span>
    <span class="o">//</span> <span class="n">compiler</span><span class="o">.</span>  <span class="n">Inspect</span> <span class="n">the</span> <span class="n">demos</span> <span class="k">for</span> <span class="n">the</span> <span class="n">port</span> <span class="n">you</span> <span class="n">are</span> <span class="n">using</span> <span class="n">to</span> <span class="n">find</span> <span class="n">the</span>
    <span class="o">//</span> <span class="n">actual</span> <span class="n">syntax</span> <span class="n">required</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">!=</span> <span class="n">pdFALSE</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Call</span> <span class="n">the</span> <span class="n">interrupt</span> <span class="n">safe</span> <span class="k">yield</span> <span class="n">function</span> <span class="n">here</span> <span class="p">(</span><span class="n">actual</span> <span class="n">function</span>
        <span class="o">//</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FreeRTOS</span> <span class="n">port</span> <span class="n">being</span> <span class="n">used</span><span class="p">)</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdFAIL will be returned if the stop command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: The handle of the timer being stopped.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>: The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerStopFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling xTimerStopFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerStopFromISR() function. If xTimerStopFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt exits.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xTimerChangePeriodFromISR">
<span class="target" id="timers_8h_1a6d89ca6afb6e692e98932b5038c9e14a"></span><code class="descname">xTimerChangePeriodFromISR</code><span class="sig-paren">(</span>xTimer, xNewPeriod, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="#c.xTimerChangePeriodFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>A version of xTimerChangePeriod() that can be called from an interrupt service routine.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">This</span> <span class="n">scenario</span> <span class="n">assumes</span> <span class="n">xTimer</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span> <span class="ow">and</span> <span class="n">started</span><span class="o">.</span>  <span class="n">When</span>
<span class="o">//</span> <span class="n">an</span> <span class="n">interrupt</span> <span class="n">occurs</span><span class="p">,</span> <span class="n">the</span> <span class="n">period</span> <span class="n">of</span> <span class="n">xTimer</span> <span class="n">should</span> <span class="n">be</span> <span class="n">changed</span> <span class="n">to</span> <span class="mi">500</span><span class="n">ms</span><span class="o">.</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span> <span class="n">that</span> <span class="n">changes</span> <span class="n">the</span> <span class="n">period</span> <span class="n">of</span> <span class="n">xTimer</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vAnExampleInterruptServiceRoutine</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">The</span> <span class="n">interrupt</span> <span class="n">has</span> <span class="n">occurred</span> <span class="o">-</span> <span class="n">change</span> <span class="n">the</span> <span class="n">period</span> <span class="n">of</span> <span class="n">xTimer</span> <span class="n">to</span> <span class="mi">500</span><span class="n">ms</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">was</span> <span class="nb">set</span> <span class="n">to</span> <span class="n">pdFALSE</span> <span class="n">where</span> <span class="n">it</span> <span class="n">was</span> <span class="n">defined</span>
    <span class="o">//</span> <span class="p">(</span><span class="n">within</span> <span class="n">this</span> <span class="n">function</span><span class="p">)</span><span class="o">.</span>  <span class="n">As</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span><span class="p">,</span> <span class="n">only</span>
    <span class="o">//</span> <span class="n">FreeRTOS</span> <span class="n">API</span> <span class="n">functions</span> <span class="n">that</span> <span class="n">end</span> <span class="ow">in</span> <span class="s2">&quot;FromISR&quot;</span> <span class="n">can</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xTimerChangePeriodFromISR</span><span class="p">(</span> <span class="n">xTimer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">The</span> <span class="n">command</span> <span class="n">to</span> <span class="n">change</span> <span class="n">the</span> <span class="n">timers</span> <span class="n">period</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">executed</span>
        <span class="o">//</span> <span class="n">successfully</span><span class="o">.</span>  <span class="n">Take</span> <span class="n">appropriate</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">If</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">equals</span> <span class="n">pdTRUE</span><span class="p">,</span> <span class="n">then</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
    <span class="o">//</span> <span class="n">should</span> <span class="n">be</span> <span class="n">performed</span><span class="o">.</span>  <span class="n">The</span> <span class="n">syntax</span> <span class="n">required</span> <span class="n">to</span> <span class="n">perform</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
    <span class="o">//</span> <span class="kn">from</span> <span class="nn">inside</span> <span class="n">an</span> <span class="n">ISR</span> <span class="n">varies</span> <span class="kn">from</span> <span class="nn">port</span> <span class="n">to</span> <span class="n">port</span><span class="p">,</span> <span class="ow">and</span> <span class="kn">from</span> <span class="nn">compiler</span> <span class="n">to</span>
    <span class="o">//</span> <span class="n">compiler</span><span class="o">.</span>  <span class="n">Inspect</span> <span class="n">the</span> <span class="n">demos</span> <span class="k">for</span> <span class="n">the</span> <span class="n">port</span> <span class="n">you</span> <span class="n">are</span> <span class="n">using</span> <span class="n">to</span> <span class="n">find</span> <span class="n">the</span>
    <span class="o">//</span> <span class="n">actual</span> <span class="n">syntax</span> <span class="n">required</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">!=</span> <span class="n">pdFALSE</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Call</span> <span class="n">the</span> <span class="n">interrupt</span> <span class="n">safe</span> <span class="k">yield</span> <span class="n">function</span> <span class="n">here</span> <span class="p">(</span><span class="n">actual</span> <span class="n">function</span>
        <span class="o">//</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FreeRTOS</span> <span class="n">port</span> <span class="n">being</span> <span class="n">used</span><span class="p">)</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdFAIL will be returned if the command to change the timers period could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: The handle of the timer that is having its period changed.</li>
<li><code class="docutils literal notranslate"><span class="pre">xNewPeriod</span></code>: The new period for xTimer. Timer periods are specified in tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xNewPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then xNewPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>: The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerChangePeriodFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/ daemon task out of the Blocked state. If calling xTimerChangePeriodFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerChangePeriodFromISR() function. If xTimerChangePeriodFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt exits.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xTimerResetFromISR">
<span class="target" id="timers_8h_1a448138d0cebf76044f107ca56c842230"></span><code class="descname">xTimerResetFromISR</code><span class="sig-paren">(</span>xTimer, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="#c.xTimerResetFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>A version of xTimerReset() that can be called from an interrupt service routine.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">This</span> <span class="n">scenario</span> <span class="n">assumes</span> <span class="n">xBacklightTimer</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span><span class="o">.</span>  <span class="n">When</span> <span class="n">a</span>
<span class="o">//</span> <span class="n">key</span> <span class="ow">is</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">an</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">switched</span> <span class="n">on</span><span class="o">.</span>  <span class="n">If</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="k">pass</span>
<span class="o">//</span> <span class="n">without</span> <span class="n">a</span> <span class="n">key</span> <span class="n">being</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">then</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">switched</span> <span class="n">off</span><span class="o">.</span>  <span class="n">In</span>
<span class="o">//</span> <span class="n">this</span> <span class="n">case</span><span class="p">,</span> <span class="n">the</span> <span class="n">timer</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="p">,</span> <span class="ow">and</span> <span class="n">unlike</span> <span class="n">the</span> <span class="n">example</span> <span class="n">given</span> <span class="k">for</span>
<span class="o">//</span> <span class="n">the</span> <span class="n">xTimerReset</span><span class="p">()</span> <span class="n">function</span><span class="p">,</span> <span class="n">the</span> <span class="n">key</span> <span class="n">press</span> <span class="n">event</span> <span class="n">handler</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">interrupt</span>
<span class="o">//</span> <span class="n">service</span> <span class="n">routine</span><span class="o">.</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">assigned</span> <span class="n">to</span> <span class="n">the</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="o">.</span>  <span class="n">In</span> <span class="n">this</span> <span class="n">case</span> <span class="n">the</span>
<span class="o">//</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vBacklightTimerCallback</span><span class="p">(</span> <span class="n">TimerHandle_t</span> <span class="n">pxTimer</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="n">expired</span><span class="p">,</span> <span class="n">therefore</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="n">must</span> <span class="n">have</span> <span class="n">passed</span> <span class="n">since</span> <span class="n">a</span> <span class="n">key</span>
    <span class="o">//</span> <span class="n">was</span> <span class="n">pressed</span><span class="o">.</span>  <span class="n">Switch</span> <span class="n">off</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span><span class="o">.</span>
    <span class="n">vSetBacklightState</span><span class="p">(</span> <span class="n">BACKLIGHT_OFF</span> <span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">key</span> <span class="n">press</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vKeyPressEventInterruptHandler</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Ensure</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">on</span><span class="p">,</span> <span class="n">then</span> <span class="n">reset</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">that</span> <span class="ow">is</span>
    <span class="o">//</span> <span class="n">responsible</span> <span class="k">for</span> <span class="n">turning</span> <span class="n">the</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="n">off</span> <span class="n">after</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="n">of</span>
    <span class="o">//</span> <span class="n">key</span> <span class="n">inactivity</span><span class="o">.</span>  <span class="n">This</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span> <span class="n">so</span> <span class="n">can</span> <span class="n">only</span>
    <span class="o">//</span> <span class="n">call</span> <span class="n">FreeRTOS</span> <span class="n">API</span> <span class="n">functions</span> <span class="n">that</span> <span class="n">end</span> <span class="ow">in</span> <span class="s2">&quot;FromISR&quot;</span><span class="o">.</span>
    <span class="n">vSetBacklightState</span><span class="p">(</span> <span class="n">BACKLIGHT_ON</span> <span class="p">);</span>

    <span class="o">//</span> <span class="n">xTimerStartFromISR</span><span class="p">()</span> <span class="ow">or</span> <span class="n">xTimerResetFromISR</span><span class="p">()</span> <span class="n">could</span> <span class="n">be</span> <span class="n">called</span> <span class="n">here</span>
    <span class="o">//</span> <span class="k">as</span> <span class="n">both</span> <span class="n">cause</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">to</span> <span class="n">re</span><span class="o">-</span><span class="n">calculate</span> <span class="n">its</span> <span class="n">expiry</span> <span class="n">time</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">was</span> <span class="n">initialised</span> <span class="n">to</span> <span class="n">pdFALSE</span> <span class="n">when</span> <span class="n">it</span> <span class="n">was</span>
    <span class="o">//</span> <span class="n">declared</span> <span class="p">(</span><span class="ow">in</span> <span class="n">this</span> <span class="n">function</span><span class="p">)</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xTimerResetFromISR</span><span class="p">(</span> <span class="n">xBacklightTimer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">The</span> <span class="n">reset</span> <span class="n">command</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">executed</span> <span class="n">successfully</span><span class="o">.</span>  <span class="n">Take</span> <span class="n">appropriate</span>
        <span class="o">//</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">Perform</span> <span class="n">the</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">the</span> <span class="n">key</span> <span class="n">processing</span> <span class="n">here</span><span class="o">.</span>

    <span class="o">//</span> <span class="n">If</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">equals</span> <span class="n">pdTRUE</span><span class="p">,</span> <span class="n">then</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
    <span class="o">//</span> <span class="n">should</span> <span class="n">be</span> <span class="n">performed</span><span class="o">.</span>  <span class="n">The</span> <span class="n">syntax</span> <span class="n">required</span> <span class="n">to</span> <span class="n">perform</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
    <span class="o">//</span> <span class="kn">from</span> <span class="nn">inside</span> <span class="n">an</span> <span class="n">ISR</span> <span class="n">varies</span> <span class="kn">from</span> <span class="nn">port</span> <span class="n">to</span> <span class="n">port</span><span class="p">,</span> <span class="ow">and</span> <span class="kn">from</span> <span class="nn">compiler</span> <span class="n">to</span>
    <span class="o">//</span> <span class="n">compiler</span><span class="o">.</span>  <span class="n">Inspect</span> <span class="n">the</span> <span class="n">demos</span> <span class="k">for</span> <span class="n">the</span> <span class="n">port</span> <span class="n">you</span> <span class="n">are</span> <span class="n">using</span> <span class="n">to</span> <span class="n">find</span> <span class="n">the</span>
    <span class="o">//</span> <span class="n">actual</span> <span class="n">syntax</span> <span class="n">required</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">!=</span> <span class="n">pdFALSE</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Call</span> <span class="n">the</span> <span class="n">interrupt</span> <span class="n">safe</span> <span class="k">yield</span> <span class="n">function</span> <span class="n">here</span> <span class="p">(</span><span class="n">actual</span> <span class="n">function</span>
        <span class="o">//</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FreeRTOS</span> <span class="n">port</span> <span class="n">being</span> <span class="n">used</span><span class="p">)</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pdFAIL will be returned if the reset command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerResetFromISR() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: The handle of the timer that is to be started, reset, or restarted.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>: The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerResetFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling xTimerResetFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerResetFromISR() function. If xTimerResetFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt exits.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="id11">
<h3>Type Definitions<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv413TimerHandle_t">
<span id="_CPPv313TimerHandle_t"></span><span id="_CPPv213TimerHandle_t"></span><span id="TimerHandle_t"></span><span class="target" id="timers_8h_1aae4bf1dce696ab615d5fd073606fd3cb"></span><em class="property">typedef </em>void *<code class="descname">TimerHandle_t</code><a class="headerlink" href="#_CPPv413TimerHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Type by which software timers are referenced. For example, a call to xTimerCreate() returns an TimerHandle_t variable that can then be used to reference the subject timer in calls to other software timer API functions (for example, xTimerStart(), xTimerReset(), etc.). </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv423TimerCallbackFunction_t">
<span id="_CPPv323TimerCallbackFunction_t"></span><span id="_CPPv223TimerCallbackFunction_t"></span><span id="TimerCallbackFunction_t"></span><span class="target" id="timers_8h_1a5cf6d1f61ccd4871022ed8ad454c6027"></span><em class="property">typedef </em>void (*<code class="descname">TimerCallbackFunction_t</code>)<span class="sig-paren">(</span><a class="reference internal" href="#_CPPv413TimerHandle_t" title="TimerHandle_t">TimerHandle_t</a> xTimer<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423TimerCallbackFunction_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Defines the prototype to which timer callback functions must conform. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv416PendedFunction_t">
<span id="_CPPv316PendedFunction_t"></span><span id="_CPPv216PendedFunction_t"></span><span id="PendedFunction_t"></span><span class="target" id="timers_8h_1af6e8e2be58df2be9f9bb808fcdc51622"></span><em class="property">typedef </em>void (*<code class="descname">PendedFunction_t</code>)<span class="sig-paren">(</span>void *, uint32_t<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416PendedFunction_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Defines the prototype to which functions used with the xTimerPendFunctionCallFromISR() function must conform. </p>
</dd></dl>

</div>
</div>
<div class="section" id="event-group-api">
<h2>Event Group API<a class="headerlink" href="#event-group-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id12">
<h3>Header File<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/freertos/include/freertos/event_groups.h">freertos/include/freertos/event_groups.h</a></li>
</ul>
</div>
<div class="section" id="id13">
<h3>Functions<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv417xEventGroupCreatev">
<span id="_CPPv317xEventGroupCreatev"></span><span id="_CPPv217xEventGroupCreatev"></span><span id="xEventGroupCreate__void"></span><span class="target" id="event__groups_8h_1a7ed741a0902718aca9c8d3ca273f1b73"></span><a class="reference internal" href="#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t">EventGroupHandle_t</a> <code class="descname">xEventGroupCreate</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417xEventGroupCreatev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new event group.</p>
<p>Internally, within the FreeRTOS implementation, event groups use a [small] block of memory, in which the event group’s structure is stored. If an event groups is created using xEventGroupCreate() then the required memory is automatically dynamically allocated inside the xEventGroupCreate() function. (see <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). If an event group is created using xEventGropuCreateStatic() then the application writer must instead provide the memory that will get used by the event group. xEventGroupCreateStatic() therefore allows an event group to be created without using any dynamic memory allocation.</p>
<p>Although event groups are not related to ticks, for internal implementation reasons the number of bits available for use in an event group is dependent on the configUSE_16_BIT_TICKS setting in FreeRTOSConfig.h. If configUSE_16_BIT_TICKS is 1 then each event group contains 8 usable bits (bit 0 to bit 7). If configUSE_16_BIT_TICKS is set to 0 then each event group has 24 usable bits (bit 0 to bit 23). The EventBits_t type is used to store event bits within an event group.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Declare a variable to hold the created event group.
EventGroupHandle_t xCreatedEventGroup;

// Attempt to create the event group.
xCreatedEventGroup = xEventGroupCreate();

// Was the event group created successfully?
if( xCreatedEventGroup == NULL )
{
    // The event group was not created because there was insufficient
    // FreeRTOS heap available.
}
else
{
    // The event group was created.
}
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If the event group was created then a handle to the event group is returned. If there was insufficient FreeRTOS heap available to create the event group then NULL is returned. See <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a></dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423xEventGroupCreateStaticP18StaticEventGroup_t">
<span id="_CPPv323xEventGroupCreateStaticP18StaticEventGroup_t"></span><span id="_CPPv223xEventGroupCreateStaticP18StaticEventGroup_t"></span><span id="xEventGroupCreateStatic__StaticEventGroup_tP"></span><span class="target" id="event__groups_8h_1a19fff40ab0121395db2b2c8a823ec7e6"></span><a class="reference internal" href="#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t">EventGroupHandle_t</a> <code class="descname">xEventGroupCreateStatic</code><span class="sig-paren">(</span>StaticEventGroup_t *<em>pxEventGroupBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423xEventGroupCreateStaticP18StaticEventGroup_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new event group.</p>
<p>Internally, within the FreeRTOS implementation, event groups use a [small] block of memory, in which the event group’s structure is stored. If an event groups is created using xEventGropuCreate() then the required memory is automatically dynamically allocated inside the xEventGroupCreate() function. (see <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). If an event group is created using xEventGropuCreateStatic() then the application writer must instead provide the memory that will get used by the event group. xEventGroupCreateStatic() therefore allows an event group to be created without using any dynamic memory allocation.</p>
<p>Although event groups are not related to ticks, for internal implementation reasons the number of bits available for use in an event group is dependent on the configUSE_16_BIT_TICKS setting in FreeRTOSConfig.h. If configUSE_16_BIT_TICKS is 1 then each event group contains 8 usable bits (bit 0 to bit 7). If configUSE_16_BIT_TICKS is set to 0 then each event group has 24 usable bits (bit 0 to bit 23). The EventBits_t type is used to store event bits within an event group.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">StaticEventGroup_t</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">publicly</span> <span class="n">accessible</span> <span class="n">structure</span> <span class="n">that</span> <span class="n">has</span> <span class="n">the</span> <span class="n">same</span>
<span class="o">//</span> <span class="n">size</span> <span class="ow">and</span> <span class="n">alignment</span> <span class="n">requirements</span> <span class="k">as</span> <span class="n">the</span> <span class="n">real</span> <span class="n">event</span> <span class="n">group</span> <span class="n">structure</span><span class="o">.</span>  <span class="n">It</span> <span class="ow">is</span>
<span class="o">//</span> <span class="n">provided</span> <span class="k">as</span> <span class="n">a</span> <span class="n">mechanism</span> <span class="k">for</span> <span class="n">applications</span> <span class="n">to</span> <span class="n">know</span> <span class="n">the</span> <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">event</span>
<span class="o">//</span> <span class="n">group</span> <span class="p">(</span><span class="n">which</span> <span class="ow">is</span> <span class="n">dependent</span> <span class="n">on</span> <span class="n">the</span> <span class="n">architecture</span> <span class="ow">and</span> <span class="n">configuration</span> <span class="n">file</span>
<span class="o">//</span> <span class="n">settings</span><span class="p">)</span> <span class="n">without</span> <span class="n">breaking</span> <span class="n">the</span> <span class="n">strict</span> <span class="n">data</span> <span class="n">hiding</span> <span class="n">policy</span> <span class="n">by</span> <span class="n">exposing</span> <span class="n">the</span>
<span class="o">//</span> <span class="n">real</span> <span class="n">event</span> <span class="n">group</span> <span class="n">internals</span><span class="o">.</span>  <span class="n">This</span> <span class="n">StaticEventGroup_t</span> <span class="n">variable</span> <span class="ow">is</span> <span class="n">passed</span>
<span class="o">//</span> <span class="n">into</span> <span class="n">the</span> <span class="n">xSemaphoreCreateEventGroupStatic</span><span class="p">()</span> <span class="n">function</span> <span class="ow">and</span> <span class="ow">is</span> <span class="n">used</span> <span class="n">to</span> <span class="n">store</span>
<span class="o">//</span> <span class="n">the</span> <span class="n">event</span> <span class="n">group</span><span class="s1">&#39;s data structures</span>
<span class="n">StaticEventGroup_t</span> <span class="n">xEventGroupBuffer</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">event</span> <span class="n">group</span> <span class="n">without</span> <span class="n">dynamically</span> <span class="n">allocating</span> <span class="nb">any</span> <span class="n">memory</span><span class="o">.</span>
<span class="n">xEventGroup</span> <span class="o">=</span> <span class="n">xEventGroupCreateStatic</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">xEventGroupBuffer</span> <span class="p">);</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If the event group was created then a handle to the event group is returned. If pxEventGroupBuffer was NULL then NULL is returned.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pxEventGroupBuffer</span></code>: pxEventGroupBuffer must point to a variable of type StaticEventGroup_t, which will be then be used to hold the event group’s data structures, removing the need for the memory to be allocated dynamically.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419xEventGroupWaitBits18EventGroupHandle_tK11EventBits_tK10BaseType_tK10BaseType_t10TickType_t">
<span id="_CPPv319xEventGroupWaitBits18EventGroupHandle_tK11EventBits_tK10BaseType_tK10BaseType_t10TickType_t"></span><span id="_CPPv219xEventGroupWaitBits18EventGroupHandle_tK11EventBits_tK10BaseType_tK10BaseType_t10TickType_t"></span><span id="xEventGroupWaitBits__EventGroupHandle_t.EventBits_tC.BaseType_tC.BaseType_tC.TickType_t"></span><span class="target" id="event__groups_8h_1aab9d5b405bc57b7624dcabe9a9a503db"></span><a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <code class="descname">xEventGroupWaitBits</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t">EventGroupHandle_t</a> <em>xEventGroup</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <em>uxBitsToWaitFor</em>, <em class="property">const</em> BaseType_t <em>xClearOnExit</em>, <em class="property">const</em> BaseType_t <em>xWaitForAllBits</em>, TickType_t <em>xTicksToWait</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419xEventGroupWaitBits18EventGroupHandle_tK11EventBits_tK10BaseType_tK10BaseType_t10TickType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>[Potentially] block to wait for one or more bits to be set within a previously created event group.</p>
<p>This function cannot be called from an interrupt.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define BIT_0    ( 1 &lt;&lt; 0 )</span>
<span class="c1">#define BIT_4    ( 1 &lt;&lt; 4 )</span>

<span class="n">void</span> <span class="n">aFunction</span><span class="p">(</span> <span class="n">EventGroupHandle_t</span> <span class="n">xEventGroup</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">EventBits_t</span> <span class="n">uxBits</span><span class="p">;</span>
<span class="n">const</span> <span class="n">TickType_t</span> <span class="n">xTicksToWait</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">portTICK_PERIOD_MS</span><span class="p">;</span>

     <span class="o">//</span> <span class="n">Wait</span> <span class="n">a</span> <span class="n">maximum</span> <span class="n">of</span> <span class="mi">100</span><span class="n">ms</span> <span class="k">for</span> <span class="n">either</span> <span class="n">bit</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">bit</span> <span class="mi">4</span> <span class="n">to</span> <span class="n">be</span> <span class="nb">set</span> <span class="n">within</span>
     <span class="o">//</span> <span class="n">the</span> <span class="n">event</span> <span class="n">group</span><span class="o">.</span>  <span class="n">Clear</span> <span class="n">the</span> <span class="n">bits</span> <span class="n">before</span> <span class="n">exiting</span><span class="o">.</span>
     <span class="n">uxBits</span> <span class="o">=</span> <span class="n">xEventGroupWaitBits</span><span class="p">(</span>
                 <span class="n">xEventGroup</span><span class="p">,</span>    <span class="o">//</span> <span class="n">The</span> <span class="n">event</span> <span class="n">group</span> <span class="n">being</span> <span class="n">tested</span><span class="o">.</span>
                 <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span><span class="p">,</span>  <span class="o">//</span> <span class="n">The</span> <span class="n">bits</span> <span class="n">within</span> <span class="n">the</span> <span class="n">event</span> <span class="n">group</span> <span class="n">to</span> <span class="n">wait</span> <span class="k">for</span><span class="o">.</span>
                 <span class="n">pdTRUE</span><span class="p">,</span>         <span class="o">//</span> <span class="n">BIT_0</span> <span class="ow">and</span> <span class="n">BIT_4</span> <span class="n">should</span> <span class="n">be</span> <span class="n">cleared</span> <span class="n">before</span> <span class="n">returning</span><span class="o">.</span>
                 <span class="n">pdFALSE</span><span class="p">,</span>        <span class="o">//</span> <span class="n">Don</span><span class="s1">&#39;t wait for both bits, either bit will do.</span>
                 <span class="n">xTicksToWait</span> <span class="p">);</span> <span class="o">//</span> <span class="n">Wait</span> <span class="n">a</span> <span class="n">maximum</span> <span class="n">of</span> <span class="mi">100</span><span class="n">ms</span> <span class="k">for</span> <span class="n">either</span> <span class="n">bit</span> <span class="n">to</span> <span class="n">be</span> <span class="nb">set</span><span class="o">.</span>

     <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxBits</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span> <span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="p">(</span> <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span> <span class="p">)</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">xEventGroupWaitBits</span><span class="p">()</span> <span class="n">returned</span> <span class="n">because</span> <span class="n">both</span> <span class="n">bits</span> <span class="n">were</span> <span class="nb">set</span><span class="o">.</span>
     <span class="p">}</span>
     <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxBits</span> <span class="o">&amp;</span> <span class="n">BIT_0</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">xEventGroupWaitBits</span><span class="p">()</span> <span class="n">returned</span> <span class="n">because</span> <span class="n">just</span> <span class="n">BIT_0</span> <span class="n">was</span> <span class="nb">set</span><span class="o">.</span>
     <span class="p">}</span>
     <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxBits</span> <span class="o">&amp;</span> <span class="n">BIT_4</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">xEventGroupWaitBits</span><span class="p">()</span> <span class="n">returned</span> <span class="n">because</span> <span class="n">just</span> <span class="n">BIT_4</span> <span class="n">was</span> <span class="nb">set</span><span class="o">.</span>
     <span class="p">}</span>
     <span class="k">else</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">xEventGroupWaitBits</span><span class="p">()</span> <span class="n">returned</span> <span class="n">because</span> <span class="n">xTicksToWait</span> <span class="n">ticks</span> <span class="n">passed</span>
         <span class="o">//</span> <span class="n">without</span> <span class="n">either</span> <span class="n">BIT_0</span> <span class="ow">or</span> <span class="n">BIT_4</span> <span class="n">becoming</span> <span class="nb">set</span><span class="o">.</span>
     <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
{c} <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The value of the event group at the time either the bits being waited for became set, or the block time expired. Test the return value to know which bits were set. If xEventGroupWaitBits() returned because its timeout expired then not all the bits being waited for will be set. If xEventGroupWaitBits() returned because the bits it was waiting for were set then the returned value is the event group value before any bits were automatically cleared in the case that xClearOnExit parameter was set to pdTRUE.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xEventGroup</span></code>: The event group in which the bits are being tested. The event group must have previously been created using a call to xEventGroupCreate().</li>
<li><code class="docutils literal notranslate"><span class="pre">uxBitsToWaitFor</span></code>: A bitwise value that indicates the bit or bits to test inside the event group. For example, to wait for bit 0 and/or bit 2 set uxBitsToWaitFor to 0x05. To wait for bits 0 and/or bit 1 and/or bit 2 set uxBitsToWaitFor to 0x07. Etc.</li>
<li><code class="docutils literal notranslate"><span class="pre">xClearOnExit</span></code>: If xClearOnExit is set to pdTRUE then any bits within uxBitsToWaitFor that are set within the event group will be cleared before xEventGroupWaitBits() returns if the wait condition was met (if the function returns for a reason other than a timeout). If xClearOnExit is set to pdFALSE then the bits set in the event group are not altered when the call to xEventGroupWaitBits() returns.</li>
<li><code class="docutils literal notranslate"><span class="pre">xWaitForAllBits</span></code>: If xWaitForAllBits is set to pdTRUE then xEventGroupWaitBits() will return when either all the bits in uxBitsToWaitFor are set or the specified block time expires. If xWaitForAllBits is set to pdFALSE then xEventGroupWaitBits() will return when any one of the bits set in uxBitsToWaitFor is set or the specified block time expires. The block time is specified by the xTicksToWait parameter.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: The maximum amount of time (specified in ‘ticks’) to wait for one/all (depending on the xWaitForAllBits value) of the bits specified by uxBitsToWaitFor to become set.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420xEventGroupClearBits18EventGroupHandle_tK11EventBits_t">
<span id="_CPPv320xEventGroupClearBits18EventGroupHandle_tK11EventBits_t"></span><span id="_CPPv220xEventGroupClearBits18EventGroupHandle_tK11EventBits_t"></span><span id="xEventGroupClearBits__EventGroupHandle_t.EventBits_tC"></span><span class="target" id="event__groups_8h_1a0fb72cfdd4f0d5f86d955fc3af448f2a"></span><a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <code class="descname">xEventGroupClearBits</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t">EventGroupHandle_t</a> <em>xEventGroup</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <em>uxBitsToClear</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420xEventGroupClearBits18EventGroupHandle_tK11EventBits_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear bits within an event group. This function cannot be called from an interrupt.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define BIT_0    ( 1 &lt;&lt; 0 )</span>
<span class="c1">#define BIT_4    ( 1 &lt;&lt; 4 )</span>

<span class="n">void</span> <span class="n">aFunction</span><span class="p">(</span> <span class="n">EventGroupHandle_t</span> <span class="n">xEventGroup</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">EventBits_t</span> <span class="n">uxBits</span><span class="p">;</span>

     <span class="o">//</span> <span class="n">Clear</span> <span class="n">bit</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">bit</span> <span class="mi">4</span> <span class="ow">in</span> <span class="n">xEventGroup</span><span class="o">.</span>
     <span class="n">uxBits</span> <span class="o">=</span> <span class="n">xEventGroupClearBits</span><span class="p">(</span>
                             <span class="n">xEventGroup</span><span class="p">,</span>    <span class="o">//</span> <span class="n">The</span> <span class="n">event</span> <span class="n">group</span> <span class="n">being</span> <span class="n">updated</span><span class="o">.</span>
                             <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span> <span class="p">);</span><span class="o">//</span> <span class="n">The</span> <span class="n">bits</span> <span class="n">being</span> <span class="n">cleared</span><span class="o">.</span>

     <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxBits</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span> <span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="p">(</span> <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span> <span class="p">)</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">Both</span> <span class="n">bit</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">bit</span> <span class="mi">4</span> <span class="n">were</span> <span class="nb">set</span> <span class="n">before</span> <span class="n">xEventGroupClearBits</span><span class="p">()</span> <span class="n">was</span>
         <span class="o">//</span> <span class="n">called</span><span class="o">.</span>  <span class="n">Both</span> <span class="n">will</span> <span class="n">now</span> <span class="n">be</span> <span class="n">clear</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">set</span><span class="p">)</span><span class="o">.</span>
     <span class="p">}</span>
     <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxBits</span> <span class="o">&amp;</span> <span class="n">BIT_0</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">Bit</span> <span class="mi">0</span> <span class="n">was</span> <span class="nb">set</span> <span class="n">before</span> <span class="n">xEventGroupClearBits</span><span class="p">()</span> <span class="n">was</span> <span class="n">called</span><span class="o">.</span>  <span class="n">It</span> <span class="n">will</span>
         <span class="o">//</span> <span class="n">now</span> <span class="n">be</span> <span class="n">clear</span><span class="o">.</span>
     <span class="p">}</span>
     <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxBits</span> <span class="o">&amp;</span> <span class="n">BIT_4</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">Bit</span> <span class="mi">4</span> <span class="n">was</span> <span class="nb">set</span> <span class="n">before</span> <span class="n">xEventGroupClearBits</span><span class="p">()</span> <span class="n">was</span> <span class="n">called</span><span class="o">.</span>  <span class="n">It</span> <span class="n">will</span>
         <span class="o">//</span> <span class="n">now</span> <span class="n">be</span> <span class="n">clear</span><span class="o">.</span>
     <span class="p">}</span>
     <span class="k">else</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">Neither</span> <span class="n">bit</span> <span class="mi">0</span> <span class="n">nor</span> <span class="n">bit</span> <span class="mi">4</span> <span class="n">were</span> <span class="nb">set</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">first</span> <span class="n">place</span><span class="o">.</span>
     <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The value of the event group before the specified bits were cleared.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xEventGroup</span></code>: The event group in which the bits are to be cleared.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxBitsToClear</span></code>: A bitwise value that indicates the bit or bits to clear in the event group. For example, to clear bit 3 only, set uxBitsToClear to 0x08. To clear bit 3 and bit 0 set uxBitsToClear to 0x09.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418xEventGroupSetBits18EventGroupHandle_tK11EventBits_t">
<span id="_CPPv318xEventGroupSetBits18EventGroupHandle_tK11EventBits_t"></span><span id="_CPPv218xEventGroupSetBits18EventGroupHandle_tK11EventBits_t"></span><span id="xEventGroupSetBits__EventGroupHandle_t.EventBits_tC"></span><span class="target" id="event__groups_8h_1a02d7b3bb55f7e11d9c47116266c5fb2e"></span><a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <code class="descname">xEventGroupSetBits</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t">EventGroupHandle_t</a> <em>xEventGroup</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <em>uxBitsToSet</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418xEventGroupSetBits18EventGroupHandle_tK11EventBits_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set bits within an event group. This function cannot be called from an interrupt. xEventGroupSetBitsFromISR() is a version that can be called from an interrupt.</p>
<p>Setting bits in an event group will automatically unblock tasks that are blocked waiting for the bits.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define BIT_0    ( 1 &lt;&lt; 0 )</span>
<span class="c1">#define BIT_4    ( 1 &lt;&lt; 4 )</span>

<span class="n">void</span> <span class="n">aFunction</span><span class="p">(</span> <span class="n">EventGroupHandle_t</span> <span class="n">xEventGroup</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">EventBits_t</span> <span class="n">uxBits</span><span class="p">;</span>

     <span class="o">//</span> <span class="n">Set</span> <span class="n">bit</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">bit</span> <span class="mi">4</span> <span class="ow">in</span> <span class="n">xEventGroup</span><span class="o">.</span>
     <span class="n">uxBits</span> <span class="o">=</span> <span class="n">xEventGroupSetBits</span><span class="p">(</span>
                         <span class="n">xEventGroup</span><span class="p">,</span>    <span class="o">//</span> <span class="n">The</span> <span class="n">event</span> <span class="n">group</span> <span class="n">being</span> <span class="n">updated</span><span class="o">.</span>
                         <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span> <span class="p">);</span><span class="o">//</span> <span class="n">The</span> <span class="n">bits</span> <span class="n">being</span> <span class="nb">set</span><span class="o">.</span>

     <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxBits</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span> <span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="p">(</span> <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span> <span class="p">)</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">Both</span> <span class="n">bit</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">bit</span> <span class="mi">4</span> <span class="n">remained</span> <span class="nb">set</span> <span class="n">when</span> <span class="n">the</span> <span class="n">function</span> <span class="n">returned</span><span class="o">.</span>
     <span class="p">}</span>
     <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxBits</span> <span class="o">&amp;</span> <span class="n">BIT_0</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">Bit</span> <span class="mi">0</span> <span class="n">remained</span> <span class="nb">set</span> <span class="n">when</span> <span class="n">the</span> <span class="n">function</span> <span class="n">returned</span><span class="p">,</span> <span class="n">but</span> <span class="n">bit</span> <span class="mi">4</span> <span class="n">was</span>
         <span class="o">//</span> <span class="n">cleared</span><span class="o">.</span>  <span class="n">It</span> <span class="n">might</span> <span class="n">be</span> <span class="n">that</span> <span class="n">bit</span> <span class="mi">4</span> <span class="n">was</span> <span class="n">cleared</span> <span class="n">automatically</span> <span class="k">as</span> <span class="n">a</span>
         <span class="o">//</span> <span class="n">task</span> <span class="n">that</span> <span class="n">was</span> <span class="n">waiting</span> <span class="k">for</span> <span class="n">bit</span> <span class="mi">4</span> <span class="n">was</span> <span class="n">removed</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">Blocked</span>
         <span class="o">//</span> <span class="n">state</span><span class="o">.</span>
     <span class="p">}</span>
     <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxBits</span> <span class="o">&amp;</span> <span class="n">BIT_4</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">Bit</span> <span class="mi">4</span> <span class="n">remained</span> <span class="nb">set</span> <span class="n">when</span> <span class="n">the</span> <span class="n">function</span> <span class="n">returned</span><span class="p">,</span> <span class="n">but</span> <span class="n">bit</span> <span class="mi">0</span> <span class="n">was</span>
         <span class="o">//</span> <span class="n">cleared</span><span class="o">.</span>  <span class="n">It</span> <span class="n">might</span> <span class="n">be</span> <span class="n">that</span> <span class="n">bit</span> <span class="mi">0</span> <span class="n">was</span> <span class="n">cleared</span> <span class="n">automatically</span> <span class="k">as</span> <span class="n">a</span>
         <span class="o">//</span> <span class="n">task</span> <span class="n">that</span> <span class="n">was</span> <span class="n">waiting</span> <span class="k">for</span> <span class="n">bit</span> <span class="mi">0</span> <span class="n">was</span> <span class="n">removed</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">Blocked</span>
         <span class="o">//</span> <span class="n">state</span><span class="o">.</span>
     <span class="p">}</span>
     <span class="k">else</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">Neither</span> <span class="n">bit</span> <span class="mi">0</span> <span class="n">nor</span> <span class="n">bit</span> <span class="mi">4</span> <span class="n">remained</span> <span class="nb">set</span><span class="o">.</span>  <span class="n">It</span> <span class="n">might</span> <span class="n">be</span> <span class="n">that</span> <span class="n">a</span> <span class="n">task</span>
         <span class="o">//</span> <span class="n">was</span> <span class="n">waiting</span> <span class="k">for</span> <span class="n">both</span> <span class="n">of</span> <span class="n">the</span> <span class="n">bits</span> <span class="n">to</span> <span class="n">be</span> <span class="nb">set</span><span class="p">,</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">bits</span> <span class="n">were</span>
         <span class="o">//</span> <span class="n">cleared</span> <span class="k">as</span> <span class="n">the</span> <span class="n">task</span> <span class="n">left</span> <span class="n">the</span> <span class="n">Blocked</span> <span class="n">state</span><span class="o">.</span>
     <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
{c} <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The value of the event group at the time the call to xEventGroupSetBits() returns. There are two reasons why the returned value might have the bits specified by the uxBitsToSet parameter cleared. First, if setting a bit results in a task that was waiting for the bit leaving the blocked state then it is possible the bit will be cleared automatically (see the xClearBitOnExit parameter of xEventGroupWaitBits()). Second, any unblocked (or otherwise Ready state) task that has a priority above that of the task that called xEventGroupSetBits() will execute and may change the event group value before the call to xEventGroupSetBits() returns.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xEventGroup</span></code>: The event group in which the bits are to be set.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxBitsToSet</span></code>: A bitwise value that indicates the bit or bits to set. For example, to set bit 3 only, set uxBitsToSet to 0x08. To set bit 3 and bit 0 set uxBitsToSet to 0x09.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415xEventGroupSync18EventGroupHandle_tK11EventBits_tK11EventBits_t10TickType_t">
<span id="_CPPv315xEventGroupSync18EventGroupHandle_tK11EventBits_tK11EventBits_t10TickType_t"></span><span id="_CPPv215xEventGroupSync18EventGroupHandle_tK11EventBits_tK11EventBits_t10TickType_t"></span><span id="xEventGroupSync__EventGroupHandle_t.EventBits_tC.EventBits_tC.TickType_t"></span><span class="target" id="event__groups_8h_1a869511456b86426f52e2eec898bff341"></span><a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <code class="descname">xEventGroupSync</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t">EventGroupHandle_t</a> <em>xEventGroup</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <em>uxBitsToSet</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <em>uxBitsToWaitFor</em>, TickType_t <em>xTicksToWait</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415xEventGroupSync18EventGroupHandle_tK11EventBits_tK11EventBits_t10TickType_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Atomically set bits within an event group, then wait for a combination of bits to be set within the same event group. This functionality is typically used to synchronise multiple tasks, where each task has to wait for the other tasks to reach a synchronisation point before proceeding.</p>
<p>This function cannot be used from an interrupt.</p>
<p>The function will return before its block time expires if the bits specified by the uxBitsToWait parameter are set, or become set within that time. In this case all the bits specified by uxBitsToWait will be automatically cleared before the function returns.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Bits</span> <span class="n">used</span> <span class="n">by</span> <span class="n">the</span> <span class="n">three</span> <span class="n">tasks</span><span class="o">.</span>
<span class="c1">#define TASK_0_BIT     ( 1 &lt;&lt; 0 )</span>
<span class="c1">#define TASK_1_BIT     ( 1 &lt;&lt; 1 )</span>
<span class="c1">#define TASK_2_BIT     ( 1 &lt;&lt; 2 )</span>

<span class="c1">#define ALL_SYNC_BITS ( TASK_0_BIT | TASK_1_BIT | TASK_2_BIT )</span>

<span class="o">//</span> <span class="n">Use</span> <span class="n">an</span> <span class="n">event</span> <span class="n">group</span> <span class="n">to</span> <span class="n">synchronise</span> <span class="n">three</span> <span class="n">tasks</span><span class="o">.</span>  <span class="n">It</span> <span class="ow">is</span> <span class="n">assumed</span> <span class="n">this</span> <span class="n">event</span>
<span class="o">//</span> <span class="n">group</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span> <span class="n">elsewhere</span><span class="o">.</span>
<span class="n">EventGroupHandle_t</span> <span class="n">xEventBits</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vTask0</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">EventBits_t</span> <span class="n">uxReturn</span><span class="p">;</span>
<span class="n">TickType_t</span> <span class="n">xTicksToWait</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">portTICK_PERIOD_MS</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">)</span>
    <span class="p">{</span>
       <span class="o">//</span> <span class="n">Perform</span> <span class="n">task</span> <span class="n">functionality</span> <span class="n">here</span><span class="o">.</span>

       <span class="o">//</span> <span class="n">Set</span> <span class="n">bit</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">event</span> <span class="n">flag</span> <span class="n">to</span> <span class="n">note</span> <span class="n">this</span> <span class="n">task</span> <span class="n">has</span> <span class="n">reached</span> <span class="n">the</span>
       <span class="o">//</span> <span class="n">sync</span> <span class="n">point</span><span class="o">.</span>  <span class="n">The</span> <span class="n">other</span> <span class="n">two</span> <span class="n">tasks</span> <span class="n">will</span> <span class="nb">set</span> <span class="n">the</span> <span class="n">other</span> <span class="n">two</span> <span class="n">bits</span> <span class="n">defined</span>
       <span class="o">//</span> <span class="n">by</span> <span class="n">ALL_SYNC_BITS</span><span class="o">.</span>  <span class="n">All</span> <span class="n">three</span> <span class="n">tasks</span> <span class="n">have</span> <span class="n">reached</span> <span class="n">the</span> <span class="n">synchronisation</span>
       <span class="o">//</span> <span class="n">point</span> <span class="n">when</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">ALL_SYNC_BITS</span> <span class="n">are</span> <span class="nb">set</span><span class="o">.</span>  <span class="n">Wait</span> <span class="n">a</span> <span class="n">maximum</span> <span class="n">of</span> <span class="mi">100</span><span class="n">ms</span>
       <span class="o">//</span> <span class="k">for</span> <span class="n">this</span> <span class="n">to</span> <span class="n">happen</span><span class="o">.</span>
       <span class="n">uxReturn</span> <span class="o">=</span> <span class="n">xEventGroupSync</span><span class="p">(</span> <span class="n">xEventBits</span><span class="p">,</span> <span class="n">TASK_0_BIT</span><span class="p">,</span> <span class="n">ALL_SYNC_BITS</span><span class="p">,</span> <span class="n">xTicksToWait</span> <span class="p">);</span>

       <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxReturn</span> <span class="o">&amp;</span> <span class="n">ALL_SYNC_BITS</span> <span class="p">)</span> <span class="o">==</span> <span class="n">ALL_SYNC_BITS</span> <span class="p">)</span>
       <span class="p">{</span>
           <span class="o">//</span> <span class="n">All</span> <span class="n">three</span> <span class="n">tasks</span> <span class="n">reached</span> <span class="n">the</span> <span class="n">synchronisation</span> <span class="n">point</span> <span class="n">before</span> <span class="n">the</span> <span class="n">call</span>
           <span class="o">//</span> <span class="n">to</span> <span class="n">xEventGroupSync</span><span class="p">()</span> <span class="n">timed</span> <span class="n">out</span><span class="o">.</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">vTask1</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">)</span>
    <span class="p">{</span>
       <span class="o">//</span> <span class="n">Perform</span> <span class="n">task</span> <span class="n">functionality</span> <span class="n">here</span><span class="o">.</span>

       <span class="o">//</span> <span class="n">Set</span> <span class="n">bit</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">event</span> <span class="n">flag</span> <span class="n">to</span> <span class="n">note</span> <span class="n">this</span> <span class="n">task</span> <span class="n">has</span> <span class="n">reached</span> <span class="n">the</span>
       <span class="o">//</span> <span class="n">synchronisation</span> <span class="n">point</span><span class="o">.</span>  <span class="n">The</span> <span class="n">other</span> <span class="n">two</span> <span class="n">tasks</span> <span class="n">will</span> <span class="nb">set</span> <span class="n">the</span> <span class="n">other</span> <span class="n">two</span>
       <span class="o">//</span> <span class="n">bits</span> <span class="n">defined</span> <span class="n">by</span> <span class="n">ALL_SYNC_BITS</span><span class="o">.</span>  <span class="n">All</span> <span class="n">three</span> <span class="n">tasks</span> <span class="n">have</span> <span class="n">reached</span> <span class="n">the</span>
       <span class="o">//</span> <span class="n">synchronisation</span> <span class="n">point</span> <span class="n">when</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">ALL_SYNC_BITS</span> <span class="n">are</span> <span class="nb">set</span><span class="o">.</span>  <span class="n">Wait</span>
       <span class="o">//</span> <span class="n">indefinitely</span> <span class="k">for</span> <span class="n">this</span> <span class="n">to</span> <span class="n">happen</span><span class="o">.</span>
       <span class="n">xEventGroupSync</span><span class="p">(</span> <span class="n">xEventBits</span><span class="p">,</span> <span class="n">TASK_1_BIT</span><span class="p">,</span> <span class="n">ALL_SYNC_BITS</span><span class="p">,</span> <span class="n">portMAX_DELAY</span> <span class="p">);</span>

       <span class="o">//</span> <span class="n">xEventGroupSync</span><span class="p">()</span> <span class="n">was</span> <span class="n">called</span> <span class="k">with</span> <span class="n">an</span> <span class="n">indefinite</span> <span class="n">block</span> <span class="n">time</span><span class="p">,</span> <span class="n">so</span>
       <span class="o">//</span> <span class="n">this</span> <span class="n">task</span> <span class="n">will</span> <span class="n">only</span> <span class="n">reach</span> <span class="n">here</span> <span class="k">if</span> <span class="n">the</span> <span class="n">syncrhonisation</span> <span class="n">was</span> <span class="n">made</span> <span class="n">by</span> <span class="nb">all</span>
       <span class="o">//</span> <span class="n">three</span> <span class="n">tasks</span><span class="p">,</span> <span class="n">so</span> <span class="n">there</span> <span class="ow">is</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">test</span> <span class="n">the</span> <span class="k">return</span> <span class="n">value</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">vTask2</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">)</span>
    <span class="p">{</span>
       <span class="o">//</span> <span class="n">Perform</span> <span class="n">task</span> <span class="n">functionality</span> <span class="n">here</span><span class="o">.</span>

       <span class="o">//</span> <span class="n">Set</span> <span class="n">bit</span> <span class="mi">2</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">event</span> <span class="n">flag</span> <span class="n">to</span> <span class="n">note</span> <span class="n">this</span> <span class="n">task</span> <span class="n">has</span> <span class="n">reached</span> <span class="n">the</span>
       <span class="o">//</span> <span class="n">synchronisation</span> <span class="n">point</span><span class="o">.</span>  <span class="n">The</span> <span class="n">other</span> <span class="n">two</span> <span class="n">tasks</span> <span class="n">will</span> <span class="nb">set</span> <span class="n">the</span> <span class="n">other</span> <span class="n">two</span>
       <span class="o">//</span> <span class="n">bits</span> <span class="n">defined</span> <span class="n">by</span> <span class="n">ALL_SYNC_BITS</span><span class="o">.</span>  <span class="n">All</span> <span class="n">three</span> <span class="n">tasks</span> <span class="n">have</span> <span class="n">reached</span> <span class="n">the</span>
       <span class="o">//</span> <span class="n">synchronisation</span> <span class="n">point</span> <span class="n">when</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">ALL_SYNC_BITS</span> <span class="n">are</span> <span class="nb">set</span><span class="o">.</span>  <span class="n">Wait</span>
       <span class="o">//</span> <span class="n">indefinitely</span> <span class="k">for</span> <span class="n">this</span> <span class="n">to</span> <span class="n">happen</span><span class="o">.</span>
       <span class="n">xEventGroupSync</span><span class="p">(</span> <span class="n">xEventBits</span><span class="p">,</span> <span class="n">TASK_2_BIT</span><span class="p">,</span> <span class="n">ALL_SYNC_BITS</span><span class="p">,</span> <span class="n">portMAX_DELAY</span> <span class="p">);</span>

       <span class="o">//</span> <span class="n">xEventGroupSync</span><span class="p">()</span> <span class="n">was</span> <span class="n">called</span> <span class="k">with</span> <span class="n">an</span> <span class="n">indefinite</span> <span class="n">block</span> <span class="n">time</span><span class="p">,</span> <span class="n">so</span>
       <span class="o">//</span> <span class="n">this</span> <span class="n">task</span> <span class="n">will</span> <span class="n">only</span> <span class="n">reach</span> <span class="n">here</span> <span class="k">if</span> <span class="n">the</span> <span class="n">syncrhonisation</span> <span class="n">was</span> <span class="n">made</span> <span class="n">by</span> <span class="nb">all</span>
       <span class="o">//</span> <span class="n">three</span> <span class="n">tasks</span><span class="p">,</span> <span class="n">so</span> <span class="n">there</span> <span class="ow">is</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">test</span> <span class="n">the</span> <span class="k">return</span> <span class="n">value</span><span class="o">.</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The value of the event group at the time either the bits being waited for became set, or the block time expired. Test the return value to know which bits were set. If xEventGroupSync() returned because its timeout expired then not all the bits being waited for will be set. If xEventGroupSync() returned because all the bits it was waiting for were set then the returned value is the event group value before any bits were automatically cleared.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xEventGroup</span></code>: The event group in which the bits are being tested. The event group must have previously been created using a call to xEventGroupCreate().</li>
<li><code class="docutils literal notranslate"><span class="pre">uxBitsToSet</span></code>: The bits to set in the event group before determining if, and possibly waiting for, all the bits specified by the uxBitsToWait parameter are set.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxBitsToWaitFor</span></code>: A bitwise value that indicates the bit or bits to test inside the event group. For example, to wait for bit 0 and bit 2 set uxBitsToWaitFor to 0x05. To wait for bits 0 and bit 1 and bit 2 set uxBitsToWaitFor to 0x07. Etc.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: The maximum amount of time (specified in ‘ticks’) to wait for all of the bits specified by uxBitsToWaitFor to become set.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425xEventGroupGetBitsFromISR18EventGroupHandle_t">
<span id="_CPPv325xEventGroupGetBitsFromISR18EventGroupHandle_t"></span><span id="_CPPv225xEventGroupGetBitsFromISR18EventGroupHandle_t"></span><span id="xEventGroupGetBitsFromISR__EventGroupHandle_t"></span><span class="target" id="event__groups_8h_1adcb3d3f7dded9fa372bb1ee405c36b8d"></span><a class="reference internal" href="#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <code class="descname">xEventGroupGetBitsFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t">EventGroupHandle_t</a> <em>xEventGroup</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425xEventGroupGetBitsFromISR18EventGroupHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A version of xEventGroupGetBits() that can be called from an ISR.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The event group bits at the time xEventGroupGetBitsFromISR() was called. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xEventGroup</span></code>: The event group being queried.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417vEventGroupDelete18EventGroupHandle_t">
<span id="_CPPv317vEventGroupDelete18EventGroupHandle_t"></span><span id="_CPPv217vEventGroupDelete18EventGroupHandle_t"></span><span id="vEventGroupDelete__EventGroupHandle_t"></span><span class="target" id="event__groups_8h_1a6939faca89fc4ba52fa8288527042464"></span>void <code class="descname">vEventGroupDelete</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t">EventGroupHandle_t</a> <em>xEventGroup</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417vEventGroupDelete18EventGroupHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Delete an event group that was previously created by a call to xEventGroupCreate(). Tasks that are blocked on the event group will be unblocked and obtain 0 as the event group’s value.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xEventGroup</span></code>: The event group being deleted. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="id14">
<h3>Macros<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.xEventGroupClearBitsFromISR">
<span class="target" id="event__groups_8h_1a3d7de214a697f33fe7b914e26a93f33a"></span><code class="descname">xEventGroupClearBitsFromISR</code><span class="sig-paren">(</span>xEventGroup, uxBitsToClear<span class="sig-paren">)</span><a class="headerlink" href="#c.xEventGroupClearBitsFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>A version of xEventGroupClearBits() that can be called from an interrupt.</p>
<p>Setting bits in an event group is not a deterministic operation because there are an unknown number of tasks that may be waiting for the bit or bits being set. FreeRTOS does not allow nondeterministic operations to be performed while interrupts are disabled, so protects event groups that are accessed from tasks by suspending the scheduler rather than disabling interrupts. As a result event groups cannot be accessed directly from an interrupt service routine. Therefore xEventGroupClearBitsFromISR() sends a message to the timer task to have the clear operation performed in the context of the timer task.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="c1">#define BIT_0    ( 1 &lt;&lt; 0 )</span>
 <span class="c1">#define BIT_4    ( 1 &lt;&lt; 4 )</span>

 <span class="o">//</span> <span class="n">An</span> <span class="n">event</span> <span class="n">group</span> <span class="n">which</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">assumed</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span> <span class="n">by</span> <span class="n">a</span> <span class="n">call</span> <span class="n">to</span>
 <span class="o">//</span> <span class="n">xEventGroupCreate</span><span class="p">()</span><span class="o">.</span>
 <span class="n">EventGroupHandle_t</span> <span class="n">xEventGroup</span><span class="p">;</span>

 <span class="n">void</span> <span class="n">anInterruptHandler</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
 <span class="p">{</span>
      <span class="o">//</span> <span class="n">Clear</span> <span class="n">bit</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">bit</span> <span class="mi">4</span> <span class="ow">in</span> <span class="n">xEventGroup</span><span class="o">.</span>
      <span class="n">xResult</span> <span class="o">=</span> <span class="n">xEventGroupClearBitsFromISR</span><span class="p">(</span>
                          <span class="n">xEventGroup</span><span class="p">,</span>     <span class="o">//</span> <span class="n">The</span> <span class="n">event</span> <span class="n">group</span> <span class="n">being</span> <span class="n">updated</span><span class="o">.</span>
                          <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span> <span class="p">);</span> <span class="o">//</span> <span class="n">The</span> <span class="n">bits</span> <span class="n">being</span> <span class="nb">set</span><span class="o">.</span>

      <span class="k">if</span><span class="p">(</span> <span class="n">xResult</span> <span class="o">==</span> <span class="n">pdPASS</span> <span class="p">)</span>
      <span class="p">{</span>
          <span class="o">//</span> <span class="n">The</span> <span class="n">message</span> <span class="n">was</span> <span class="n">posted</span> <span class="n">successfully</span><span class="o">.</span>
      <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If the request to execute the function was posted successfully then pdPASS is returned, otherwise pdFALSE is returned. pdFALSE will be returned if the timer service queue was full.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xEventGroup</span></code>: The event group in which the bits are to be cleared.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxBitsToClear</span></code>: A bitwise value that indicates the bit or bits to clear. For example, to clear bit 3 only, set uxBitsToClear to 0x08. To clear bit 3 and bit 0 set uxBitsToClear to 0x09.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xEventGroupSetBitsFromISR">
<span class="target" id="event__groups_8h_1a62b68278abac6358369ae8e390988a02"></span><code class="descname">xEventGroupSetBitsFromISR</code><span class="sig-paren">(</span>xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="#c.xEventGroupSetBitsFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>A version of xEventGroupSetBits() that can be called from an interrupt.</p>
<p>Setting bits in an event group is not a deterministic operation because there are an unknown number of tasks that may be waiting for the bit or bits being set. FreeRTOS does not allow nondeterministic operations to be performed in interrupts or from critical sections. Therefore xEventGroupSetBitFromISR() sends a message to the timer task to have the set operation performed in the context of the timer task - where a scheduler lock is used in place of a critical section.</p>
<p><p>Example usage: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> #define BIT_0    ( 1 &lt;&lt; 0 )
 #define BIT_4    ( 1 &lt;&lt; 4 )

 // An event group which it is assumed has already been created by a call to
 // xEventGroupCreate().
 EventGroupHandle_t xEventGroup;

 void anInterruptHandler( void )
 {
 BaseType_t xHigherPriorityTaskWoken, xResult;

      // xHigherPriorityTaskWoken must be initialised to pdFALSE.
      xHigherPriorityTaskWoken = pdFALSE;

      // Set bit 0 and bit 4 in xEventGroup.
      xResult = xEventGroupSetBitsFromISR(
                          xEventGroup,    // The event group being updated.
                          BIT_0 | BIT_4   // The bits being set.
                          &amp;xHigherPriorityTaskWoken );

      // Was the message posted successfully?
      if( xResult == pdPASS )
      {
          // If xHigherPriorityTaskWoken is now set to pdTRUE then a context
          // switch should be requested.  The macro used is port specific and
          // will be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() -
          // refer to the documentation page for the port being used.
          portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
      }
}
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If the request to execute the function was posted successfully then pdPASS is returned, otherwise pdFALSE is returned. pdFALSE will be returned if the timer service queue was full.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xEventGroup</span></code>: The event group in which the bits are to be set.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxBitsToSet</span></code>: A bitwise value that indicates the bit or bits to set. For example, to set bit 3 only, set uxBitsToSet to 0x08. To set bit 3 and bit 0 set uxBitsToSet to 0x09.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>: As mentioned above, calling this function will result in a message being sent to the timer daemon task. If the priority of the timer daemon task is higher than the priority of the currently running task (the task the interrupt interrupted) then *pxHigherPriorityTaskWoken will be set to pdTRUE by xEventGroupSetBitsFromISR(), indicating that a context switch should be requested before the interrupt exits. For that reason *pxHigherPriorityTaskWoken must be initialised to pdFALSE. See the example code below.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.xEventGroupGetBits">
<span class="target" id="event__groups_8h_1a0ae86f092fb07ccb475ae938f9a12584"></span><code class="descname">xEventGroupGetBits</code><span class="sig-paren">(</span>xEventGroup<span class="sig-paren">)</span><a class="headerlink" href="#c.xEventGroupGetBits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current value of the bits in an event group. This function cannot be used from an interrupt.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The event group bits at the time xEventGroupGetBits() was called. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xEventGroup</span></code>: The event group being queried.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="id15">
<h3>Type Definitions<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv418EventGroupHandle_t">
<span id="_CPPv318EventGroupHandle_t"></span><span id="_CPPv218EventGroupHandle_t"></span><span id="EventGroupHandle_t"></span><span class="target" id="event__groups_8h_1a5119294106541c4eca46e8742fdb4e85"></span><em class="property">typedef </em>void *<code class="descname">EventGroupHandle_t</code><a class="headerlink" href="#_CPPv418EventGroupHandle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><p>An event group is a collection of bits to which an application can assign a meaning. For example, an application may create an event group to convey the status of various CAN bus related events in which bit 0 might mean “A CAN</p>
<p>message has been received and is ready for processing”, bit 1 might mean “The application has queued a message that is ready for sending onto the CAN network”, and bit 2 might mean “It is time to send a SYNC message onto the CAN network” etc. A task can then test the bit values to see which events are active, and optionally enter the Blocked state to wait for a specified bit or a group of specified bits to be active. To continue the CAN bus example, a CAN controlling task can enter the Blocked state (and therefore not consume any processing time) until either bit 0, bit 1 or bit 2 are active, at which time the bit that was actually active would inform the task which action it had to take (process a received message, send a message, or send a SYNC).</p>
</p>
<p>The event groups implementation contains intelligence to avoid race conditions that would otherwise occur were an application to use a simple variable for the same purpose. This is particularly important with respect to when a bit within an event group is to be cleared, and when bits have to be set and then tested atomically - as is the case where event groups are used to create a synchronisation point between multiple tasks (a ‘rendezvous’). event_groups.h</p>
<p>Type by which event groups are referenced. For example, a call to xEventGroupCreate() returns an EventGroupHandle_t variable that can then be used as a parameter to other event group functions. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv411EventBits_t">
<span id="_CPPv311EventBits_t"></span><span id="_CPPv211EventBits_t"></span><span id="EventBits_t"></span><span class="target" id="event__groups_8h_1ab2f21b93db0b2a0ab64d7a81ff32ac2e"></span><em class="property">typedef </em>TickType_t <code class="descname">EventBits_t</code><a class="headerlink" href="#_CPPv411EventBits_t" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="freertos_additions.html" class="btn btn-neutral float-right" title="FreeRTOS Additions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="esp_event_legacy.html" class="btn btn-neutral float-left" title="Legacy event loop" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016 - 2019, Espressif Systems (Shanghai) CO., LTD
      
        <span class="commit">
          Revision <code>f9108063</code>.
        </span>
      

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org/">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: latest
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="https://docs.espressif.com/en/latest/">latest</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/stable/">stable</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v4.0-rc/">v4.0-rc</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v4.0-beta2/">v4.0-beta2</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.3.1/">v3.3.1</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.3/">v3.3</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.2.3/">v3.2.3</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.2.2/">v3.2.2</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.1.6/">v3.1.6</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.1.5/">v3.1.5</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.0.9/">v3.0.9</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/release-v4.1/">release-v4.1</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/release-v4.0/">release-v4.0</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/release-v3.3/">release-v3.3</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/release-v3.2/">release-v3.2</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/release-v3.1/">release-v3.1</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/release-v3.0/">release-v3.0</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="http://docs.espressif.com/_/downloads/esp-idf/en/latest/pdf/">pdf</a></dd>
        
      </dl>
      <dl>
        <dt>On Read the Docs</dt>
          <dd>
            <a href="http://readthedocs.com/projects/espressif-esp-idf/?fromdocs=espressif-esp-idf">Project Home</a>
          </dd>
          <dd>
            <a href="http://readthedocs.com/builds/espressif-esp-idf/?fromdocs=espressif-esp-idf">Builds</a>
          </dd>
      </dl>
      <hr/>
      Free document hosting provided by <a href="http://www.readthedocs.org/">Read the Docs</a>.

    </div>
  </div>



  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
   

</body>

<!-- Mirrored from docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/freertos.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 29 Feb 2020 06:26:11 GMT -->
</html>