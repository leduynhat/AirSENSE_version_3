

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->

<!-- Mirrored from docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/mem_alloc.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 29 Feb 2020 06:26:27 GMT -->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Heap Memory Allocation &mdash; ESP-IDF Programming Guide v4.1-dev-2071-gf91080637 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../../../../../media.readthedocs.com/javascript/readthedocs-doc-embed.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Heap Memory Debugging" href="heap_debug.html" />
    <link rel="prev" title="FreeRTOS Additions" href="freertos_additions.html" /> 

<!-- RTD Extra Head -->

<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link rel="canonical" href="mem_alloc.html" />

<link rel="stylesheet" href="../../../../../../../media.readthedocs.com/css/readthedocs-doc-embed.css" type="text/css" />

<script type="text/javascript" src="../../_static/readthedocs-data.js"></script>

<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = "api-reference/system/mem_alloc"
READTHEDOCS_DATA['source_suffix'] = ".rst"
</script>

<script type="text/javascript" src="../../../../../../../media.readthedocs.com/javascript/readthedocs-analytics.js"></script>

<!-- end RTD <extrahead> -->
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index-2.html" class="icon icon-home"> ESP-IDF Programming Guide
          

          
            
            <img src="../../_static/espressif-logo.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="https://docs.espressif.com/projects/esp-idf/en/latest/search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">Get Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../peripherals/index.html">Peripherals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">Provisioning</a></li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">Storage</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">System</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="app_image_format.html">App image format</a></li>
<li class="toctree-l3"><a class="reference internal" href="app_trace.html">Application Level Tracing</a></li>
<li class="toctree-l3"><a class="reference internal" href="efuse.html">eFuse Manager</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_err.html">Error Codes and Helper Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_https_ota.html">ESP HTTPS OTA</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_pthread.html">ESP pthread</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_event.html">Event Loop Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="freertos.html">FreeRTOS</a></li>
<li class="toctree-l3"><a class="reference internal" href="freertos_additions.html">FreeRTOS Additions</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Heap Memory Allocation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#stack-and-heap">Stack and Heap</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-capabilities">Memory Capabilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="#available-heap">Available Heap</a></li>
<li class="toctree-l4"><a class="reference internal" href="#special-capabilities">Special Capabilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference-heap-allocation">API Reference - Heap Allocation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#heap-tracing-debugging">Heap Tracing &amp; Debugging</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference-initialisation">API Reference - Initialisation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation-notes">Implementation Notes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference-multi-heap-api">API Reference - Multi Heap API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="heap_debug.html">Heap Memory Debugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_timer.html">High Resolution Timer</a></li>
<li class="toctree-l3"><a class="reference internal" href="himem.html">Himem (large external SPI RAM) API</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipc.html">Inter-Processor Call</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_expression_with_stack.html">Call function with external stack</a></li>
<li class="toctree-l3"><a class="reference internal" href="intr_alloc.html">Interrupt Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="log.html">Logging</a></li>
<li class="toctree-l3"><a class="reference internal" href="system.html">Miscellaneous System APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="ota.html">Over The Air Updates (OTA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="perfmon.html">Performance Monitor</a></li>
<li class="toctree-l3"><a class="reference internal" href="power_management.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="sleep_modes.html">Sleep Modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="wdts.html">Watchdogs</a></li>
<li class="toctree-l3"><a class="reference internal" href="system_time.html">System Time</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">Configuration Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">Error Codes Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">H/W Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../esp32s2.html">ESP32-S2 Preview Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">Libraries and Frameworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">Versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">Copyrights</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">语言/Languages</a></li>
<li class="toctree-l1"><a class="reference external" href="https://readthedocs.com/projects/espressif-esp-idf/downloads/">Guide Downloads</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index-2.html">ESP-IDF Programming Guide</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index-2.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">API Reference</a> &raquo;</li>
        
          <li><a href="index.html">System API</a> &raquo;</li>
        
      <li>Heap Memory Allocation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/espressif/esp-idf/blob/master/docs/en/api-reference/system/mem_alloc.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="heap-memory-allocation">
<h1>Heap Memory Allocation<a class="headerlink" href="#heap-memory-allocation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="stack-and-heap">
<h2>Stack and Heap<a class="headerlink" href="#stack-and-heap" title="Permalink to this headline">¶</a></h2>
<p>ESP-IDF applications use the common computer architecture patterns of <em>stack</em> (dynamic memory allocated by program control flow) and <em>heap</em> (dynamic memory allocated by function calls), as well as statically allocated memory (allocated at compile time).</p>
<p>Because ESP-IDF is a multi-threaded RTOS environment, each RTOS task has its own stack. By default, each of these stacks is allocated from the heap when the task is created. (See <a class="reference internal" href="freertos.html#_CPPv417xTaskCreateStatic14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_t" title="xTaskCreateStatic"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xTaskCreateStatic()</span></code></a> for the alternative where stacks are statically allocated.)</p>
<p>Because ESP32 uses multiple types of RAM, it also contains multiple heaps with different capabilities. A capabilities-based memory allocator allows apps to make heap allocations for different purposes.</p>
<p>For most purposes, the standard libc <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> and <code class="docutils literal notranslate"><span class="pre">free()</span></code> functions can be used for heap allocation without any special consideration.</p>
<p>However, in order to fully make use of all of the memory types and their characteristics, ESP-IDF also has a
capabilities-based heap memory allocator. If you want to have memory with certain properties (for example, <a class="reference internal" href="#dma-capable-memory"><span class="std std-ref">DMA-Capable Memory</span></a> or executable-memory), you can create an OR-mask of the required capabilities and pass that to <a class="reference internal" href="#_CPPv416heap_caps_malloc6size_t8uint32_t" title="heap_caps_malloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_malloc()</span></code></a>.</p>
</div>
<div class="section" id="memory-capabilities">
<h2>Memory Capabilities<a class="headerlink" href="#memory-capabilities" title="Permalink to this headline">¶</a></h2>
<p>The ESP32 contains multiple types of RAM:</p>
<ul class="simple">
<li>DRAM (Data RAM) is memory used to hold data. This is the most common kind of memory accessed as heap.</li>
<li>IRAM (Instruction RAM) usually holds executable data only. If accessed as generic memory, all accesses must be <a class="reference internal" href="#bit-accessible-memory"><span class="std std-ref">32-bit aligned</span></a>.</li>
<li>D/IRAM is RAM which can be used as either Instruction or Data RAM.</li>
</ul>
<p>For more details on these internal memory types, see <a class="reference internal" href="../../api-guides/general-notes.html#memory-layout"><span class="std std-ref">Application memory layout</span></a>.</p>
<p>It’s also possible to connect external SPI RAM to the ESP32 - <a class="reference internal" href="../../api-guides/external-ram.html"><span class="doc">external RAM</span></a> can be integrated into the ESP32’s memory map using the flash cache, and accessed similarly to DRAM.</p>
<p>DRAM uses capability <code class="docutils literal notranslate"><span class="pre">MALLOC_CAP_8BIT</span></code> (accessible in single byte reads and writes). When calling <code class="docutils literal notranslate"><span class="pre">malloc()</span></code>, the ESP-IDF <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> implementation internally calls <code class="docutils literal notranslate"><span class="pre">heap_caps_malloc(size,</span> <span class="pre">MALLOC_CAP_8BIT)</span></code> in order to allocate DRAM that is byte-addressable. To test the free DRAM heap size at runtime, call cpp:func:<cite>heap_caps_get_free_size(MALLOC_CAP_8BIT)</cite>.</p>
<p>Because malloc uses the capabilities-based allocation system, memory allocated using <a class="reference internal" href="#_CPPv416heap_caps_malloc6size_t8uint32_t" title="heap_caps_malloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_malloc()</span></code></a> can be freed by calling
the standard <code class="docutils literal notranslate"><span class="pre">free()</span></code> function.</p>
</div>
<div class="section" id="available-heap">
<h2>Available Heap<a class="headerlink" href="#available-heap" title="Permalink to this headline">¶</a></h2>
<div class="section" id="dram">
<h3>DRAM<a class="headerlink" href="#dram" title="Permalink to this headline">¶</a></h3>
<p>At startup, the DRAM heap contains all data memory which is not statically allocated by the app. Reducing statically allocated buffers will increase the amount of available free heap.</p>
<p>To find the amount of statically allocated memory, use the <a class="reference internal" href="../../api-guides/build-system.html#idf-py-size"><span class="std std-ref">idf.py size</span></a> command.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Due to a technical limitation, the maximum statically allocated DRAM usage is 160KB. The remaining 160KB (for a total of 320KB of DRAM) can only be allocated at runtime as heap.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">At runtime, the available heap DRAM may be less than calculated at compile time, because at startup some memory is allocated from the heap before the FreeRTOS scheduler is started (including memory for the stacks of initial FreeRTOS tasks).</p>
</div>
</div>
<div class="section" id="iram">
<h3>IRAM<a class="headerlink" href="#iram" title="Permalink to this headline">¶</a></h3>
<p>At startup, the IRAM heap contains all instruction memory which is not used by the app executable code.</p>
<p>The <a class="reference internal" href="../../api-guides/build-system.html#idf-py-size"><span class="std std-ref">idf.py size</span></a> command can be used to find the amount of IRAM used by the app.</p>
</div>
<div class="section" id="d-iram">
<h3>D/IRAM<a class="headerlink" href="#d-iram" title="Permalink to this headline">¶</a></h3>
<p>Some memory in the ESP32 is available as either DRAM or IRAM. If memory is allocated from a D/IRAM region, the free heap size for both types of memory will decrease.</p>
</div>
<div class="section" id="heap-sizes">
<h3>Heap Sizes<a class="headerlink" href="#heap-sizes" title="Permalink to this headline">¶</a></h3>
<p>At startup, all ESP-IDF apps log a summary of all heap addresses (and sizes) at level Info:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>I (252) heap_init: Initializing. RAM available for dynamic allocation:
I (259) heap_init: At 3FFAE6E0 len 00001920 (6 KiB): DRAM
I (265) heap_init: At 3FFB2EC8 len 0002D138 (180 KiB): DRAM
I (272) heap_init: At 3FFE0440 len 00003AE0 (14 KiB): D/IRAM
I (278) heap_init: At 3FFE4350 len 0001BCB0 (111 KiB): D/IRAM
I (284) heap_init: At 4008944C len 00016BB4 (90 KiB): IRAM
</pre></div>
</div>
</div>
<div class="section" id="finding-available-heap">
<h3>Finding available heap<a class="headerlink" href="#finding-available-heap" title="Permalink to this headline">¶</a></h3>
<p>See <a class="reference internal" href="heap_debug.html#heap-information"><span class="std std-ref">Heap Information</span></a>.</p>
</div>
</div>
<div class="section" id="special-capabilities">
<h2>Special Capabilities<a class="headerlink" href="#special-capabilities" title="Permalink to this headline">¶</a></h2>
<div class="section" id="dma-capable-memory">
<span id="id1"></span><h3>DMA-Capable Memory<a class="headerlink" href="#dma-capable-memory" title="Permalink to this headline">¶</a></h3>
<p>Use the <code class="docutils literal notranslate"><span class="pre">MALLOC_CAP_DMA</span></code> flag to allocate memory which is suitable for use with hardware DMA engines (for example SPI and I2S). This capability flag excludes any external PSRAM.</p>
</div>
<div class="section" id="bit-accessible-memory">
<span id="id2"></span><h3>32-Bit Accessible Memory<a class="headerlink" href="#bit-accessible-memory" title="Permalink to this headline">¶</a></h3>
<p>If a certain memory structure is only addressed in 32-bit units, for example an array of ints or pointers, it can be
useful to allocate it with the <code class="docutils literal notranslate"><span class="pre">MALLOC_CAP_32BIT</span></code> flag. This also allows the allocator to give out IRAM memory; something
which it can’t do for a normal malloc() call. This can help to use all the available memory in the ESP32.</p>
<p>Memory allocated with <code class="docutils literal notranslate"><span class="pre">MALLOC_CAP_32BIT</span></code> can <em>only</em> be accessed via 32-bit reads and writes, any other type of access will
generate a fatal LoadStoreError exception.</p>
</div>
<div class="section" id="external-spi-memory">
<h3>External SPI Memory<a class="headerlink" href="#external-spi-memory" title="Permalink to this headline">¶</a></h3>
<p>When <a class="reference internal" href="../../api-guides/external-ram.html"><span class="doc">external RAM</span></a> is enabled, external SPI RAM under 4MiB in size can be allocated using standard <code class="docutils literal notranslate"><span class="pre">malloc</span></code> calls, or via <code class="docutils literal notranslate"><span class="pre">heap_caps_malloc(MALLOC_CAP_SPIRAM)</span></code>, depending on configuration. See <a class="reference internal" href="../../api-guides/external-ram.html#external-ram-config"><span class="std std-ref">Configuring External RAM</span></a> for more details.</p>
<p>To use the region above the 4MiB limit, you can use the <a class="reference internal" href="himem.html"><span class="doc">himem API</span></a>.</p>
</div>
</div>
<div class="section" id="api-reference-heap-allocation">
<h2>API Reference - Heap Allocation<a class="headerlink" href="#api-reference-heap-allocation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="header-file">
<h3>Header File<a class="headerlink" href="#header-file" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/heap/include/esp_heap_caps.h">heap/include/esp_heap_caps.h</a></li>
</ul>
</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv416heap_caps_malloc6size_t8uint32_t">
<span id="_CPPv316heap_caps_malloc6size_t8uint32_t"></span><span id="_CPPv216heap_caps_malloc6size_t8uint32_t"></span><span id="heap_caps_malloc__s.uint32_t"></span><span class="target" id="esp__heap__caps_8h_1ab423ad98296288ff760c238e599b2669"></span>void *<code class="descname">heap_caps_malloc</code><span class="sig-paren">(</span>size_t <em>size</em>, uint32_t <em>caps</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416heap_caps_malloc6size_t8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a chunk of memory which has the given capabilities. </p>
<p>Equivalent semantics to libc malloc(), for capability-aware memory.</p>
<p>In IDF, <code class="docutils literal notranslate"><span class="pre">malloc(p)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">heap_caps_malloc(p,</span> <span class="pre">MALLOC_CAP_8BIT)</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A pointer to the memory allocated on success, NULL on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Size, in bytes, of the amount of memory to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>: Bitwise OR of MALLOC_CAP_* flags indicating the type of memory to be returned</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414heap_caps_freePv">
<span id="_CPPv314heap_caps_freePv"></span><span id="_CPPv214heap_caps_freePv"></span><span id="heap_caps_free__voidP"></span><span class="target" id="esp__heap__caps_8h_1aefb117b700d0577eaf80b02fedb41e39"></span>void <code class="descname">heap_caps_free</code><span class="sig-paren">(</span>void *<em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414heap_caps_freePv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free memory previously allocated via heap_caps_malloc() or heap_caps_realloc(). </p>
<p>Equivalent semantics to libc free(), for capability-aware memory.</p>
<p>In IDF, <code class="docutils literal notranslate"><span class="pre">free(p)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">heap_caps_free(p)</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ptr</span></code>: Pointer to memory previously returned from heap_caps_malloc() or heap_caps_realloc(). Can be NULL. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417heap_caps_reallocPv6size_ti">
<span id="_CPPv317heap_caps_reallocPv6size_ti"></span><span id="_CPPv217heap_caps_reallocPv6size_ti"></span><span id="heap_caps_realloc__voidP.s.i"></span><span class="target" id="esp__heap__caps_8h_1ae9d230cd97014ae5e0e218bd477c94c2"></span>void *<code class="descname">heap_caps_realloc</code><span class="sig-paren">(</span>void *<em>ptr</em>, size_t <em>size</em>, int <em>caps</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417heap_caps_reallocPv6size_ti" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reallocate memory previously allocated via heap_caps_malloc() or heap_caps_realloc(). </p>
<p>Equivalent semantics to libc realloc(), for capability-aware memory.</p>
<p>In IDF, <code class="docutils literal notranslate"><span class="pre">realloc(p,</span> <span class="pre">s)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">heap_caps_realloc(p,</span> <span class="pre">s,</span> <span class="pre">MALLOC_CAP_8BIT)</span></code>.</p>
<p>‘caps’ parameter can be different to the capabilities that any original ‘ptr’ was allocated with. In this way, realloc can be used to “move” a buffer if necessary to ensure it meets a new set of capabilities.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Pointer to a new buffer of size ‘size’ with capabilities ‘caps’, or NULL if allocation failed. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ptr</span></code>: Pointer to previously allocated memory, or NULL for a new allocation. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Size of the new buffer requested, or 0 to free the buffer. </li>
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>: Bitwise OR of MALLOC_CAP_* flags indicating the type of memory desired for the new allocation.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423heap_caps_aligned_alloc6size_t6size_ti">
<span id="_CPPv323heap_caps_aligned_alloc6size_t6size_ti"></span><span id="_CPPv223heap_caps_aligned_alloc6size_t6size_ti"></span><span id="heap_caps_aligned_alloc__s.s.i"></span><span class="target" id="esp__heap__caps_8h_1abdec7b01277123f950aafc739565ec37"></span>void *<code class="descname">heap_caps_aligned_alloc</code><span class="sig-paren">(</span>size_t <em>alignment</em>, size_t <em>size</em>, int <em>caps</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423heap_caps_aligned_alloc6size_t6size_ti" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a aligned chunk of memory which has the given capabilities. </p>
<p>Equivalent semantics to libc aligned_alloc(), for capability-aware memory. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A pointer to the memory allocated on success, NULL on failure</dd>
<dt><strong>Note</strong></dt>
<dd>Any memory allocated with heaps_caps_aligned_alloc() MUST be freed with heap_caps_aligned_free() and CANNOT be passed to free() </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">alignment</span></code>: How the pointer received needs to be aligned must be a power of two </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Size, in bytes, of the amount of memory to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>: Bitwise OR of MALLOC_CAP_* flags indicating the type of memory to be returned</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424heap_caps_aligned_calloc6size_t6size_t6size_t8uint32_t">
<span id="_CPPv324heap_caps_aligned_calloc6size_t6size_t6size_t8uint32_t"></span><span id="_CPPv224heap_caps_aligned_calloc6size_t6size_t6size_t8uint32_t"></span><span id="heap_caps_aligned_calloc__s.s.s.uint32_t"></span><span class="target" id="esp__heap__caps_8h_1ae4fd0561451035c858cd2cc3f93d61b6"></span>void *<code class="descname">heap_caps_aligned_calloc</code><span class="sig-paren">(</span>size_t <em>alignment</em>, size_t <em>n</em>, size_t <em>size</em>, uint32_t <em>caps</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424heap_caps_aligned_calloc6size_t6size_t6size_t8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a aligned chunk of memory which has the given capabilities. The initialized value in the memory is set to zero. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A pointer to the memory allocated on success, NULL on failure</dd>
<dt><strong>Note</strong></dt>
<dd>Any memory allocated with heap_caps_aligned_calloc() MUST be freed with heap_caps_aligned_free() and CANNOT be passed to free() </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">alignment</span></code>: How the pointer received needs to be aligned must be a power of two </li>
<li><code class="docutils literal notranslate"><span class="pre">n</span></code>: Number of continuing chunks of memory to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Size, in bytes, of a chunk of memory to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>: Bitwise OR of MALLOC_CAP_* flags indicating the type of memory to be returned</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv422heap_caps_aligned_freePv">
<span id="_CPPv322heap_caps_aligned_freePv"></span><span id="_CPPv222heap_caps_aligned_freePv"></span><span id="heap_caps_aligned_free__voidP"></span><span class="target" id="esp__heap__caps_8h_1a2aa70af40dda32723d5c98890c1187d3"></span>void <code class="descname">heap_caps_aligned_free</code><span class="sig-paren">(</span>void *<em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422heap_caps_aligned_freePv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Used to deallocate memory previously allocated with heap_caps_aligned_alloc. </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is aimed to deallocate only memory allocated with heap_caps_aligned_alloc, memory allocated with heap_caps_malloc MUST not be passed to this function </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ptr</span></code>: Pointer to the memory allocated </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416heap_caps_calloc6size_t6size_t8uint32_t">
<span id="_CPPv316heap_caps_calloc6size_t6size_t8uint32_t"></span><span id="_CPPv216heap_caps_calloc6size_t6size_t8uint32_t"></span><span id="heap_caps_calloc__s.s.uint32_t"></span><span class="target" id="esp__heap__caps_8h_1a8c1ffa70e033b9485580af0078a66cf1"></span>void *<code class="descname">heap_caps_calloc</code><span class="sig-paren">(</span>size_t <em>n</em>, size_t <em>size</em>, uint32_t <em>caps</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416heap_caps_calloc6size_t6size_t8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a chunk of memory which has the given capabilities. The initialized value in the memory is set to zero. </p>
<p>Equivalent semantics to libc calloc(), for capability-aware memory.</p>
<p>In IDF, <code class="docutils literal notranslate"><span class="pre">calloc(p)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">heap_caps_calloc(p,</span> <span class="pre">MALLOC_CAP_8BIT)</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A pointer to the memory allocated on success, NULL on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code>: Number of continuing chunks of memory to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Size, in bytes, of a chunk of memory to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>: Bitwise OR of MALLOC_CAP_* flags indicating the type of memory to be returned</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424heap_caps_get_total_size8uint32_t">
<span id="_CPPv324heap_caps_get_total_size8uint32_t"></span><span id="_CPPv224heap_caps_get_total_size8uint32_t"></span><span id="heap_caps_get_total_size__uint32_t"></span><span class="target" id="esp__heap__caps_8h_1acc9e000e44c005280d4bfb2b0237cb04"></span>size_t <code class="descname">heap_caps_get_total_size</code><span class="sig-paren">(</span>uint32_t <em>caps</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424heap_caps_get_total_size8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the total size of all the regions that have the given capabilities. </p>
<p>This function takes all regions capable of having the given capabilities allocated in them and adds up the total space they have.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>total size in bytes </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>: Bitwise OR of MALLOC_CAP_* flags indicating the type of memory</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423heap_caps_get_free_size8uint32_t">
<span id="_CPPv323heap_caps_get_free_size8uint32_t"></span><span id="_CPPv223heap_caps_get_free_size8uint32_t"></span><span id="heap_caps_get_free_size__uint32_t"></span><span class="target" id="esp__heap__caps_8h_1aba551fca7214bbab39f9dfaa93ce581f"></span>size_t <code class="descname">heap_caps_get_free_size</code><span class="sig-paren">(</span>uint32_t <em>caps</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423heap_caps_get_free_size8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the total free size of all the regions that have the given capabilities. </p>
<p>This function takes all regions capable of having the given capabilities allocated in them and adds up the free space they have.</p>
<p>Note that because of heap fragmentation it is probably not possible to allocate a single block of memory of this size. Use heap_caps_get_largest_free_block() for this purpose.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Amount of free bytes in the regions </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>: Bitwise OR of MALLOC_CAP_* flags indicating the type of memory</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv431heap_caps_get_minimum_free_size8uint32_t">
<span id="_CPPv331heap_caps_get_minimum_free_size8uint32_t"></span><span id="_CPPv231heap_caps_get_minimum_free_size8uint32_t"></span><span id="heap_caps_get_minimum_free_size__uint32_t"></span><span class="target" id="esp__heap__caps_8h_1a9a90e8d38ee9a6a900a90f1dfa5393fb"></span>size_t <code class="descname">heap_caps_get_minimum_free_size</code><span class="sig-paren">(</span>uint32_t <em>caps</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431heap_caps_get_minimum_free_size8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the total minimum free memory of all regions with the given capabilities. </p>
<p>This adds all the low water marks of the regions capable of delivering the memory with the given capabilities.</p>
<p>Note the result may be less than the global all-time minimum available heap of this kind, as “low water marks” are tracked per-region. Individual regions’ heaps may have reached their “low water marks” at different points in time. However this result still gives a “worst case” indication for all-time minimum free heap.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Amount of free bytes in the regions </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>: Bitwise OR of MALLOC_CAP_* flags indicating the type of memory</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv432heap_caps_get_largest_free_block8uint32_t">
<span id="_CPPv332heap_caps_get_largest_free_block8uint32_t"></span><span id="_CPPv232heap_caps_get_largest_free_block8uint32_t"></span><span id="heap_caps_get_largest_free_block__uint32_t"></span><span class="target" id="esp__heap__caps_8h_1a557602c430237f580762415ccfff8c72"></span>size_t <code class="descname">heap_caps_get_largest_free_block</code><span class="sig-paren">(</span>uint32_t <em>caps</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432heap_caps_get_largest_free_block8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the largest free block of memory able to be allocated with the given capabilities. </p>
<p>Returns the largest value of <code class="docutils literal notranslate"><span class="pre">s</span></code> for which <code class="docutils literal notranslate"><span class="pre">heap_caps_malloc(s,</span> <span class="pre">caps)</span></code> will succeed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Size of largest free block in bytes. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>: Bitwise OR of MALLOC_CAP_* flags indicating the type of memory</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418heap_caps_get_infoP17multi_heap_info_t8uint32_t">
<span id="_CPPv318heap_caps_get_infoP17multi_heap_info_t8uint32_t"></span><span id="_CPPv218heap_caps_get_infoP17multi_heap_info_t8uint32_t"></span><span id="heap_caps_get_info__multi_heap_info_tP.uint32_t"></span><span class="target" id="esp__heap__caps_8h_1a149c4d5f97b416d97c43e699297d308d"></span>void <code class="descname">heap_caps_get_info</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv417multi_heap_info_t" title="multi_heap_info_t">multi_heap_info_t</a> *<em>info</em>, uint32_t <em>caps</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418heap_caps_get_infoP17multi_heap_info_t8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get heap info for all regions with the given capabilities. </p>
<p>Calls multi_heap_info() on all heaps which share the given capabilities. The information returned is an aggregate across all matching heaps. The meanings of fields are the same as defined for <a class="reference internal" href="#structmulti__heap__info__t"><span class="std std-ref">multi_heap_info_t</span></a>, except that <code class="docutils literal notranslate"><span class="pre">minimum_free_bytes</span></code> has the same caveats described in heap_caps_get_minimum_free_size().</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">info</span></code>: Pointer to a structure which will be filled with relevant heap metadata. </li>
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>: Bitwise OR of MALLOC_CAP_* flags indicating the type of memory </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425heap_caps_print_heap_info8uint32_t">
<span id="_CPPv325heap_caps_print_heap_info8uint32_t"></span><span id="_CPPv225heap_caps_print_heap_info8uint32_t"></span><span id="heap_caps_print_heap_info__uint32_t"></span><span class="target" id="esp__heap__caps_8h_1a9128a61529561f49fec49416cbe7a1e6"></span>void <code class="descname">heap_caps_print_heap_info</code><span class="sig-paren">(</span>uint32_t <em>caps</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425heap_caps_print_heap_info8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Print a summary of all memory with the given capabilities. </p>
<p>Calls multi_heap_info on all heaps which share the given capabilities, and prints a two-line summary for each, then a total summary.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>: Bitwise OR of MALLOC_CAP_* flags indicating the type of memory </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv429heap_caps_check_integrity_allb">
<span id="_CPPv329heap_caps_check_integrity_allb"></span><span id="_CPPv229heap_caps_check_integrity_allb"></span><span id="heap_caps_check_integrity_all__b"></span><span class="target" id="esp__heap__caps_8h_1a211c894e4d9caf638c3f4969729a42b5"></span>bool <code class="descname">heap_caps_check_integrity_all</code><span class="sig-paren">(</span>bool <em>print_errors</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429heap_caps_check_integrity_allb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check integrity of all heap memory in the system. </p>
<p>Calls multi_heap_check on all heaps. Optionally print errors if heaps are corrupt.</p>
<p>Calling this function is equivalent to calling heap_caps_check_integrity with the caps argument set to MALLOC_CAP_INVALID.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>True if all heaps are valid, False if at least one heap is corrupt. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">print_errors</span></code>: Print specific errors if heap corruption is found.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv425heap_caps_check_integrity8uint32_tb">
<span id="_CPPv325heap_caps_check_integrity8uint32_tb"></span><span id="_CPPv225heap_caps_check_integrity8uint32_tb"></span><span id="heap_caps_check_integrity__uint32_t.b"></span><span class="target" id="esp__heap__caps_8h_1a2a45e5c3e46f6e3b2fe2f09ffa49079f"></span>bool <code class="descname">heap_caps_check_integrity</code><span class="sig-paren">(</span>uint32_t <em>caps</em>, bool <em>print_errors</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425heap_caps_check_integrity8uint32_tb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check integrity of all heaps with the given capabilities. </p>
<p>Calls multi_heap_check on all heaps which share the given capabilities. Optionally print errors if the heaps are corrupt.</p>
<p>See also heap_caps_check_integrity_all to check all heap memory in the system and heap_caps_check_integrity_addr to check memory around a single address.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>True if all heaps are valid, False if at least one heap is corrupt. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>: Bitwise OR of MALLOC_CAP_* flags indicating the type of memory </li>
<li><code class="docutils literal notranslate"><span class="pre">print_errors</span></code>: Print specific errors if heap corruption is found.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv430heap_caps_check_integrity_addr8intptr_tb">
<span id="_CPPv330heap_caps_check_integrity_addr8intptr_tb"></span><span id="_CPPv230heap_caps_check_integrity_addr8intptr_tb"></span><span id="heap_caps_check_integrity_addr__intptr_t.b"></span><span class="target" id="esp__heap__caps_8h_1a70306edd596739207e9b56301d2e3cc5"></span>bool <code class="descname">heap_caps_check_integrity_addr</code><span class="sig-paren">(</span>intptr_t <em>addr</em>, bool <em>print_errors</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430heap_caps_check_integrity_addr8intptr_tb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check integrity of heap memory around a given address. </p>
<p>This function can be used to check the integrity of a single region of heap memory, which contains the given address.</p>
<p>This can be useful if debugging heap integrity for corruption at a known address, as it has a lower overhead than checking all heap regions. Note that if the corrupt address moves around between runs (due to timing or other factors) then this approach won’t work and you should call heap_caps_check_integrity or heap_caps_check_integrity_all instead.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The entire heap region around the address is checked, not only the adjacent heap blocks.</dd>
<dt><strong>Return</strong></dt>
<dd>True if the heap containing the specified address is valid, False if at least one heap is corrupt or the address doesn’t belong to a heap region. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">addr</span></code>: Address in memory. Check for corruption in region containing this address. </li>
<li><code class="docutils literal notranslate"><span class="pre">print_errors</span></code>: Print specific errors if heap corruption is found.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv430heap_caps_malloc_extmem_enable6size_t">
<span id="_CPPv330heap_caps_malloc_extmem_enable6size_t"></span><span id="_CPPv230heap_caps_malloc_extmem_enable6size_t"></span><span id="heap_caps_malloc_extmem_enable__s"></span><span class="target" id="esp__heap__caps_8h_1a94574f33deb2cacc7ed5b5ce3920440f"></span>void <code class="descname">heap_caps_malloc_extmem_enable</code><span class="sig-paren">(</span>size_t <em>limit</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430heap_caps_malloc_extmem_enable6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enable malloc() in external memory and set limit below which malloc() attempts are placed in internal memory. </p>
<p>When external memory is in use, the allocation strategy is to initially try to satisfy smaller allocation requests with internal memory and larger requests with external memory. This sets the limit between the two, as well as generally enabling allocation in external memory.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">limit</span></code>: Limit, in bytes. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423heap_caps_malloc_prefer6size_t6size_tz">
<span id="_CPPv323heap_caps_malloc_prefer6size_t6size_tz"></span><span id="_CPPv223heap_caps_malloc_prefer6size_t6size_tz"></span><span id="heap_caps_malloc_prefer__s.s.z"></span><span class="target" id="esp__heap__caps_8h_1a7744d1d1932294a1171b684e9633d096"></span>void *<code class="descname">heap_caps_malloc_prefer</code><span class="sig-paren">(</span>size_t <em>size</em>, size_t <em>num</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423heap_caps_malloc_prefer6size_t6size_tz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a chunk of memory as preference in decreasing order. </p>
<p><dl class="docutils">
<dt><strong>Attention</strong></dt>
<dd>The variable parameters are bitwise OR of MALLOC_CAP_* flags indicating the type of memory. This API prefers to allocate memory with the first parameter. If failed, allocate memory with the next parameter. It will try in this order until allocating a chunk of memory successfully or fail to allocate memories with any of the parameters.</dd>
<dt><strong>Return</strong></dt>
<dd>A pointer to the memory allocated on success, NULL on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Size, in bytes, of the amount of memory to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">num</span></code>: Number of variable paramters</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv424heap_caps_realloc_preferPv6size_t6size_tz">
<span id="_CPPv324heap_caps_realloc_preferPv6size_t6size_tz"></span><span id="_CPPv224heap_caps_realloc_preferPv6size_t6size_tz"></span><span id="heap_caps_realloc_prefer__voidP.s.s.z"></span><span class="target" id="esp__heap__caps_8h_1a2953dd52680bec9536f305856e709b4a"></span>void *<code class="descname">heap_caps_realloc_prefer</code><span class="sig-paren">(</span>void *<em>ptr</em>, size_t <em>size</em>, size_t <em>num</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424heap_caps_realloc_preferPv6size_t6size_tz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a chunk of memory as preference in decreasing order. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Pointer to a new buffer of size ‘size’, or NULL if allocation failed. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ptr</span></code>: Pointer to previously allocated memory, or NULL for a new allocation. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Size of the new buffer requested, or 0 to free the buffer. </li>
<li><code class="docutils literal notranslate"><span class="pre">num</span></code>: Number of variable paramters</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423heap_caps_calloc_prefer6size_t6size_t6size_tz">
<span id="_CPPv323heap_caps_calloc_prefer6size_t6size_t6size_tz"></span><span id="_CPPv223heap_caps_calloc_prefer6size_t6size_t6size_tz"></span><span id="heap_caps_calloc_prefer__s.s.s.z"></span><span class="target" id="esp__heap__caps_8h_1aa05e878ed334b584bcb0b2c6229e4b2b"></span>void *<code class="descname">heap_caps_calloc_prefer</code><span class="sig-paren">(</span>size_t <em>n</em>, size_t <em>size</em>, size_t <em>num</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423heap_caps_calloc_prefer6size_t6size_t6size_tz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a chunk of memory as preference in decreasing order. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A pointer to the memory allocated on success, NULL on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code>: Number of continuing chunks of memory to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Size, in bytes, of a chunk of memory to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">num</span></code>: Number of variable paramters</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv414heap_caps_dump8uint32_t">
<span id="_CPPv314heap_caps_dump8uint32_t"></span><span id="_CPPv214heap_caps_dump8uint32_t"></span><span id="heap_caps_dump__uint32_t"></span><span class="target" id="esp__heap__caps_8h_1ae19d3bc2f6f027fe30e47cbf991f1a6b"></span>void <code class="descname">heap_caps_dump</code><span class="sig-paren">(</span>uint32_t <em>caps</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414heap_caps_dump8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Dump the full structure of all heaps with matching capabilities. </p>
<p>Prints a large amount of output to serial (because of locking limitations, the output bypasses stdout/stderr). For each (variable sized) block in each matching heap, the following output is printed on a single line:</p>
<p><ul class="simple">
<li>Block address (the data buffer returned by malloc is 4 bytes after this if heap debugging is set to Basic, or 8 bytes otherwise).</li>
<li>Data size (the data size may be larger than the size requested by malloc, either due to heap fragmentation or because of heap debugging level).</li>
<li>Address of next block in the heap.</li>
<li>If the block is free, the address of the next free block is also printed.</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>: Bitwise OR of MALLOC_CAP_* flags indicating the type of memory </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418heap_caps_dump_allv">
<span id="_CPPv318heap_caps_dump_allv"></span><span id="_CPPv218heap_caps_dump_allv"></span><span id="heap_caps_dump_all__void"></span><span class="target" id="esp__heap__caps_8h_1a38a354fb76dfa5b8f9ea0755455ff02b"></span>void <code class="descname">heap_caps_dump_all</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418heap_caps_dump_allv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Dump the full structure of all heaps. </p>
<p>Covers all registered heaps. Prints a large amount of output to serial.</p>
<p>Output is the same as for heap_caps_dump. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv428heap_caps_get_allocated_sizePv">
<span id="_CPPv328heap_caps_get_allocated_sizePv"></span><span id="_CPPv228heap_caps_get_allocated_sizePv"></span><span id="heap_caps_get_allocated_size__voidP"></span><span class="target" id="esp__heap__caps_8h_1a048217cbb477451ec4739bdac4021583"></span>size_t <code class="descname">heap_caps_get_allocated_size</code><span class="sig-paren">(</span>void *<em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428heap_caps_get_allocated_sizePv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the size that a particular pointer was allocated with. </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The app will crash with an assertion failure if the pointer is not valid.</dd>
<dt><strong>Return</strong></dt>
<dd>Size of the memory allocated at this block. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ptr</span></code>: Pointer to currently allocated heap memory. Must be a pointer value previously returned by heap_caps_malloc,malloc,calloc, etc. and not yet freed.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="macros">
<h3>Macros<a class="headerlink" href="#macros" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.MALLOC_CAP_EXEC">
<span class="target" id="esp__heap__caps_8h_1a7c96cafcb8ab916f84bca17603ec7ba7"></span><code class="descname">MALLOC_CAP_EXEC</code><a class="headerlink" href="#c.MALLOC_CAP_EXEC" title="Permalink to this definition">¶</a></dt>
<dd><p>Flags to indicate the capabilities of the various memory systems. </p>
<p>Memory must be able to run executable code </p>
</dd></dl>

<dl class="macro">
<dt id="c.MALLOC_CAP_32BIT">
<span class="target" id="esp__heap__caps_8h_1a826059625c016d96c251325d6673e096"></span><code class="descname">MALLOC_CAP_32BIT</code><a class="headerlink" href="#c.MALLOC_CAP_32BIT" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory must allow for aligned 32-bit data accesses. </p>
</dd></dl>

<dl class="macro">
<dt id="c.MALLOC_CAP_8BIT">
<span class="target" id="esp__heap__caps_8h_1aac0f0a20c619ae2e979820ffbf2a74ca"></span><code class="descname">MALLOC_CAP_8BIT</code><a class="headerlink" href="#c.MALLOC_CAP_8BIT" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory must allow for 8/16/…-bit data accesses. </p>
</dd></dl>

<dl class="macro">
<dt id="c.MALLOC_CAP_DMA">
<span class="target" id="esp__heap__caps_8h_1ad54f7d30a5138ac70088b9532043ebd7"></span><code class="descname">MALLOC_CAP_DMA</code><a class="headerlink" href="#c.MALLOC_CAP_DMA" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory must be able to accessed by DMA. </p>
</dd></dl>

<dl class="macro">
<dt id="c.MALLOC_CAP_PID2">
<span class="target" id="esp__heap__caps_8h_1a3673338a10ab2461426397b1f08b1f46"></span><code class="descname">MALLOC_CAP_PID2</code><a class="headerlink" href="#c.MALLOC_CAP_PID2" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory must be mapped to PID2 memory space (PIDs are not currently used) </p>
</dd></dl>

<dl class="macro">
<dt id="c.MALLOC_CAP_PID3">
<span class="target" id="esp__heap__caps_8h_1a0de919b5cc5d4d45f645a3386c717a6e"></span><code class="descname">MALLOC_CAP_PID3</code><a class="headerlink" href="#c.MALLOC_CAP_PID3" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory must be mapped to PID3 memory space (PIDs are not currently used) </p>
</dd></dl>

<dl class="macro">
<dt id="c.MALLOC_CAP_PID4">
<span class="target" id="esp__heap__caps_8h_1a3d003de2672f6516e41c6af17b14dcd3"></span><code class="descname">MALLOC_CAP_PID4</code><a class="headerlink" href="#c.MALLOC_CAP_PID4" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory must be mapped to PID4 memory space (PIDs are not currently used) </p>
</dd></dl>

<dl class="macro">
<dt id="c.MALLOC_CAP_PID5">
<span class="target" id="esp__heap__caps_8h_1ac9769710e6abd937d3b3b9d06ffb4fc2"></span><code class="descname">MALLOC_CAP_PID5</code><a class="headerlink" href="#c.MALLOC_CAP_PID5" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory must be mapped to PID5 memory space (PIDs are not currently used) </p>
</dd></dl>

<dl class="macro">
<dt id="c.MALLOC_CAP_PID6">
<span class="target" id="esp__heap__caps_8h_1abecfbaa7697633318a031eff5ea50dc6"></span><code class="descname">MALLOC_CAP_PID6</code><a class="headerlink" href="#c.MALLOC_CAP_PID6" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory must be mapped to PID6 memory space (PIDs are not currently used) </p>
</dd></dl>

<dl class="macro">
<dt id="c.MALLOC_CAP_PID7">
<span class="target" id="esp__heap__caps_8h_1a6f793bf08b8197cc457062ecba25b984"></span><code class="descname">MALLOC_CAP_PID7</code><a class="headerlink" href="#c.MALLOC_CAP_PID7" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory must be mapped to PID7 memory space (PIDs are not currently used) </p>
</dd></dl>

<dl class="macro">
<dt id="c.MALLOC_CAP_SPIRAM">
<span class="target" id="esp__heap__caps_8h_1ace53477a25da151b259cb66c4c486f48"></span><code class="descname">MALLOC_CAP_SPIRAM</code><a class="headerlink" href="#c.MALLOC_CAP_SPIRAM" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory must be in SPI RAM. </p>
</dd></dl>

<dl class="macro">
<dt id="c.MALLOC_CAP_INTERNAL">
<span class="target" id="esp__heap__caps_8h_1a5f2f4d8ffb828c43078750c475cf6047"></span><code class="descname">MALLOC_CAP_INTERNAL</code><a class="headerlink" href="#c.MALLOC_CAP_INTERNAL" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory must be internal; specifically it should not disappear when flash/spiram cache is switched off. </p>
</dd></dl>

<dl class="macro">
<dt id="c.MALLOC_CAP_DEFAULT">
<span class="target" id="esp__heap__caps_8h_1ac2819ab42951525fcea5025c268f069c"></span><code class="descname">MALLOC_CAP_DEFAULT</code><a class="headerlink" href="#c.MALLOC_CAP_DEFAULT" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory can be returned in a non-capability-specific memory allocation (e.g. malloc(), calloc()) call. </p>
</dd></dl>

<dl class="macro">
<dt id="c.MALLOC_CAP_INVALID">
<span class="target" id="esp__heap__caps_8h_1ab711dea757d655e249112adc67a879ad"></span><code class="descname">MALLOC_CAP_INVALID</code><a class="headerlink" href="#c.MALLOC_CAP_INVALID" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory can’t be used / list end marker. </p>
</dd></dl>

</div>
<div class="section" id="thread-safety">
<h3>Thread Safety<a class="headerlink" href="#thread-safety" title="Permalink to this headline">¶</a></h3>
<p>Heap functions are thread safe, meaning they can be called from different tasks simultaneously without any limitations.</p>
<p>It is technically possible to call <code class="docutils literal notranslate"><span class="pre">malloc</span></code>, <code class="docutils literal notranslate"><span class="pre">free</span></code>, and related functions from interrupt handler (ISR) context. However this is not recommended, as heap function calls may delay other interrupts. It is strongly recommended to refactor applications so that any buffers used by an ISR are pre-allocated outside of the ISR. Support for calling heap functions from ISRs may be removed in a future update.</p>
</div>
</div>
<div class="section" id="heap-tracing-debugging">
<h2>Heap Tracing &amp; Debugging<a class="headerlink" href="#heap-tracing-debugging" title="Permalink to this headline">¶</a></h2>
<p>The following features are documented on the <a class="reference internal" href="heap_debug.html"><span class="doc">Heap Memory Debugging</span></a> page:</p>
<ul class="simple">
<li><a class="reference internal" href="heap_debug.html#heap-information"><span class="std std-ref">Heap Information</span></a> (free space, etc.)</li>
<li><a class="reference internal" href="heap_debug.html#heap-corruption"><span class="std std-ref">Heap Corruption Detection</span></a></li>
<li><a class="reference internal" href="heap_debug.html#heap-tracing"><span class="std std-ref">Heap Tracing</span></a> (memory leak detection, monitoring, etc.)</li>
</ul>
</div>
<div class="section" id="api-reference-initialisation">
<h2>API Reference - Initialisation<a class="headerlink" href="#api-reference-initialisation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id3">
<h3>Header File<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/heap/include/esp_heap_caps_init.h">heap/include/esp_heap_caps_init.h</a></li>
</ul>
</div>
<div class="section" id="id4">
<h3>Functions<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv414heap_caps_initv">
<span id="_CPPv314heap_caps_initv"></span><span id="_CPPv214heap_caps_initv"></span><span id="heap_caps_init__void"></span><span class="target" id="esp__heap__caps__init_8h_1abacfe65210ed89804126b128dcdc6db0"></span>void <code class="descname">heap_caps_init</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414heap_caps_initv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initialize the capability-aware heap allocator. </p>
<p>This is called once in the IDF startup code. Do not call it at other times. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv434heap_caps_enable_nonos_stack_heapsv">
<span id="_CPPv334heap_caps_enable_nonos_stack_heapsv"></span><span id="_CPPv234heap_caps_enable_nonos_stack_heapsv"></span><span id="heap_caps_enable_nonos_stack_heaps__void"></span><span class="target" id="esp__heap__caps__init_8h_1af5c1dc12cab8b7acd97863f433316c19"></span>void <code class="descname">heap_caps_enable_nonos_stack_heaps</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv434heap_caps_enable_nonos_stack_heapsv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enable heap(s) in memory regions where the startup stacks are located. </p>
<p>On startup, the pro/app CPUs have a certain memory region they use as stack, so we cannot do allocations in the regions these stack frames are. When FreeRTOS is completely started, they do not use that memory anymore and heap(s) there can be enabled. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420heap_caps_add_region8intptr_t8intptr_t">
<span id="_CPPv320heap_caps_add_region8intptr_t8intptr_t"></span><span id="_CPPv220heap_caps_add_region8intptr_t8intptr_t"></span><span id="heap_caps_add_region__intptr_t.intptr_t"></span><span class="target" id="esp__heap__caps__init_8h_1ae22488c4edee3a2bff04a19938dc7b23"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">heap_caps_add_region</code><span class="sig-paren">(</span>intptr_t <em>start</em>, intptr_t <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420heap_caps_add_region8intptr_t8intptr_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a region of memory to the collection of heaps at runtime. </p>
<p>Most memory regions are defined in soc_memory_layout.c for the SoC, and are registered via heap_caps_init(). Some regions can’t be used immediately and are later enabled via heap_caps_enable_nonos_stack_heaps().</p>
<p>Call this function to add a region of memory to the heap at some later time.</p>
<p>This function does not consider any of the “reserved” regions or other data in soc_memory_layout, caller needs to consider this themselves.</p>
<p>All memory within the region specified by start &amp; end parameters must be otherwise unused.</p>
<p>The capabilities of the newly registered memory will be determined by the start address, as looked up in the regions specified in soc_memory_layout.c.</p>
<p>Use heap_caps_add_region_with_caps() to register a region with custom capabilities.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>ESP_OK on success, ESP_ERR_INVALID_ARG if a parameter is invalid, ESP_ERR_NOT_FOUND if the specified start address doesn’t reside in a known region, or any error returned by heap_caps_add_region_with_caps(). </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">start</span></code>: Start address of new region. </li>
<li><code class="docutils literal notranslate"><span class="pre">end</span></code>: End address of new region.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv430heap_caps_add_region_with_capsA_K8uint32_t8intptr_t8intptr_t">
<span id="_CPPv330heap_caps_add_region_with_capsA_K8uint32_t8intptr_t8intptr_t"></span><span id="_CPPv230heap_caps_add_region_with_capsA_K8uint32_t8intptr_t8intptr_t"></span><span id="heap_caps_add_region_with_caps__uint32_tCA.intptr_t.intptr_t"></span><span class="target" id="esp__heap__caps__init_8h_1a6960ca17873b47de977541b37cde3404"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">heap_caps_add_region_with_caps</code><span class="sig-paren">(</span><em class="property">const</em> uint32_t <em>caps</em>[], intptr_t <em>start</em>, intptr_t <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430heap_caps_add_region_with_capsA_K8uint32_t8intptr_t8intptr_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a region of memory to the collection of heaps at runtime, with custom capabilities. </p>
<p>Similar to heap_caps_add_region(), only custom memory capabilities are specified by the caller.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>ESP_OK on success</li>
<li>ESP_ERR_INVALID_ARG if a parameter is invalid</li>
<li>ESP_ERR_NO_MEM if no memory to register new heap.</li>
<li>ESP_ERR_INVALID_SIZE if the memory region is too small to fit a heap</li>
<li>ESP_FAIL if region overlaps the start and/or end of an existing region </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>: Ordered array of capability masks for the new region, in order of priority. Must have length SOC_MEMORY_TYPE_NO_PRIOS. Does not need to remain valid after the call returns. </li>
<li><code class="docutils literal notranslate"><span class="pre">start</span></code>: Start address of new region. </li>
<li><code class="docutils literal notranslate"><span class="pre">end</span></code>: End address of new region.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</div>
<div class="section" id="implementation-notes">
<h2>Implementation Notes<a class="headerlink" href="#implementation-notes" title="Permalink to this headline">¶</a></h2>
<p>Knowledge about the regions of memory in the chip comes from the “soc” component, which contains memory layout information for the chip, and the different capabilities of each region. Each region’s capabilities are prioritised, so that (for example) dedicated DRAM and IRAM regions will be used for allocations ahead of the more versatile D/IRAM regions.</p>
<p>Each contiguous region of memory contains its own memory heap. The heaps are created using the <a class="reference external" href="APIReference-MultiHeapAPI.html">multi_heap</a> functionality. multi_heap allows any contiguous region of memory to be used as a heap.</p>
<p>The heap capabilities allocator uses knowledge of the memory regions to initialize each individual heap. Allocation functions in the heap capabilities API will find the most appropriate heap for the allocation (based on desired capabilities, available space, and preferences for each region’s use) and then calling <a class="reference internal" href="#_CPPv417multi_heap_malloc19multi_heap_handle_t6size_t" title="multi_heap_malloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">multi_heap_malloc()</span></code></a> or <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">multi_heap_calloc()</span></code> for the heap situated in that particular region.</p>
<p>Calling <code class="docutils literal notranslate"><span class="pre">free()</span></code> involves finding the particular heap corresponding to the freed address, and then calling <a class="reference internal" href="#_CPPv415multi_heap_free19multi_heap_handle_tPv" title="multi_heap_free"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">multi_heap_free()</span></code></a> on that particular multi_heap instance.</p>
</div>
<div class="section" id="api-reference-multi-heap-api">
<h2>API Reference - Multi Heap API<a class="headerlink" href="#api-reference-multi-heap-api" title="Permalink to this headline">¶</a></h2>
<p>(Note: The multi heap API is used internally by the heap capabilities allocator. Most IDF programs will never need to call this API directly.)</p>
<div class="section" id="id5">
<h3>Header File<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/heap/include/multi_heap.h">heap/include/multi_heap.h</a></li>
</ul>
</div>
<div class="section" id="id6">
<h3>Functions<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv424multi_heap_aligned_alloc19multi_heap_handle_t6size_t6size_t">
<span id="_CPPv324multi_heap_aligned_alloc19multi_heap_handle_t6size_t6size_t"></span><span id="_CPPv224multi_heap_aligned_alloc19multi_heap_handle_t6size_t6size_t"></span><span id="multi_heap_aligned_alloc__multi_heap_handle_t.s.s"></span><span class="target" id="multi__heap_8h_1a3cc0c646637c5a8b7ba32bef73ef8cf2"></span>void *<code class="descname">multi_heap_aligned_alloc</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">multi_heap_handle_t</a> <em>heap</em>, size_t <em>size</em>, size_t <em>alignment</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424multi_heap_aligned_alloc19multi_heap_handle_t6size_t6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>allocate a chunk of memory with specific alignment </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>pointer to the memory allocated, NULL on failure </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: Handle to a registered heap. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: size in bytes of memory chunk </li>
<li><code class="docutils literal notranslate"><span class="pre">alignment</span></code>: how the memory must be aligned</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417multi_heap_malloc19multi_heap_handle_t6size_t">
<span id="_CPPv317multi_heap_malloc19multi_heap_handle_t6size_t"></span><span id="_CPPv217multi_heap_malloc19multi_heap_handle_t6size_t"></span><span id="multi_heap_malloc__multi_heap_handle_t.s"></span><span class="target" id="multi__heap_8h_1ac212763e8d7784e6d497e1f43b2df28e"></span>void *<code class="descname">multi_heap_malloc</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">multi_heap_handle_t</a> <em>heap</em>, size_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417multi_heap_malloc19multi_heap_handle_t6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>malloc() a buffer in a given heap </p>
<p>Semantics are the same as standard malloc(), only the returned buffer will be allocated in the specified heap.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Pointer to new memory, or NULL if allocation fails. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: Handle to a registered heap. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Size of desired buffer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv423multi_heap_aligned_free19multi_heap_handle_tPv">
<span id="_CPPv323multi_heap_aligned_free19multi_heap_handle_tPv"></span><span id="_CPPv223multi_heap_aligned_free19multi_heap_handle_tPv"></span><span id="multi_heap_aligned_free__multi_heap_handle_t.voidP"></span><span class="target" id="multi__heap_8h_1a96b36bfa54860ff4d98f218d5c472d7d"></span>void <code class="descname">multi_heap_aligned_free</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">multi_heap_handle_t</a> <em>heap</em>, void *<em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423multi_heap_aligned_free19multi_heap_handle_tPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>free() a buffer aligned in a given heap. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: Handle to a registered heap. </li>
<li><code class="docutils literal notranslate"><span class="pre">p</span></code>: NULL, or a pointer previously returned from multi_heap_aligned_alloc() for the same heap. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415multi_heap_free19multi_heap_handle_tPv">
<span id="_CPPv315multi_heap_free19multi_heap_handle_tPv"></span><span id="_CPPv215multi_heap_free19multi_heap_handle_tPv"></span><span id="multi_heap_free__multi_heap_handle_t.voidP"></span><span class="target" id="multi__heap_8h_1a57ece2f1499c39b5756498ec331bd468"></span>void <code class="descname">multi_heap_free</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">multi_heap_handle_t</a> <em>heap</em>, void *<em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415multi_heap_free19multi_heap_handle_tPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>free() a buffer in a given heap. </p>
<p>Semantics are the same as standard free(), only the argument ‘p’ must be NULL or have been allocated in the specified heap.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: Handle to a registered heap. </li>
<li><code class="docutils literal notranslate"><span class="pre">p</span></code>: NULL, or a pointer previously returned from multi_heap_malloc() or multi_heap_realloc() for the same heap. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418multi_heap_realloc19multi_heap_handle_tPv6size_t">
<span id="_CPPv318multi_heap_realloc19multi_heap_handle_tPv6size_t"></span><span id="_CPPv218multi_heap_realloc19multi_heap_handle_tPv6size_t"></span><span id="multi_heap_realloc__multi_heap_handle_t.voidP.s"></span><span class="target" id="multi__heap_8h_1a9d3f3a85cb7c2581e5d822bb2682d8c9"></span>void *<code class="descname">multi_heap_realloc</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">multi_heap_handle_t</a> <em>heap</em>, void *<em>p</em>, size_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418multi_heap_realloc19multi_heap_handle_tPv6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>realloc() a buffer in a given heap. </p>
<p>Semantics are the same as standard realloc(), only the argument ‘p’ must be NULL or have been allocated in the specified heap.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>New buffer of ‘size’ containing contents of ‘p’, or NULL if reallocation failed. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: Handle to a registered heap. </li>
<li><code class="docutils literal notranslate"><span class="pre">p</span></code>: NULL, or a pointer previously returned from multi_heap_malloc() or multi_heap_realloc() for the same heap. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Desired new size for buffer.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv429multi_heap_get_allocated_size19multi_heap_handle_tPv">
<span id="_CPPv329multi_heap_get_allocated_size19multi_heap_handle_tPv"></span><span id="_CPPv229multi_heap_get_allocated_size19multi_heap_handle_tPv"></span><span id="multi_heap_get_allocated_size__multi_heap_handle_t.voidP"></span><span class="target" id="multi__heap_8h_1af88d5a13cce47e48c329ef86f29f5fa2"></span>size_t <code class="descname">multi_heap_get_allocated_size</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">multi_heap_handle_t</a> <em>heap</em>, void *<em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429multi_heap_get_allocated_size19multi_heap_handle_tPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the size that a particular pointer was allocated with. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Size of the memory allocated at this block. May be more than the original size argument, due to padding and minimum block sizes. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: Handle to a registered heap. </li>
<li><code class="docutils literal notranslate"><span class="pre">p</span></code>: Pointer, must have been previously returned from multi_heap_malloc() or multi_heap_realloc() for the same heap.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419multi_heap_registerPv6size_t">
<span id="_CPPv319multi_heap_registerPv6size_t"></span><span id="_CPPv219multi_heap_registerPv6size_t"></span><span id="multi_heap_register__voidP.s"></span><span class="target" id="multi__heap_8h_1a83ee39aa9c03378c9eb32dc45c27f016"></span><a class="reference internal" href="#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">multi_heap_handle_t</a> <code class="descname">multi_heap_register</code><span class="sig-paren">(</span>void *<em>start</em>, size_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419multi_heap_registerPv6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register a new heap for use. </p>
<p>This function initialises a heap at the specified address, and returns a handle for future heap operations.</p>
<p>There is no equivalent function for deregistering a heap - if all blocks in the heap are free, you can immediately start using the memory for other purposes.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Handle of a new heap ready for use, or NULL if the heap region was too small to be initialised. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">start</span></code>: Start address of the memory to use for a new heap. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Size (in bytes) of the new heap.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419multi_heap_set_lock19multi_heap_handle_tPv">
<span id="_CPPv319multi_heap_set_lock19multi_heap_handle_tPv"></span><span id="_CPPv219multi_heap_set_lock19multi_heap_handle_tPv"></span><span id="multi_heap_set_lock__multi_heap_handle_t.voidP"></span><span class="target" id="multi__heap_8h_1af1e3c624610b9768289eb95496f6cdeb"></span>void <code class="descname">multi_heap_set_lock</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">multi_heap_handle_t</a> <em>heap</em>, void *<em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419multi_heap_set_lock19multi_heap_handle_tPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Associate a private lock pointer with a heap. </p>
<p>The lock argument is supplied to the MULTI_HEAP_LOCK() and MULTI_HEAP_UNLOCK() macros, defined in multi_heap_platform.h.</p>
<p>The lock in question must be recursive.</p>
<p>When the heap is first registered, the associated lock is NULL.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: Handle to a registered heap. </li>
<li><code class="docutils literal notranslate"><span class="pre">lock</span></code>: Optional pointer to a locking structure to associate with this heap. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv415multi_heap_dump19multi_heap_handle_t">
<span id="_CPPv315multi_heap_dump19multi_heap_handle_t"></span><span id="_CPPv215multi_heap_dump19multi_heap_handle_t"></span><span id="multi_heap_dump__multi_heap_handle_t"></span><span class="target" id="multi__heap_8h_1a498d52c8ab07c5863ce49cc142b01828"></span>void <code class="descname">multi_heap_dump</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">multi_heap_handle_t</a> <em>heap</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415multi_heap_dump19multi_heap_handle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Dump heap information to stdout. </p>
<p>For debugging purposes, this function dumps information about every block in the heap to stdout.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: Handle to a registered heap. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416multi_heap_check19multi_heap_handle_tb">
<span id="_CPPv316multi_heap_check19multi_heap_handle_tb"></span><span id="_CPPv216multi_heap_check19multi_heap_handle_tb"></span><span id="multi_heap_check__multi_heap_handle_t.b"></span><span class="target" id="multi__heap_8h_1ad1f307768d124bc73ec03a44ef28d740"></span>bool <code class="descname">multi_heap_check</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">multi_heap_handle_t</a> <em>heap</em>, bool <em>print_errors</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416multi_heap_check19multi_heap_handle_tb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check heap integrity. </p>
<p>Walks the heap and checks all heap data structures are valid. If any errors are detected, an error-specific message can be optionally printed to stderr. Print behaviour can be overriden at compile time by defining MULTI_CHECK_FAIL_PRINTF in multi_heap_platform.h.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>true if heap is valid, false otherwise. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: Handle to a registered heap. </li>
<li><code class="docutils literal notranslate"><span class="pre">print_errors</span></code>: If true, errors will be printed to stderr. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420multi_heap_free_size19multi_heap_handle_t">
<span id="_CPPv320multi_heap_free_size19multi_heap_handle_t"></span><span id="_CPPv220multi_heap_free_size19multi_heap_handle_t"></span><span id="multi_heap_free_size__multi_heap_handle_t"></span><span class="target" id="multi__heap_8h_1a31baeeba41b9560413af745b33c5b6b5"></span>size_t <code class="descname">multi_heap_free_size</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">multi_heap_handle_t</a> <em>heap</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420multi_heap_free_size19multi_heap_handle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return free heap size. </p>
<p>Returns the number of bytes available in the heap.</p>
<p>Equivalent to the total_free_bytes member returned by multi_heap_get_heap_info().</p>
<p>Note that the heap may be fragmented, so the actual maximum size for a single malloc() may be lower. To know this size, see the largest_free_block member returned by multi_heap_get_heap_info().</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Number of free bytes. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: Handle to a registered heap. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv428multi_heap_minimum_free_size19multi_heap_handle_t">
<span id="_CPPv328multi_heap_minimum_free_size19multi_heap_handle_t"></span><span id="_CPPv228multi_heap_minimum_free_size19multi_heap_handle_t"></span><span id="multi_heap_minimum_free_size__multi_heap_handle_t"></span><span class="target" id="multi__heap_8h_1a7073b215edc403edd4ef7083d8f86e13"></span>size_t <code class="descname">multi_heap_minimum_free_size</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">multi_heap_handle_t</a> <em>heap</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428multi_heap_minimum_free_size19multi_heap_handle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the lifetime minimum free heap size. </p>
<p>Equivalent to the minimum_free_bytes member returned by multi_heap_get_info().</p>
<p>Returns the lifetime “low water mark” of possible values returned from multi_free_heap_size(), for the specified heap.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Number of free bytes. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: Handle to a registered heap. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419multi_heap_get_info19multi_heap_handle_tP17multi_heap_info_t">
<span id="_CPPv319multi_heap_get_info19multi_heap_handle_tP17multi_heap_info_t"></span><span id="_CPPv219multi_heap_get_info19multi_heap_handle_tP17multi_heap_info_t"></span><span id="multi_heap_get_info__multi_heap_handle_t.multi_heap_info_tP"></span><span class="target" id="multi__heap_8h_1aad3673c369c1efc02fd8aa1cbebcf713"></span>void <code class="descname">multi_heap_get_info</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">multi_heap_handle_t</a> <em>heap</em>, <a class="reference internal" href="#_CPPv417multi_heap_info_t" title="multi_heap_info_t">multi_heap_info_t</a> *<em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419multi_heap_get_info19multi_heap_handle_tP17multi_heap_info_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return metadata about a given heap. </p>
<p>Fills a <a class="reference internal" href="#structmulti__heap__info__t"><span class="std std-ref">multi_heap_info_t</span></a> structure with information about the specified heap.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: Handle to a registered heap. </li>
<li><code class="docutils literal notranslate"><span class="pre">info</span></code>: Pointer to a structure to fill with heap metadata. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="structures">
<h3>Structures<a class="headerlink" href="#structures" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv417multi_heap_info_t">
<span id="_CPPv317multi_heap_info_t"></span><span id="_CPPv217multi_heap_info_t"></span><span id="multi_heap_info_t"></span><span class="target" id="structmulti__heap__info__t"></span><em class="property">struct </em><code class="descname">multi_heap_info_t</code><a class="headerlink" href="#_CPPv417multi_heap_info_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Structure to access heap metadata via multi_heap_get_info. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv4N17multi_heap_info_t16total_free_bytesE">
<span id="_CPPv3N17multi_heap_info_t16total_free_bytesE"></span><span id="_CPPv2N17multi_heap_info_t16total_free_bytesE"></span><span id="multi_heap_info_t::total_free_bytes__s"></span><span class="target" id="structmulti__heap__info__t_1a579d218a5e7be434de0e06c4a5e2fc44"></span>size_t <code class="descname">total_free_bytes</code><a class="headerlink" href="#_CPPv4N17multi_heap_info_t16total_free_bytesE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Total free bytes in the heap. Equivalent to multi_free_heap_size(). </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N17multi_heap_info_t21total_allocated_bytesE">
<span id="_CPPv3N17multi_heap_info_t21total_allocated_bytesE"></span><span id="_CPPv2N17multi_heap_info_t21total_allocated_bytesE"></span><span id="multi_heap_info_t::total_allocated_bytes__s"></span><span class="target" id="structmulti__heap__info__t_1af7ac7bb9523d54bc65ff43ca695eaa4d"></span>size_t <code class="descname">total_allocated_bytes</code><a class="headerlink" href="#_CPPv4N17multi_heap_info_t21total_allocated_bytesE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Total bytes allocated to data in the heap. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N17multi_heap_info_t18largest_free_blockE">
<span id="_CPPv3N17multi_heap_info_t18largest_free_blockE"></span><span id="_CPPv2N17multi_heap_info_t18largest_free_blockE"></span><span id="multi_heap_info_t::largest_free_block__s"></span><span class="target" id="structmulti__heap__info__t_1ab1f0470a7a39d0ff6624aa3a51ebe314"></span>size_t <code class="descname">largest_free_block</code><a class="headerlink" href="#_CPPv4N17multi_heap_info_t18largest_free_blockE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Size of largest free block in the heap. This is the largest malloc-able size. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N17multi_heap_info_t18minimum_free_bytesE">
<span id="_CPPv3N17multi_heap_info_t18minimum_free_bytesE"></span><span id="_CPPv2N17multi_heap_info_t18minimum_free_bytesE"></span><span id="multi_heap_info_t::minimum_free_bytes__s"></span><span class="target" id="structmulti__heap__info__t_1aaae058568c1b0c400bf53060c64d1193"></span>size_t <code class="descname">minimum_free_bytes</code><a class="headerlink" href="#_CPPv4N17multi_heap_info_t18minimum_free_bytesE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Lifetime minimum free heap size. Equivalent to multi_minimum_free_heap_size(). </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N17multi_heap_info_t16allocated_blocksE">
<span id="_CPPv3N17multi_heap_info_t16allocated_blocksE"></span><span id="_CPPv2N17multi_heap_info_t16allocated_blocksE"></span><span id="multi_heap_info_t::allocated_blocks__s"></span><span class="target" id="structmulti__heap__info__t_1a216a36cb5c73cec2f2a1afafdbdb4727"></span>size_t <code class="descname">allocated_blocks</code><a class="headerlink" href="#_CPPv4N17multi_heap_info_t16allocated_blocksE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Number of (variable size) blocks allocated in the heap. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N17multi_heap_info_t11free_blocksE">
<span id="_CPPv3N17multi_heap_info_t11free_blocksE"></span><span id="_CPPv2N17multi_heap_info_t11free_blocksE"></span><span id="multi_heap_info_t::free_blocks__s"></span><span class="target" id="structmulti__heap__info__t_1ab18daccada986848b88c9c61b06183a7"></span>size_t <code class="descname">free_blocks</code><a class="headerlink" href="#_CPPv4N17multi_heap_info_t11free_blocksE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Number of (variable size) free blocks in the heap. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv4N17multi_heap_info_t12total_blocksE">
<span id="_CPPv3N17multi_heap_info_t12total_blocksE"></span><span id="_CPPv2N17multi_heap_info_t12total_blocksE"></span><span id="multi_heap_info_t::total_blocks__s"></span><span class="target" id="structmulti__heap__info__t_1a0298f4fdc59110fe56a29c2e130ea9f7"></span>size_t <code class="descname">total_blocks</code><a class="headerlink" href="#_CPPv4N17multi_heap_info_t12total_blocksE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Total number of (variable size) blocks in the heap. </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="type-definitions">
<h3>Type Definitions<a class="headerlink" href="#type-definitions" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv419multi_heap_handle_t">
<span id="_CPPv319multi_heap_handle_t"></span><span id="_CPPv219multi_heap_handle_t"></span><span id="multi_heap_handle_t"></span><span class="target" id="multi__heap_8h_1a051dfcd4b982e1c1d33930f96fb6539d"></span><em class="property">typedef </em><em class="property">struct</em> multi_heap_info *<code class="descname">multi_heap_handle_t</code><a class="headerlink" href="#_CPPv419multi_heap_handle_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Opaque handle to a registered heap. </p>
</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="heap_debug.html" class="btn btn-neutral float-right" title="Heap Memory Debugging" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="freertos_additions.html" class="btn btn-neutral float-left" title="FreeRTOS Additions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016 - 2019, Espressif Systems (Shanghai) CO., LTD
      
        <span class="commit">
          Revision <code>f9108063</code>.
        </span>
      

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org/">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: latest
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="https://docs.espressif.com/en/latest/">latest</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/stable/">stable</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v4.0-rc/">v4.0-rc</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v4.0-beta2/">v4.0-beta2</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.3.1/">v3.3.1</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.3/">v3.3</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.2.3/">v3.2.3</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.2.2/">v3.2.2</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.1.6/">v3.1.6</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.1.5/">v3.1.5</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/v3.0.9/">v3.0.9</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/release-v4.1/">release-v4.1</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/release-v4.0/">release-v4.0</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/release-v3.3/">release-v3.3</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/release-v3.2/">release-v3.2</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/release-v3.1/">release-v3.1</a></dd>
        
          <dd><a href="https://docs.espressif.com/en/release-v3.0/">release-v3.0</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="http://docs.espressif.com/_/downloads/esp-idf/en/latest/pdf/">pdf</a></dd>
        
      </dl>
      <dl>
        <dt>On Read the Docs</dt>
          <dd>
            <a href="http://readthedocs.com/projects/espressif-esp-idf/?fromdocs=espressif-esp-idf">Project Home</a>
          </dd>
          <dd>
            <a href="http://readthedocs.com/builds/espressif-esp-idf/?fromdocs=espressif-esp-idf">Builds</a>
          </dd>
      </dl>
      <hr/>
      Free document hosting provided by <a href="http://www.readthedocs.org/">Read the Docs</a>.

    </div>
  </div>



  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
   

</body>

<!-- Mirrored from docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/mem_alloc.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 29 Feb 2020 06:26:28 GMT -->
</html>